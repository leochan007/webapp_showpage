{"version":3,"sources":["stores/reducers/account_reducer.ts","stores/reducers/settings_reducer.ts","hooks/account_hook.ts","plugins/i18n.ts","locales/zh_CN/common.ts","locales/zh_CN/menu.ts","locales/zh_CN/home_page.ts","locales/zh_CN/trading_page.ts","locales/zh_CN/footer.ts","locales/en_US/common.ts","locales/en_US/menu.ts","locales/en_US/home_page.ts","locales/en_US/trading_page.ts","locales/en_US/footer.ts","lightcone_api/api/api.ts","components/menus/NormalMenu/SubMenu.tsx","components/menus/NormalMenu/Menu.tsx","components/menus/NormalMenu/index.ts","features/components/menu/NormalMenu/index.ts","features/components/menu/NormalMenu/Menu.tsx","utils/text_tools.ts","components/btns/ConnectWalletBtn/ConnectWalletBtn.tsx","features/components/btns/ConnectWalletBtn/index.ts","features/components/btns/ConnectWalletBtn/ConnectWalletBtn.tsx","components/btns/IconBtn/IconBtn.tsx","components/btns/IconBtn/index.ts","components/selects/LngSelector/LngSelector.tsx","components/selects/LngSelector/index.ts","features/components/selects/LngSelector/index.ts","features/components/selects/LngSelector/LngSelector.tsx","layouts/header/Header.tsx","layouts/header/index.ts","layouts/footer/Footer.tsx","layouts/footer/index.ts","features/panels/home/IntroPanel/IntroPanel.tsx","features/panels/home/IntroPanel/index.ts","features/panels/home/ActivityPanel/ActivityPanel.tsx","features/panels/home/ActivityPanel/index.ts","components/tables/QuoteTable/QuoteTable.tsx","components/tables/QuoteTable/index.ts","features/panels/home/HomeQuotePanel/HomeQuotePanel.tsx","features/panels/home/HomeQuotePanel/index.ts","features/panels/home/TraitPanel/TraitPanel.tsx","features/panels/home/TraitPanel/index.ts","features/panels/home/Lv2IntroPanel/Lv2IntroPanel.tsx","features/panels/home/Lv2IntroPanel/index.ts","components/lists/AnnouncementList/AnnouncementList.tsx","components/lists/AnnouncementList/index.ts","features/components/lists/AnnouncementList/mock_data.ts","features/components/lists/AnnouncementList/index.ts","features/components/lists/AnnouncementList/AnnouncementList.tsx","features/panels/home/AnnouncementPanel/AnnouncementPanel.tsx","features/panels/home/AnnouncementPanel/index.ts","features/panels/home/WalletPanel/WalletPanel.tsx","features/panels/home/WalletPanel/index.ts","pages/HomePage/index.ts","pages/HomePage/HomePage.tsx","pages/QuotePage/index.ts","pages/QuotePage/QuotePage.tsx","layouts/responsive_layout/pages/trading_page.ts","components/selects/SymbolList/SymbolList.tsx","components/selects/SymbolList/index.ts","lightcone_api/api/base.ts","lightcone_api/api/common.ts","lightcone_api/api/configuration.ts","lightcone_api/api_wrapper/ethereum/contracts/AbiFunction.js","lightcone_api/api_wrapper/ethereum/contracts/Contract.js","lightcone_api/api_wrapper/ethereum/contracts/Contracts.js","lightcone_api/api_wrapper/ethereum/contracts/index.js","lightcone_api/api_wrapper/ethereum/metaMask.js","lightcone_api/api_wrapper/sign_tools.ts","lightcone_api/api_wrapper/AuthHasEcdsaSigApi.ts","lightcone_api/api_wrapper/AuthHasEddsaSigApi.ts","lightcone_api/api_wrapper/AuthApiKeyApi.ts","lightcone_api/api_wrapper/AuthNoKeyApi.ts","lightcone_api/api_wrapper/global.ts","stores/reducers/trading_reducer.ts","lightcone_api/api_wrapper/index.ts","hooks/trading_hook.ts","utils/dt_tools.ts","features/panels/trading/BasicInfoPanel/BasicInfoPanel.tsx","features/panels/trading/BasicInfoPanel/index.ts","features/panels/trading/OrderActionsPanel/index.ts","features/panels/trading/OrderActionsPanel/OrderActionsPanel.tsx","components/tables/OrderBookTable/OrderBookTable.tsx","components/tables/OrderBookTable/index.ts","features/panels/trading/OrderBookPanel/index.ts","features/panels/trading/OrderBookPanel/OrderBookPanel.tsx","components/tabs/HTabs/HTabs.tsx","components/tables/OrderRecordTable/OrderRecordTable.tsx","components/tables/OrderRecordTable/index.ts","features/panels/trading/OrderRecordsPanel/index.ts","features/panels/trading/OrderRecordsPanel/OrderRecordsPanel.tsx","components/tables/TradeRecordTable/TradeRecordTable.tsx","components/tables/TradeRecordTable/index.ts","features/panels/trading/TradeRecordsPanel/index.ts","features/panels/trading/TradeRecordsPanel/TradeRecordsPanel.tsx","components/charts/TradingChart/index.ts","components/charts/TradingChart/TradingChart.tsx","utils/kline_tools.ts","features/panels/trading/TradingChartPanel/TradingChartPanel.tsx","features/panels/trading/TradingChartPanel/index.ts","pages/TradingPage/TradingPage.tsx","pages/TradingPage/index.ts","components/tabs/VTabs/VTabs.tsx","pages/LiquidityPage/LiquidityPage.tsx","pages/LiquidityPage/index.ts","pages/L2WalletPage/L2WalletPage.tsx","pages/L2WalletPage/index.ts","networks/web3_connectors.ts","pages/DemoPage/items/Spinner.tsx","pages/DemoPage/items/Account.tsx","wallets/wallet_defs.ts","pages/DemoPage/items/Balance.tsx","pages/DemoPage/items/BlockNumber.tsx","pages/DemoPage/items/ChainId.tsx","utils/web3_tools.ts","pages/DemoPage/wallet_showcase.tsx","hooks/web3_hook.ts","routers/index.tsx","assets/images/adv.png","assets/images/dark/logo.svg","assets/images/dark/submenu_down.svg","assets/images/dark/download.svg","assets/images/dark/notification.svg","assets/images/dark/settings.svg","assets/images/dark/lang.svg","assets/images/dark/account.svg","assets/images/dark/obt1.svg","assets/images/dark/obt2.svg","assets/images/dark/obt3.svg","assets/images/dark/mode_selector.svg","themes/theme.ts","features/themes/ThemeProvider/index.ts","features/themes/ThemeProvider/ThemeProvider.tsx","stores/reducers/loading_reducer.ts","components/modals/LoadingModal/index.ts","components/modals/LoadingModal/LoadingModal.tsx","features/components/modal/LoadingModal/index.ts","features/components/modal/LoadingModal/LoadingModal.tsx","App.tsx","stores/reducers/index.ts","stores/index.ts","index.tsx","layouts/header/header.module.scss","routers/routers.module.scss","lightcone_api/api_wrapper/sign/poseidon.js","components/menus/NormalMenu/menu.module.scss","lightcone_api/api_wrapper/common/formatter.ts","components/selects/LngSelector/lng_selector.module.scss","lightcone_api/api_wrapper/sign/babyjub.js","lightcone_api/api_wrapper/sign/eddsa.js","features/panels/trading/BasicInfoPanel/basic_info.module.scss"],"names":["AccountStatus","settingsSlice","createSlice","name","initialState","themeType","lng","reducers","changeTheme","state","changeLng","setLng","action","payload","actions","defaultAccId","parseInt","process","status","Unknown","apiKey","eddsaKey","ecdsaKey","accountId","accountSlice","setAccountStatus","setAccountId","setApiKey","setEddsaKey","setEcdsaKey","useAccount","account","useSelector","isLogined","Logined","resources","zh_CN","common","com_name","search","connect_btn","menu_quote","menu_trading","submenu_simple_title","submenu_simple_desc","submenu_pro_title","submenu_pro_desc","menu_liquidity","menu_l2wallet","pages","quote_col_1","quote_col_2","quote_col_3","quote_col_4","quote_col_5","quote_col_6","quote_col_7","more_quotes","more_announcements","basic_24hrs_updown","basic_24hrs_low","basic_24hrs_high","basic_24hrs_volume","order_book_title","chart_title","chart_toggle_left","chart_toggle_right","trade_record_title","trade_record_latest","trade_record_mine","trade_col_1","trade_col_2","trade_col_3","order_record_title","order_record_current","order_record_history","order_col_1","order_col_2","order_col_3","order_col_4","order_col_5","order_col_6","order_col_7","order_col_8","footer","en_US","i18n","use","initReactI18next","init","keySeparator","interpolation","escapeValue","AmmTradeDataV3SideEnum","AmmTransactionDataV3TxTypeEnum","AmmTransactionDataV3TxStatusEnum","AmmTransactionDataV3AmmLayerTypeEnum","DepositDataStatusEnum","OrderDetailStatusEnum","OrderDetailSideEnum","OrderDetailOrderTypeEnum","OrderDetailV3SideEnum","OrderDetailV3OrderTypeEnum","OrderDetailV3StatusEnum","SubmitOffChainRequestItemStatusEnum","SubmitOrderRequestOrderTypeEnum","SubmitOrderRequestV3OrderTypeEnum","SubmitOrderResponseItemV3StatusEnum","SubmitOrderResponseV2ItemStatusEnum","TokenInfoTypeEnum","TokenInfoV3TypeEnum","TransferDataStatusEnum","UserAccountTxDataStatusEnum","WithdrawalDataStatusEnum","WithdrawalDataFastStatusEnum","SubMenuContent","styled","div","SubMenuContentInternal","theme","colors","subMenuBgColor","SubMenuItem","active","submenu_item_bg_color_a","submenu_item_bg_color_ia","submenu_circle_bg_color_a","submenu_circle_bg_color_ia","submenu_title_color_a","submenu_title_color_ia","submenu_desc_color","effects","submenu_desc_text_shadow","SubMenu","submenus","location","className","styles","dropdown_content","map","sub_value","sub_index","isActive","pathname","to","MenuUl","ul","MenuLi","li","width","toString","font_family","menuActived","menuInactived","MenuLiImg","img","MenuLiDiv","Menu","menu_data","submenu_down","value","index","hasSubmenu","length","dropdown","src","t","useTranslation","useLocation","useTheme","language","imgs","Button","button","cwBtnBgColor","cwBtnColor","w","h","ConnectWalletBtn","txt","onClick","BtnImg","marginTop","marginLeft","IconBtn","height","LngSelectMain","DropDownContainer","DropDownHeader","DropDownListContainer","DropDownList","bodyBgColor","ListItem","LngSelector","lng_data","onLngChange","lang_img","item","lan","changeLanguage","HeaderDiv","headerBgColor","AdvDiv","AdvImg","Logo","Header","acc","dispatch","useDispatch","onDownload","console","log","onNotification","onModeChange","advimg","advImg","menu_bar","logo","iconbtns","download_img","notification_img","mode_img","cwbtn","small_menu_bar","FooterDiv","Footer","Date","getFullYear","Intro","Line1","Line2","Line3","IntroPanel","ActivityRow","ActivityItem","margin_left","ActivityPanel","Styles","QuoteTable","quotes","cols","col","order_index","quote","quote_index","QuotePanel","ViewMore","HomeQuotePanel","useState","accessor","TraitRow","TraitItem","TraitPanel","Lv2Intro","Left","Right","Lv2IntroPanel","AnnouncementItem","AnnouncementList","data","text","date_str","mock","mock_data","Announcement","AnnouncementPanel","HomeWallet","ConnectTxt","ConnectDiv","WalletPanel","HomePage","QuotePage","lg_layout","i","x","y","static","upper_panel_h","basic_info_h","breakpoints","lg","md","sm","xs","xxs","layouts","SymbolSelector","select","SymbolList","listData","BASE_PATH","replace","BaseAPI","configuration","basePath","axios","globalAxios","this","RequiredError","field","msg","Error","DUMMY_BASE_URL","assertParamExists","functionName","paramName","paramValue","undefined","setSearchParams","url","searchParams","URLSearchParams","objects","object","key","set","serializeDataIfNeeded","requestOptions","nonString","isJsonMime","headers","JSON","stringify","toPathString","hash","createRequestFunction","axiosArgs","axiosRequestArgs","options","request","AuthApiKeyApiAxiosParamCreator","getCommissionReward","tokenId","start","size","rewardType","taker","a","localVarPath","localVarUrlObj","URL","baseOptions","localVarRequestOptions","method","localVarHeaderParameter","localVarQueryParameter","query","headersFromBaseOptions","getCommissionTotalReward","getFinanceIncome","address","financeType","tokenAddress","offset","limit","getLiquidityMiningRewardTotal","getLiquidityMiningRewards","market","timestamp","getNextStorageId","sellTokenId","getOrderDetail","orderHash","getOrders","end","side","orderTypes","getUserBalances","tokens","getUserBill","billType","income","transferAddress","fromAddress","getUserCreate","getUserDeposits","tokenSymbol","getUserFeeRates","markets","getUserTrades","fromId","fillTypes","getUserTransfers","transferTypes","getUserUpdate","getUserWithdrawals","withdrawalTypes","AuthHasEcdsaSigApiAxiosParamCreator","submitOffChainWithdrawal","body","submitTransfer","submitUpdateAccount","AuthHasEddsaSigApiAxiosParamCreator","applyApiKey","cancelOrder","clientOrderId","getApiKey","setReferrer","submitAmmPoolExit","submitAmmPoolJoin","submitOrderV3","AuthNoKeyApiFp","localVarAxiosParamCreator","crawlSite","site","getAccount","owner","getAllowance","token","getAmmPoolBalance","poolAddress","getAmmPools","getAmmPoolsBalances","getAmmTrades","ammPoolAddress","getAmmTransactions","getCandlestick","interval","getCommissionRewardRank","top","getDepth","level","getEthBalance","getEthNonce","getExchangeInfo","getLiquidityMiningConf","running","pageIndex","getLiquidityMiningRank","getMarketTrade","getMarkets","getPrice","legal","getRecommendedGasPrice","getTicker","getTimestamp","getTokenBalance","getTokens","getWithdrawalAgents","amount","sendTransaction","AuthNoKeyApiAxiosParamCreator","localVarAxiosArgs","AuthNoKeyApi","then","Configuration","param","username","password","accessToken","formDataCtor","mime","jsonMime","RegExp","test","toLowerCase","AbiFunction","inputs","outputs","constant","inputTypes","type","outputTypes","methodAbiHash","toHex","methodID","abiInputs","parseInputs","clearHexPrefix","rawEncode","parseOutputs","rawDecode","toBuffer","encoded","addHexPrefix","output","BN","Contract","abi","funAbi","filter","abiFunctions","reduce","methodHash","abiFunction","encodeInputs","decodeOutputs","encode","methodId","slice","decodeEncodedInputs","erc20Abi","require","exchange31Abi","exchange36Abi","contractWalletAbi","ERC20Token","Exchange31Contract","ExchangeContract","ContractWallet","Contracts","personalSign","web3","pwd","walletType","Promise","resolve","eth","personal","sign","err","result","walletLinkValid","sig","error","authereumValid","ecRecover","contractWalletValidate","contractWalletValidate2","mykeyWalletValid","hashPersonalMessage","ABI","_data","_signature","call","valid","_account","_index","res","signature","fromRpcSig","keccak256","recAddress","pubToAddress","ecrecover","v","r","s","SNARK_SCALAR_FIELD","BigInteger","genSig","PrivateKey","EdDSA","fm","Rx","Ry","getEdDSASig","api_url","requestInfo","params","mapAsc","Map","entries","sort","paramlist","Array","forEach","push","encodeURIComponent","join","makeRequestParamStr","uri","message","sha256","mod","toFormat","getEdDSASigWithPoseidon","Poseidon","hasher","getEcDSASig","typedData","msgParams","currentProvider","send","response","ecdsaSig","sigUtil","AuthHasEcdsaSigApi","conf","api","exAddr","PublicKeyX","PublicKeyY","volume","validUntil","nonce","hasDataStruct","reqData","exchange","publicKey","maxFee","AuthHasEddsaSigApi","requestMap","eddsaSig","storageId","sell_tokenId","sell_volume","buy_tokenId","buy_volume","allOrNone","fillAmountBOrS","maxFeeBips","sellToken","buyToken","eddsaSignature","AuthApiKeyApi","market_str","raw_data","tick_map","ind","arr","tick","date_time","base_token_amt","quote_token_amt","open","parseFloat","high","low","close","count","bid","ask","isReverse","ab_arr","amtTotal","ab_prices","ab_amtTotals","price","amt","BigNumber","dividedBy","toNumber","reverse","bids","genAB","asks","depth","version","bids_prices","bids_amtTotals","asks_prices","asks_amtTotals","trades","totalNum","TradingInterval","authApiKeyApi","authNoKeyApi","getBaseQuote","symbol","indexOf","symbol_base","substr","symbol_quote","defaultSymbol","REACT_APP_TEST_SYMBOL","defaultInterval","REACT_APP_TEST_INTERVAL","hr1","refreshRate","refreshRateSlow","tradingSlice","changeSymbol","changeTradingInterval","changeRefreshRate","changeRefreshRateSlow","setMarkets","useTradingInfo","trading","getLocaleDtFromTs","ts","locale","newLocale","dt","toLocaleString","getLocaleDt","BasicInfoPanel","ticker","setTicker","tradingInfo","useEffect","id","setInterval","getMarketTicker","tick_data","clearInterval","basic_info_panel","basic_info_row","basic_info_row2","OrderActionsPanel","OrderBookTable","ask_index","toFixed","bid_index","OrderBookPanel","onOrderBookTypeChange","event","obt1_img","obt2_img","obt3_img","Tabs","Tab","props","isRight","Content","OrderRecordTable","orders","order","validity","orderType","volumes","quoteAmount","OrderRecordsPanel","setOrders","setActive","handleClick","e","target","orders_data","TradeRecordTable","trade_index","trade","TradeRecordsPanel","setTrades","getMarketTradeData","trades_data","TradingChart","defaultOption","getOption","option","setOption","opt","style","notMerge","lazyUpdate","onChartReady","getKlineSign","dataIndex","openVal","closeVal","closeDimIdx","genOHLC","rawData","Number","genOption","upColor","upBorderColor","downColor","downBorderColor","backgroundColor","dataset","source","title","tooltip","trigger","axisPointer","animation","lineStyle","color","opacity","toolbox","feature","grid","left","right","bottom","xAxis","scale","boundaryGap","axisLine","onZero","splitLine","show","splitNumber","min","max","gridIndex","axisTick","axisLabel","yAxis","splitArea","dataZoom","xAxisIndex","visualMap","seriesIndex","dimension","pieces","series","itemStyle","color0","borderColor","borderColor0","yAxisIndex","large","genDepthOption","alpha","a_xdata","a_ydata","b_xdata","b_ydata","xdata","concat","new_b_ydata","fill","new_a_ydata","position","pt","sampling","areaStyle","echarts","LinearGradient","Title","TradingChartPanel","defaultDepthOption","data1","getDepthOption","ResponsiveGridLayout","WidthProvider","Responsive","TradingPage","setDepth","getDepthData","depth_data","rowHeight","draggableHandle","isResizable","LiquidityPage","L2WalletPage","POLLING_INTERVAL","RPC_URLS","injected","InjectedConnector","supportedChainIds","network","NetworkConnector","urls","1","4","defaultChainId","walletconnect","WalletConnectConnector","rpc","bridge","qrcode","pollingInterval","walletlink","WalletLinkConnector","appName","ledger","LedgerConnector","chainId","trezor","TrezorConnector","manifestEmail","manifestAppUrl","authereum","AuthereumConnector","Spinner","rest","viewBox","xmlns","stroke","fillRule","transform","strokeWidth","strokeOpacity","cx","cy","d","attributeName","from","dur","repeatCount","Account","useWeb3React","role","aria-label","substring","ConnectorNames","Balance","library","React","balance","setBalance","stale","getBalance","catch","formatEther","BlockNumber","blockNumber","setBlockNumber","getBlockNumber","updateBlockNumber","on","removeListener","ChainId","connectorsByName","Injected","Network","WalletConnect","WalletLink","Ledger","Trezor","Authereum","getErrorMessage","NoEthereumProviderError","UnsupportedChainIdError","UserRejectedRequestErrorInjected","UserRejectedRequestErrorWalletConnect","WalletShowCase","context","connector","activate","deactivate","activatingConnector","setActivatingConnector","triedEager","tried","setTried","isAuthorized","useEagerConnect","suppress","ethereum","window","handleConnect","handleChainChanged","handleAccountsChanged","accounts","handleNetworkChanged","networkId","useInactiveListener","margin","textAlign","display","gridGap","gridTemplateColumns","maxWidth","lineHeight","Object","keys","currentConnector","activating","connected","disabled","alignItems","flexDirection","marginBottom","getSigner","signMessage","alert","changeChainId","Container","RouterView","exact","path","content_container","Component","darkTheme","all","logo_dark","submenu_down_dark","download_dark","notification_dark","mode_dark","lang_dark","account_img","account_dark","obt1_dark","obt2_dark","obt3_dark","lightTheme","logo_light","submenu_down_light","download_light","notification_light","mode_light","lang_light","account_light","obt1_light","obt2_light","obt3_light","ThemeProvider","baseStyled","children","settings","loadingSlice","isLoading","setLoading","LoadingModal","onClose","loading","App","symbols","array","reject","useExchangeMarkets","I18nextProvider","rootReducer","combineReducers","reducer","store","configureStore","middleware","getDefaultMiddleware","logger","devTools","enhancers","reduxBatch","ReactDOM","render","getLibrary","provider","Web3Provider","document","getElementById","module","exports","assert","F","bn128","Fr","SEED","getPseudoRandom","seed","n","input","Buffer","blake2b","update","digest","affine","bigInt","leBuff2int","allDifferent","isZero","j","equals","ark","c","add","sigma","mul","square","mix","M","newState","zero","createHash","nRoundsF","nRoundsP","C","nRounds","NROUNDSF","getConstants","cmatrix","inverse","sub","getMatrix","mixed","ethUtil","toBig","startsWith","formatEddsaKey","hexKey","String","padStart","config","EXPONENTIAL_AT","RANGE","ROUNDING_MODE","F1Field","Scalar","utils","addPoint","mulPointEscalar","inCurve","inSubgroup","P","subOrder","eq","one","packPoint","buff","leInt2Buff","lt","unpackPoint","_buff","gt","p","y2","sqrt","A","D","neg","fromString","b","beta","gamma","delta","tau","dtau","base","rem","exp","isOdd","shiftRight","x2","Base8","getKeyPair","entropy","crypto","randomBytes","babyJub","secretKey","unpacked","packed","pack","unpack","publicKeyX","publicKeyY","keyX","keyY","reversed","alloc","repeat","strKey","prv","h1","createBlakeHash","msgBuff","rBuff","R8","hm","S","verify","pubKey","R","Pleft","Pright","generateKeyPair","generatePubKeyFromPrivate"],"mappings":"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","file":"static/js/main~06837ae4.c22ea468.chunk.js","sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nexport enum AccountStatus {\n  Unknown,\n  Logined,\n}\n\nexport interface AccountInfo {\n  status: AccountStatus\n  accountId: number\n  apiKey: string\n  eddsaKey: string\n  ecdsaKey: string\n}\n\nconst defaultAccId = process.env.REACT_APP_TEST_ACCOUND_ID ? parseInt(process.env.REACT_APP_TEST_ACCOUND_ID) : 0\nconst defaultApiKey = process.env.REACT_APP_TEST_API_KEY ? process.env.REACT_APP_TEST_API_KEY : ''\nconst defaultEddsaKey = process.env.REACT_APP_TEST_EDDSA_KEY ? process.env.REACT_APP_TEST_EDDSA_KEY : ''\nconst defaultEcdsaKey = process.env.REACT_APP_TEST_ECDSA_KEY ? process.env.REACT_APP_TEST_ECDSA_KEY : ''\n\nconst initialState = { \n  status: AccountStatus.Unknown, \n  apiKey: defaultApiKey, \n  eddsaKey: defaultEddsaKey, \n  ecdsaKey: defaultEcdsaKey, \n  accountId: defaultAccId\n} as AccountInfo\n\nconst accountSlice = createSlice({\n  name: 'account',\n  initialState,\n  reducers: {\n    setAccountStatus(state, action: PayloadAction<any>) {\n      state.status = action.payload\n    },\n    setAccountId(state, action: PayloadAction<any>) {\n      state.accountId = typeof(action.payload) == 'string' ? parseInt(action.payload): action.payload\n    },\n    setApiKey(state, action: PayloadAction<any>) {\n      state.apiKey = action.payload\n    },\n    setEddsaKey(state, action: PayloadAction<any>) {\n      state.eddsaKey = action.payload\n    },\n    setEcdsaKey(state, action: PayloadAction<any>) {\n      state.ecdsaKey = action.payload\n    },\n  },\n})\n\nexport const { setAccountStatus, setApiKey, setAccountId, setEddsaKey, setEcdsaKey, } = accountSlice.actions\nexport default accountSlice\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nexport interface SettingsState {\n  themeType: string\n  lng: string\n}\n\nconst initialState = { themeType: 'dark', lng: 'en_US' } as SettingsState\n\nconst settingsSlice = createSlice({\n  name: 'settings',\n  initialState,\n  reducers: {\n    changeTheme(state) {\n      if (state.themeType === 'dark') {\n        state.themeType = 'light'\n      } else {\n        state.themeType = 'dark'\n      }\n    },\n    changeLng(state) {\n      if (state.lng === 'en_US') {\n        state.lng = 'zh_CN'\n      } else {\n        state.lng = 'en_US'\n      }\n    },\n    setLng(state, action: PayloadAction<string>) {\n      state.lng = action.payload\n    },\n  },\n})\n\nexport const { changeTheme, changeLng, setLng } = settingsSlice.actions\nexport default settingsSlice\n","import { useSelector } from 'react-redux'\n\nimport { RootState } from 'stores'\n\nimport { AccountStatus } from 'stores/reducers/account_reducer'\n\nexport function useAccount() {\n\n    const account = useSelector((state: RootState) => state.account)\n\n    const isLogined = account.status === AccountStatus.Logined\n\n    return {\n        account: account, \n        isLogined: isLogined\n    }\n\n}\n","import i18n from 'i18next'\nimport { initReactI18next } from 'react-i18next'\n\nimport zhCommon from 'locales/zh_CN/common'\nimport enCommon from 'locales/en_US/common'\n\nimport zhMenu from 'locales/zh_CN/menu'\nimport enMenu from 'locales/en_US/menu'\n\nimport zhHome from 'locales/zh_CN/home_page'\nimport enHome from 'locales/en_US/home_page'\n\nimport zhTradingPage from 'locales/zh_CN/trading_page'\nimport enTradingPage from 'locales/en_US/trading_page'\n\nimport zhFooter from 'locales/zh_CN/footer'\nimport enFooter from 'locales/en_US/footer'\n\nconst resources = {\n  zh_CN: {\n    common: {\n      ...zhCommon,\n      ...zhMenu,\n    },\n    pages: {\n      ...zhHome,\n      ...zhTradingPage\n    },\n    footer: {\n      ...zhFooter,\n    }\n  },\n  en_US: {\n    common: {\n      ...enCommon,\n      ...enMenu,\n    },\n    pages: {\n      ...enHome,\n      ...enTradingPage\n    },\n    footer: {\n      ...enFooter,\n    }\n  },\n};\n\ni18n\n  .use(initReactI18next) // passes i18n down to react-i18next\n  .init({\n    resources,\n    lng: 'en_US',\n\n    keySeparator: false, // we do not use keys in form messages.welcome\n\n    interpolation: {\n      escapeValue: false, // react already safes from xss\n    },\n  });\n\nexport default i18n;\n","export default {\n  com_name: '',\n  search: '...',\n  connect_btn: '',\n}\n","export default {\n  menu_quote: '',\n  menu_trading: '',\n  submenu_simple_title: '',\n  submenu_simple_desc: '',\n  submenu_pro_title: '',\n  submenu_pro_desc: '',\n  menu_liquidity: '',\n  menu_l2wallet: '',\n}\n","export default {\n  quote_col_1: 'Symbol',\n  quote_col_2: 'Latest Price',\n  quote_col_3: '24hrs Up/Down',\n  quote_col_4: '24hrs High',\n  quote_col_5: '24hrs Low',\n  quote_col_6: '24hrs Volume',\n  quote_col_7: 'Action',\n\n  more_quotes: '...',\n  more_announcements: 'More Announcements...',\n}\n","export default {\n  basic_24hrs_updown: '24',\n  basic_24hrs_low: '24',\n  basic_24hrs_high: '24',\n  basic_24hrs_volume: '24',\n\n  order_book_title: '',\n\n  chart_title: '',\n  chart_toggle_left: 'K',\n  chart_toggle_right: '',\n\n  trade_record_title: '',\n  trade_record_latest: '',\n  trade_record_mine: '',\n  trade_col_1: '',\n  trade_col_2: '',\n  trade_col_3: '',\n  \n  order_record_title: '',\n  order_record_current: '',\n  order_record_history: '',\n  order_col_1: 'Order Time',\n  order_col_2: 'Symbol',\n  order_col_3: 'Order Type',\n  order_col_4: 'Direction',\n  order_col_5: 'Price',\n  order_col_6: 'Volume',\n  order_col_7: 'Status',\n  order_col_8: 'Amount',\n}\n","export default {\n}\n","export default {\n  com_name: 'Loopring',\n  search: 'Search...',\n  connect_btn: 'My Wallet',\n}\n","export default {\n  menu_quote: 'Quotes',\n  menu_trading: 'Trading',\n  submenu_simple_title: 'Quick Swap',\n  submenu_simple_desc: 'One Touch Flash Swap',\n  submenu_pro_title: 'Pro Trader',\n  submenu_pro_desc: 'Full Screen Trading Platform',\n  menu_liquidity: 'Liquidity',\n  menu_l2wallet: 'L2Wallet',\n}\n","export default {\n  quote_col_1: 'Symbol',\n  quote_col_2: 'Latest Price',\n  quote_col_3: '24hrs Up/Down',\n  quote_col_4: '24hrs High',\n  quote_col_5: '24hrs Low',\n  quote_col_6: '24hrs Volume',\n  quote_col_7: 'Action',\n\n  more_quotes: 'More Quotes...',\n  more_announcements: 'More Announcements...',\n}\n","export default {\n  basic_24hrs_updown: '24hrs Up/Down',\n  basic_24hrs_low: '24hrs Low',\n  basic_24hrs_high: '24hrs High',\n  basic_24hrs_volume: '24hrs Volume',\n\n  order_book_title: 'OrderBook',\n\n  chart_title: 'Chart',\n  chart_toggle_left: 'KLine',\n  chart_toggle_right: 'Depth',\n\n  trade_record_title: 'Trade Records',\n  trade_record_latest: 'Lastest Trades',\n  trade_record_mine: 'My Trades',\n  trade_col_1: 'Price',\n  trade_col_2: 'Volume',\n  trade_col_3: 'Trade Time',\n  \n  order_record_title: 'Order Records',\n  order_record_current: 'Current Orders',\n  order_record_history: 'Orders History',\n  order_col_1: 'Order Time',\n  order_col_2: 'Symbol',\n  order_col_3: 'Order Type',\n  order_col_4: 'Direction',\n  order_col_5: 'Price',\n  order_col_6: 'Volume',\n  order_col_7: 'Status',\n  order_col_8: 'Amount',\n}\n","export default {\n}\n","/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n * LightCone 2.0 API Documentation\r\n * LightCone DEX function interpretation\r\n *\r\n * The version of the OpenAPI document: 1.0\r\n * \r\n *\r\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\r\n * https://openapi-generator.tech\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nimport { Configuration } from './configuration';\r\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\r\n// Some imports not used depending on template conditions\r\n// @ts-ignore\r\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';\r\n// @ts-ignore\r\nimport { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';\r\n\r\n/**\r\n * field.AgentInfo.description\r\n * @export\r\n * @interface AgentInfo\r\n */\r\nexport interface AgentInfo {\r\n    /**\r\n     * field.AgentInfo.address\r\n     * @type {string}\r\n     * @memberof AgentInfo\r\n     */\r\n    address: string;\r\n    /**\r\n     * field.AgentInfo.tokenId\r\n     * @type {number}\r\n     * @memberof AgentInfo\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * field.AgentInfo.symbol\r\n     * @type {string}\r\n     * @memberof AgentInfo\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * field.AgentInfo.totalAmount\r\n     * @type {string}\r\n     * @memberof AgentInfo\r\n     */\r\n    totalAmount: string;\r\n    /**\r\n     * field.AgentInfo.freezeAmount\r\n     * @type {string}\r\n     * @memberof AgentInfo\r\n     */\r\n    freezeAmount: string;\r\n    /**\r\n     * field.AgentInfo.timestamp\r\n     * @type {number}\r\n     * @memberof AgentInfo\r\n     */\r\n    timestamp: number;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmMarketInfo\r\n */\r\nexport interface AmmMarketInfo {\r\n    /**\r\n     * field.AmmMarketInfo.name\r\n     * @type {string}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    name: string;\r\n    /**\r\n     * field.AmmMarketInfo.market\r\n     * @type {string}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    market: string;\r\n    /**\r\n     * field.AmmMarketInfo.address\r\n     * @type {string}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    address: string;\r\n    /**\r\n     * field.AmmMarketInfo.version\r\n     * @type {string}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    version: string;\r\n    /**\r\n     * field.AmmMarketInfo.inPoolTokens\r\n     * @type {Array<object>}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    inPoolTokens: Array<object>;\r\n    /**\r\n     * field.AmmMarketInfo.poolTokenId\r\n     * @type {number}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    poolTokenId: number;\r\n    /**\r\n     * field.AmmMarketInfo.feeBips\r\n     * @type {number}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    feeBips: number;\r\n    /**\r\n     * field.AmmMarketInfo.pricePrecision\r\n     * @type {number}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    pricePrecision: number;\r\n    /**\r\n     * field.AmmMarketInfo.amountPrecision\r\n     * @type {number}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    amountPrecision: number;\r\n    /**\r\n     * field.AmmMarketInfo.enabled\r\n     * @type {boolean}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    enabled: boolean;\r\n    /**\r\n     * field.AmmMarketInfo.status\r\n     * @type {number}\r\n     * @memberof AmmMarketInfo\r\n     */\r\n    status: number;\r\n}\r\n/**\r\n * Describes both pooled token balances for a given pool and minted LP tokens amount.\r\n * @export\r\n * @interface AmmPoolBalanceV3\r\n */\r\nexport interface AmmPoolBalanceV3 {\r\n    /**\r\n     * AMM in pool tokens balances\r\n     * @type {Array<TokenVolumeV3>}\r\n     * @memberof AmmPoolBalanceV3\r\n     */\r\n    pooled: Array<TokenVolumeV3>;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof AmmPoolBalanceV3\r\n     */\r\n    lp: TokenVolumeV3;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmPoolExitRequest\r\n */\r\nexport interface AmmPoolExitRequest {\r\n    /**\r\n     * field.AmmPoolJoinRequest.owner\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    owner: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.poolAddress\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    poolAddress: string;\r\n    /**\r\n     * field.AmmPoolExitRequest.burnAmount\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    burnAmount: string;\r\n    /**\r\n     * field.AmmPoolExitRequest.burnStorageID\r\n     * @type {number}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    burnStorageID: number;\r\n    /**\r\n     * field.AmmPoolExitRequest.exitMinAmounts\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    exitMinAmounts: string;\r\n    /**\r\n     * field.AmmPoolExitRequest.fee\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    fee: string;\r\n    /**\r\n     * field.AmmPoolExitRequest.validUntil\r\n     * @type {number}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.AmmPoolExitRequest.ecdsaSig\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    ecdsaSig: string;\r\n    /**\r\n     * field.AmmPoolExitRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequest\r\n     */\r\n    eddsaSig: string;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmPoolExitRequestV3\r\n */\r\nexport interface AmmPoolExitRequestV3 {\r\n    /**\r\n     * The account owner adderss\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    owner: string;\r\n    /**\r\n     * AMM pool address to be joined\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    poolAddress: string;\r\n    /**\r\n     * \r\n     * @type {AmmPoolExitTokens}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    exitTokens: AmmPoolExitTokens;\r\n    /**\r\n     * Offchain request storage Id\r\n     * @type {number}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * field.AmmPoolExitRequestV3.maxFee\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    maxFee: string;\r\n    /**\r\n     * Timestamp for order to become invalid\r\n     * @type {number}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * AMM exit request eddsa signature\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    eddsaSignature?: string;\r\n    /**\r\n     * AMM exit request ecdsa signature\r\n     * @type {string}\r\n     * @memberof AmmPoolExitRequestV3\r\n     */\r\n    ecdsaSignature?: string;\r\n}\r\n/**\r\n * escribes an AMM join transaction\r\n * @export\r\n * @interface AmmPoolExitTokens\r\n */\r\nexport interface AmmPoolExitTokens {\r\n    /**\r\n     * Describes list of the amount of a specific token to be removed from the pool, tokens seq should be same as AMM pool info\r\n     * @type {Array<TokenVolumeV3>}\r\n     * @memberof AmmPoolExitTokens\r\n     */\r\n    unPooled: Array<TokenVolumeV3>;\r\n    /**\r\n     * The minimum amoun of LP token to burn\r\n     * @type {string}\r\n     * @memberof AmmPoolExitTokens\r\n     */\r\n    burned: string;\r\n}\r\n/**\r\n * AMM pool info\r\n * @export\r\n * @interface AmmPoolInfoV3\r\n */\r\nexport interface AmmPoolInfoV3 {\r\n    /**\r\n     * AMM pool name, used to calculate domainSeparator of EIP712 hash if use chooses ECDSA sign path.\r\n     * @type {string}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    name: string;\r\n    /**\r\n     * AMM pool market name, can be used to query market related info like ticker, etc\r\n     * @type {string}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    market: string;\r\n    /**\r\n     * AMM pool address\r\n     * @type {string}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    address: string;\r\n    /**\r\n     * AMM pool contract version\r\n     * @type {string}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    version: string;\r\n    /**\r\n     * \r\n     * @type {AmmPoolTokens}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    tokens: AmmPoolTokens;\r\n    /**\r\n     * AMM fee bips\r\n     * @type {number}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    feeBips: number;\r\n    /**\r\n     * \r\n     * @type {AmmPoolPrecisions}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    precisions: AmmPoolPrecisions;\r\n    /**\r\n     * AMM market status\r\n     * @type {number}\r\n     * @memberof AmmPoolInfoV3\r\n     */\r\n    status: number;\r\n}\r\n/**\r\n * model.AmmPoolJoinRequest.description\r\n * @export\r\n * @interface AmmPoolJoinRequest\r\n */\r\nexport interface AmmPoolJoinRequest {\r\n    /**\r\n     * field.AmmPoolJoinRequest.owner\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    owner: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.poolAddress\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    poolAddress: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.joinAmounts\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    joinAmounts: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.joinStorageIDs\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    joinStorageIDs: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.mintMinAmount\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    mintMinAmount: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.validUntil\r\n     * @type {number}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.AmmPoolJoinRequest.ecdsaSig\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    ecdsaSig: string;\r\n    /**\r\n     * field.AmmPoolJoinRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequest\r\n     */\r\n    eddsaSig: string;\r\n}\r\n/**\r\n * Join request which contains parameters and constraints that a user wants to see satisfied in order to join an AMM liquidity pool.\r\n * @export\r\n * @interface AmmPoolJoinRequestV3\r\n */\r\nexport interface AmmPoolJoinRequestV3 {\r\n    /**\r\n     * The account owner adderss\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    owner: string;\r\n    /**\r\n     * AMM pool address to be joined\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    poolAddress: string;\r\n    /**\r\n     * \r\n     * @type {AmmPoolJoinTokens}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    joinTokens: AmmPoolJoinTokens;\r\n    /**\r\n     * Offchain request storage Id\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    storageIds: string;\r\n    /**\r\n     * Timestamp for order to become invalid\r\n     * @type {number}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * AMM join request eddsa signature\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    eddsaSignature?: string;\r\n    /**\r\n     * AMM join request ecdsa signature\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinRequestV3\r\n     */\r\n    ecdsaSignature?: string;\r\n}\r\n/**\r\n * escribes an AMM join transaction\r\n * @export\r\n * @interface AmmPoolJoinTokens\r\n */\r\nexport interface AmmPoolJoinTokens {\r\n    /**\r\n     * Describes an amount of a specific token to be supplied to the pool, the seq matters, and must be the same as the pool token list returned by pool info\r\n     * @type {Array<TokenVolumeV3>}\r\n     * @memberof AmmPoolJoinTokens\r\n     */\r\n    pooled: Array<TokenVolumeV3>;\r\n    /**\r\n     * The minimum amoun of LP token desired in exchange for supplying liquidity to the pool\r\n     * @type {string}\r\n     * @memberof AmmPoolJoinTokens\r\n     */\r\n    minimumLp: string;\r\n}\r\n/**\r\n * The precision requirement of a AMM pool\r\n * @export\r\n * @interface AmmPoolPrecisions\r\n */\r\nexport interface AmmPoolPrecisions {\r\n    /**\r\n     * The price precision requirement of a AMM pool\r\n     * @type {number}\r\n     * @memberof AmmPoolPrecisions\r\n     */\r\n    price: number;\r\n    /**\r\n     * The amount precision requirement of a AMM pool\r\n     * @type {number}\r\n     * @memberof AmmPoolPrecisions\r\n     */\r\n    amount: number;\r\n}\r\n/**\r\n * model.AmmPoolStatistics\r\n * @export\r\n * @interface AmmPoolStatistics\r\n */\r\nexport interface AmmPoolStatistics {\r\n    /**\r\n     * field.AmmPoolStatistics.market\r\n     * @type {string}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    market: string;\r\n    /**\r\n     * field.AmmPoolStatistics.liquidity\r\n     * @type {Array<string>}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    liquidity: Array<string>;\r\n    /**\r\n     * field.AmmPoolStatistics.lpLiquidity\r\n     * @type {string}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    lpLiquidity: string;\r\n    /**\r\n     * field.AmmPoolStatistics.ohlc\r\n     * @type {Array<string>}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    ohlc: Array<string>;\r\n    /**\r\n     * field.AmmPoolStatistics.volume\r\n     * @type {Array<string>}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    volume: Array<string>;\r\n    /**\r\n     * field.AmmPoolStatistics.fees\r\n     * @type {Array<string>}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    fees: Array<string>;\r\n    /**\r\n     * field.AmmPoolStatistics.apyBips\r\n     * @type {string}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    apyBips: string;\r\n    /**\r\n     * field.AmmPoolStatistics.isRecommended\r\n     * @type {boolean}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    isRecommended: boolean;\r\n    /**\r\n     * field.AmmPoolStatistics.rewards\r\n     * @type {Array<TokenVolumeV3>}\r\n     * @memberof AmmPoolStatistics\r\n     */\r\n    rewards: Array<TokenVolumeV3>;\r\n}\r\n/**\r\n * Wrapper object containing information about the tokens in the pool\r\n * @export\r\n * @interface AmmPoolTokens\r\n */\r\nexport interface AmmPoolTokens {\r\n    /**\r\n     * An array containing the unique identifiers of those tokens that are currently in the pool, seq matters as most requests ask for the same sequence.\r\n     * @type {Array<object>}\r\n     * @memberof AmmPoolTokens\r\n     */\r\n    pooled: Array<object>;\r\n    /**\r\n     * The unique identifier of the pool-specific LP token. This token is minted when supplying liquidity to the pool, and represents liquidity stakes in it\r\n     * @type {number}\r\n     * @memberof AmmPoolTokens\r\n     */\r\n    lp: number;\r\n}\r\n/**\r\n * model.AmmSnapshot.description\r\n * @export\r\n * @interface AmmSnapshot\r\n */\r\nexport interface AmmSnapshot {\r\n    /**\r\n     * field.AmmSnapshot.poolName\r\n     * @type {string}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    poolName: string;\r\n    /**\r\n     * field.AmmSnapshot.poolAddress\r\n     * @type {string}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    poolAddress: string;\r\n    /**\r\n     * field.AmmSnapshot.poolTokenId\r\n     * @type {number}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    poolTokenId: number;\r\n    /**\r\n     * field.AmmSnapshot.PoolTokenAmount\r\n     * @type {string}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    PoolTokenAmount: string;\r\n    /**\r\n     * field.AmmSnapshot.tokenIds\r\n     * @type {Array<object>}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    tokenIds: Array<object>;\r\n    /**\r\n     * field.AmmSnapshot.tokenAmounts\r\n     * @type {Array<string>}\r\n     * @memberof AmmSnapshot\r\n     */\r\n    tokenAmounts: Array<string>;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmTradeData\r\n */\r\nexport interface AmmTradeData {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeData\r\n     */\r\n    sequenceId: number;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeData\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeData\r\n     */\r\n    settlementRequestId: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTradeData\r\n     */\r\n    orderHash: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTradeData\r\n     */\r\n    market: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTradeData\r\n     */\r\n    side: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTradeData\r\n     */\r\n    size: string;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeData\r\n     */\r\n    price: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTradeData\r\n     */\r\n    feeAmount: string;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeData\r\n     */\r\n    createdAt: number;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmTradeDataList\r\n */\r\nexport interface AmmTradeDataList {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTradeDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * \r\n     * @type {Array<AmmTradeData>}\r\n     * @memberof AmmTradeDataList\r\n     */\r\n    trades: Array<AmmTradeData>;\r\n}\r\n/**\r\n * Trading list of AMM pool\r\n * @export\r\n * @interface AmmTradeDataListV3\r\n */\r\nexport interface AmmTradeDataListV3 {\r\n    /**\r\n     * Number of trades\r\n     * @type {number}\r\n     * @memberof AmmTradeDataListV3\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * AMM trade list\r\n     * @type {Array<AmmTradeDataV3>}\r\n     * @memberof AmmTradeDataListV3\r\n     */\r\n    trades: Array<AmmTradeDataV3>;\r\n}\r\n/**\r\n * AMM trade info data\r\n * @export\r\n * @interface AmmTradeDataV3\r\n */\r\nexport interface AmmTradeDataV3 {\r\n    /**\r\n     * trader\\'s accountId\r\n     * @type {number}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * AMM trade\\'s order hash\r\n     * @type {string}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    orderHash: string;\r\n    /**\r\n     * The trade market\r\n     * @type {string}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    market: string;\r\n    /**\r\n     * The trade direction, buy or sell\r\n     * @type {string}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    side: AmmTradeDataV3SideEnum;\r\n    /**\r\n     * The trade volume\r\n     * @type {string}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    size: string;\r\n    /**\r\n     * The trade price\r\n     * @type {number}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    price: number;\r\n    /**\r\n     * The trade fee\r\n     * @type {string}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    feeAmount: string;\r\n    /**\r\n     * The trade\\'s creation time\r\n     * @type {number}\r\n     * @memberof AmmTradeDataV3\r\n     */\r\n    createdAt: number;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum AmmTradeDataV3SideEnum {\r\n    Buy = 'BUY',\r\n    Sell = 'SELL'\r\n}\r\n\r\n/**\r\n * \r\n * @export\r\n * @interface AmmTransactionData\r\n */\r\nexport interface AmmTransactionData {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    id: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    hash: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    txHash: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    owner: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    txType: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    txStatus: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    ammLayerType: string;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    ammPoolId: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    ammPoolAddress: string;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    lpTokenId: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    lpTokenSymbol: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    lpTokenAmount: string;\r\n    /**\r\n     * \r\n     * @type {Array<AmmTransferData>}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    transfers: Array<AmmTransferData>;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    blockHeight: number;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    createdAt: number;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionData\r\n     */\r\n    updatedAt: number;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface AmmTransactionDataList\r\n */\r\nexport interface AmmTransactionDataList {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransactionDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * \r\n     * @type {Array<AmmTransactionData>}\r\n     * @memberof AmmTransactionDataList\r\n     */\r\n    transactions: Array<AmmTransactionData>;\r\n}\r\n/**\r\n * Contains one or multiple AMM pool transactions.\r\n * @export\r\n * @interface AmmTransactionDataListV3\r\n */\r\nexport interface AmmTransactionDataListV3 {\r\n    /**\r\n     * Number of AMM pool transactions\r\n     * @type {number}\r\n     * @memberof AmmTransactionDataListV3\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of AMM pool transactions\r\n     * @type {Array<AmmTransactionDataV3>}\r\n     * @memberof AmmTransactionDataListV3\r\n     */\r\n    transactions: Array<AmmTransactionDataV3>;\r\n}\r\n/**\r\n * AMM transaction info data\r\n * @export\r\n * @interface AmmTransactionDataV3\r\n */\r\nexport interface AmmTransactionDataV3 {\r\n    /**\r\n     * AMM transaction hash\r\n     * @type {string}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    hash: string;\r\n    /**\r\n     * AMM transaction type, i.e., join, exit, etc\r\n     * @type {string}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    txType: AmmTransactionDataV3TxTypeEnum;\r\n    /**\r\n     * AMM transaction processing status, i.e., processing, processed, failed, etc\r\n     * @type {string}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    txStatus: AmmTransactionDataV3TxStatusEnum;\r\n    /**\r\n     * AMM pool address of query\r\n     * @type {string}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    ammPoolAddress: string;\r\n    /**\r\n     * AMM transaction layer, 1 or 2\r\n     * @type {string}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    ammLayerType: AmmTransactionDataV3AmmLayerTypeEnum;\r\n    /**\r\n     * The in pool tokens transfers records of the AMM transaction\r\n     * @type {Array<AmmTransferDataV3>}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    poolTokens: Array<AmmTransferDataV3>;\r\n    /**\r\n     * \r\n     * @type {AmmTransferDataV3}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    lpToken: AmmTransferDataV3;\r\n    /**\r\n     * Transaction creation time\r\n     * @type {number}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    createdAt: number;\r\n    /**\r\n     * Transaction update time\r\n     * @type {number}\r\n     * @memberof AmmTransactionDataV3\r\n     */\r\n    updatedAt: number;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum AmmTransactionDataV3TxTypeEnum {\r\n    Join = 'join',\r\n    Exit = 'exit'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum AmmTransactionDataV3TxStatusEnum {\r\n    Processing = 'processing',\r\n    Cancelled = 'cancelled',\r\n    Processed = 'processed'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum AmmTransactionDataV3AmmLayerTypeEnum {\r\n    _1 = 'layer_1',\r\n    _2 = 'layer_2'\r\n}\r\n\r\n/**\r\n * \r\n * @export\r\n * @interface AmmTransferData\r\n */\r\nexport interface AmmTransferData {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransferData\r\n     */\r\n    id: number;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof AmmTransferData\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransferData\r\n     */\r\n    tokenSymbol: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransferData\r\n     */\r\n    amount: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransferData\r\n     */\r\n    actualAmount: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof AmmTransferData\r\n     */\r\n    feeAmount: string;\r\n}\r\n/**\r\n * AMM transfer info data\r\n * @export\r\n * @interface AmmTransferDataV3\r\n */\r\nexport interface AmmTransferDataV3 {\r\n    /**\r\n     * AMM transfer token id\r\n     * @type {number}\r\n     * @memberof AmmTransferDataV3\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * AMM transfer token amount\r\n     * @type {string}\r\n     * @memberof AmmTransferDataV3\r\n     */\r\n    amount: string;\r\n    /**\r\n     * Actual AMM transfer token amount due to precision processing\r\n     * @type {string}\r\n     * @memberof AmmTransferDataV3\r\n     */\r\n    actualAmount: string;\r\n    /**\r\n     * Actual AMM transfer fee amount\r\n     * @type {string}\r\n     * @memberof AmmTransferDataV3\r\n     */\r\n    feeAmount: string;\r\n}\r\n/**\r\n * model.Balance.description\r\n * @export\r\n * @interface Balance\r\n */\r\nexport interface Balance {\r\n    /**\r\n     * field.Balance.accountId\r\n     * @type {number}\r\n     * @memberof Balance\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * field.Balance.tokenId\r\n     * @type {number}\r\n     * @memberof Balance\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * field.Balance.totalAmount\r\n     * @type {string}\r\n     * @memberof Balance\r\n     */\r\n    totalAmount: string;\r\n    /**\r\n     * field.Balance.frozenAmount\r\n     * @type {string}\r\n     * @memberof Balance\r\n     */\r\n    amountLocked: string;\r\n    /**\r\n     * \r\n     * @type {PendingBalance}\r\n     * @memberof Balance\r\n     */\r\n    pending: PendingBalance;\r\n}\r\n/**\r\n * Asset information\r\n * @export\r\n * @interface BalanceV3\r\n */\r\nexport interface BalanceV3 {\r\n    /**\r\n     * Token ID\r\n     * @type {number}\r\n     * @memberof BalanceV3\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * Amount of the asset\r\n     * @type {string}\r\n     * @memberof BalanceV3\r\n     */\r\n    total: string;\r\n    /**\r\n     * The part of the total balance which is currently not liquid and not at the users disposal (because of pending withdrawals or orders for example)\r\n     * @type {string}\r\n     * @memberof BalanceV3\r\n     */\r\n    locked: string;\r\n    /**\r\n     * \r\n     * @type {PendingBalance}\r\n     * @memberof BalanceV3\r\n     */\r\n    pending: PendingBalance;\r\n}\r\n/**\r\n * Batch cancel orders.\r\n * @export\r\n * @interface BatchCancelOrderResponse\r\n */\r\nexport interface BatchCancelOrderResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof BatchCancelOrderResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Results of batch order cancellation.\r\n     * @type {Array<CancelOrderResult>}\r\n     * @memberof BatchCancelOrderResponse\r\n     */\r\n    data: Array<CancelOrderResult>;\r\n}\r\n/**\r\n * Batch submit order parameters.\r\n * @export\r\n * @interface BatchSubmitOrderRequest\r\n */\r\nexport interface BatchSubmitOrderRequest {\r\n    /**\r\n     * Orders to submit.\r\n     * @type {Array<SubmitOrderRequest>}\r\n     * @memberof BatchSubmitOrderRequest\r\n     */\r\n    orders: Array<SubmitOrderRequest>;\r\n}\r\n/**\r\n * Batch submit orders.\r\n * @export\r\n * @interface BatchSubmitOrderResponse\r\n */\r\nexport interface BatchSubmitOrderResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof BatchSubmitOrderResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Result of batch submit orders.\r\n     * @type {Array<SubmitOrderResult>}\r\n     * @memberof BatchSubmitOrderResponse\r\n     */\r\n    data: Array<SubmitOrderResult>;\r\n}\r\n/**\r\n * result for order cancellation.\r\n * @export\r\n * @interface CancelOrderResult\r\n */\r\nexport interface CancelOrderResult {\r\n    /**\r\n     * Hash or clientOrderId of order cancelled.\r\n     * @type {string}\r\n     * @memberof CancelOrderResult\r\n     */\r\n    id: string;\r\n    /**\r\n     * Order cancellation result.\r\n     * @type {boolean}\r\n     * @memberof CancelOrderResult\r\n     */\r\n    result: boolean;\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof CancelOrderResult\r\n     */\r\n    error?: ResultInfo;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface CancelOrdersResponseData\r\n */\r\nexport interface CancelOrdersResponseData {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof CancelOrdersResponseData\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.CancelOrdersResponseData.data\r\n     * @type {boolean}\r\n     * @memberof CancelOrdersResponseData\r\n     */\r\n    data?: boolean;\r\n}\r\n/**\r\n * Response data\r\n * @export\r\n * @interface DepositData\r\n */\r\nexport interface DepositData {\r\n    /**\r\n     * Unique ID\r\n     * @type {number}\r\n     * @memberof DepositData\r\n     */\r\n    id: number;\r\n    /**\r\n     * hash\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Amount requested by the user\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    amount: string;\r\n    /**\r\n     * Transaction hash\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    txHash: string;\r\n    /**\r\n     * Current status\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    status: DepositDataStatusEnum;\r\n    /**\r\n     * Progress\r\n     * @type {string}\r\n     * @memberof DepositData\r\n     */\r\n    progress: string;\r\n    /**\r\n     * Create time\r\n     * @type {number}\r\n     * @memberof DepositData\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Block height\r\n     * @type {number}\r\n     * @memberof DepositData\r\n     */\r\n    blockNum: number;\r\n    /**\r\n     * Update time\r\n     * @type {number}\r\n     * @memberof DepositData\r\n     */\r\n    updatedAt: number;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum DepositDataStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Received = 'received',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * DepositDataList\r\n * @export\r\n * @interface DepositDataList\r\n */\r\nexport interface DepositDataList {\r\n    /**\r\n     * Total number of records found\r\n     * @type {number}\r\n     * @memberof DepositDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of DepositRecord\r\n     * @type {Array<DepositData>}\r\n     * @memberof DepositDataList\r\n     */\r\n    transactions: Array<DepositData>;\r\n}\r\n/**\r\n * Order book info\r\n * @export\r\n * @interface Depth\r\n */\r\nexport interface Depth {\r\n    /**\r\n     * An ever-increasing numeric version number that reflects its change history.\r\n     * @type {number}\r\n     * @memberof Depth\r\n     */\r\n    version: number;\r\n    /**\r\n     * Update timestamp\r\n     * @type {number}\r\n     * @memberof Depth\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Array of bids, each item is an array that contains the price, size, volume and the number of orders aggregated at this price.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof Depth\r\n     */\r\n    bids: Array<Array<string>>;\r\n    /**\r\n     * Array of asks, each item is an array that contains the price, size, volume and the number of orders aggregated at this price.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof Depth\r\n     */\r\n    asks: Array<Array<string>>;\r\n}\r\n/**\r\n * Order book info\r\n * @export\r\n * @interface DepthV3\r\n */\r\nexport interface DepthV3 {\r\n    /**\r\n     * An ever-increasing numeric version number that reflects its change history.\r\n     * @type {number}\r\n     * @memberof DepthV3\r\n     */\r\n    version: number;\r\n    /**\r\n     * Update timestamp\r\n     * @type {number}\r\n     * @memberof DepthV3\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Array of bids, each item is an array that contains the price, size, volume and the number of orders aggregated at this price.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof DepthV3\r\n     */\r\n    bids: Array<Array<string>>;\r\n    /**\r\n     * Array of asks, each item is an array that contains the price, size, volume and the number of orders aggregated at this price.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof DepthV3\r\n     */\r\n    asks: Array<Array<string>>;\r\n}\r\n/**\r\n * DexAccount data\r\n * @export\r\n * @interface DexAccount\r\n */\r\nexport interface DexAccount {\r\n    /**\r\n     * field.dexAccount.accountId\r\n     * @type {number}\r\n     * @memberof DexAccount\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * field.dexAccount.owner\r\n     * @type {string}\r\n     * @memberof DexAccount\r\n     */\r\n    owner: string;\r\n    /**\r\n     * field.dexAccount.isFreeze\r\n     * @type {boolean}\r\n     * @memberof DexAccount\r\n     */\r\n    frozen: boolean;\r\n    /**\r\n     * field.dexAccount.publicKeyX\r\n     * @type {string}\r\n     * @memberof DexAccount\r\n     */\r\n    publicKeyX: string;\r\n    /**\r\n     * field.dexAccount.publicKeyY\r\n     * @type {string}\r\n     * @memberof DexAccount\r\n     */\r\n    publicKeyY: string;\r\n    /**\r\n     * field.dexAccount.tags\r\n     * @type {string}\r\n     * @memberof DexAccount\r\n     */\r\n    tags?: string;\r\n    /**\r\n     * field.dexAccount.keyNonce\r\n     * @type {number}\r\n     * @memberof DexAccount\r\n     */\r\n    keyNonce: number;\r\n    /**\r\n     * field.dexAccount.accountNonce\r\n     * @type {number}\r\n     * @memberof DexAccount\r\n     */\r\n    accountNonce: number;\r\n}\r\n/**\r\n * User information\r\n * @export\r\n * @interface DexAccountV3\r\n */\r\nexport interface DexAccountV3 {\r\n    /**\r\n     * Account ID\r\n     * @type {number}\r\n     * @memberof DexAccountV3\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * Ethereum address\r\n     * @type {string}\r\n     * @memberof DexAccountV3\r\n     */\r\n    owner: string;\r\n    /**\r\n     * The frozen state of the account, true stands for frozen, if the account is frozen, the user cant submit order.\r\n     * @type {boolean}\r\n     * @memberof DexAccountV3\r\n     */\r\n    frozen: boolean;\r\n    /**\r\n     * \r\n     * @type {PublicKey}\r\n     * @memberof DexAccountV3\r\n     */\r\n    publicKey: PublicKey;\r\n    /**\r\n     * Comma separated list of tags such as VIP levels, etc\r\n     * @type {string}\r\n     * @memberof DexAccountV3\r\n     */\r\n    tags?: string;\r\n    /**\r\n     * field.DexAccountV3.nonce\r\n     * @type {number}\r\n     * @memberof DexAccountV3\r\n     */\r\n    nonce: number;\r\n}\r\n/**\r\n * model.SubmitDualAuthTransferRequest.description\r\n * @export\r\n * @interface DualAuthTransferRequest\r\n */\r\nexport interface DualAuthTransferRequest {\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.exchange\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.payerId\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    payerId: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.payerAddr\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    payerAddr: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.token\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    token: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.amount\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    amount: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.feeToken\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    feeToken: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.maxFeeAmount\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    maxFeeAmount: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.storageId\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.validUntil\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    eddsaSig: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.dualAuthKeyX\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    dualAuthKeyX: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.dualAuthKeyY\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    dualAuthKeyY: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.dualEddsaSig\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    dualEddsaSig: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.dualPayeeId\r\n     * @type {number}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    dualPayeeId: number;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.dualPayeeAddr\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    dualPayeeAddr: string;\r\n    /**\r\n     * field.SubmitDualAuthTransferRequest.memo\r\n     * @type {string}\r\n     * @memberof DualAuthTransferRequest\r\n     */\r\n    memo?: string;\r\n}\r\n/**\r\n * field.exchangeInfo.description\r\n * @export\r\n * @interface ExchangeInfo\r\n */\r\nexport interface ExchangeInfo {\r\n    /**\r\n     * Loopring\\'s smart contract network ID.\r\n     * @type {number}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    chainId: number;\r\n    /**\r\n     * Contract address of exchange.\r\n     * @type {string}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    exchangeAddress: string;\r\n    /**\r\n     * field.ExchangeInfo.depositAddress\r\n     * @type {string}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    depositAddress: string;\r\n    /**\r\n     * Fees settings.\r\n     * @type {Array<FeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    onchainFees: Array<FeeInfo>;\r\n    /**\r\n     * field.ExchangeInfo.openAccountFee\r\n     * @type {Array<OffFeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    openAccountFees: Array<OffFeeInfo>;\r\n    /**\r\n     * field.ExchangeInfo.updateFees\r\n     * @type {Array<OffFeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    updateFees: Array<OffFeeInfo>;\r\n    /**\r\n     * Transfer fee settings.\r\n     * @type {Array<OffFeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    transferFees: Array<OffFeeInfo>;\r\n    /**\r\n     * Off-chain withdrawal fee settings.\r\n     * @type {Array<OffFeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    withdrawalFees: Array<OffFeeInfo>;\r\n    /**\r\n     * field.ExchangeInfo.fastWithdrawalFees\r\n     * @type {Array<OffFeeInfo>}\r\n     * @memberof ExchangeInfo\r\n     */\r\n    fastWithdrawalFees: Array<OffFeeInfo>;\r\n}\r\n/**\r\n * Information about fees charged by the exchange.\r\n * @export\r\n * @interface FeeInfo\r\n */\r\nexport interface FeeInfo {\r\n    /**\r\n     * Fee category.\r\n     * @type {string}\r\n     * @memberof FeeInfo\r\n     */\r\n    type: string;\r\n    /**\r\n     * Fee amount in Ether as wei.\r\n     * @type {string}\r\n     * @memberof FeeInfo\r\n     */\r\n    fee: string;\r\n}\r\n/**\r\n * The data structure of user query market fee rate\r\n * @export\r\n * @interface FeeRate\r\n */\r\nexport interface FeeRate {\r\n    /**\r\n     * Market\r\n     * @type {string}\r\n     * @memberof FeeRate\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Maker rate\r\n     * @type {number}\r\n     * @memberof FeeRate\r\n     */\r\n    makerRate: number;\r\n    /**\r\n     * Taker rate\r\n     * @type {number}\r\n     * @memberof FeeRate\r\n     */\r\n    takerRate: number;\r\n}\r\n/**\r\n * Send a raw Ethereum transaction\r\n * @export\r\n * @interface ForwardEthTxRequest\r\n */\r\nexport interface ForwardEthTxRequest {\r\n    /**\r\n     * Serialized Ethereum signature transaction as hexadecimal string\r\n     * @type {string}\r\n     * @memberof ForwardEthTxRequest\r\n     */\r\n    data: string;\r\n}\r\n/**\r\n * Response of sending raw transaction\r\n * @export\r\n * @interface ForwardEthTxResponse\r\n */\r\nexport interface ForwardEthTxResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof ForwardEthTxResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Transaction hash\r\n     * @type {string}\r\n     * @memberof ForwardEthTxResponse\r\n     */\r\n    data?: string;\r\n}\r\n/**\r\n * model.getAccountResponse\r\n * @export\r\n * @interface GetAccountResponseV2\r\n */\r\nexport interface GetAccountResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAccountResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {DexAccount}\r\n     * @memberof GetAccountResponseV2\r\n     */\r\n    data: DexAccount;\r\n}\r\n/**\r\n * Query the allowance return of the Ethereum address on the exchange\r\n * @export\r\n * @interface GetAllowancesV2Response\r\n */\r\nexport interface GetAllowancesV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAllowancesV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Allowance amount in wei\r\n     * @type {Array<string>}\r\n     * @memberof GetAllowancesV2Response\r\n     */\r\n    data?: Array<string>;\r\n}\r\n/**\r\n * model.getAmmMarketInfoResponse\r\n * @export\r\n * @interface GetAmmMarketInfoResponse\r\n */\r\nexport interface GetAmmMarketInfoResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAmmMarketInfoResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.getAmmMarketInfoResponse.data\r\n     * @type {Array<AmmMarketInfo>}\r\n     * @memberof GetAmmMarketInfoResponse\r\n     */\r\n    data?: Array<AmmMarketInfo>;\r\n}\r\n/**\r\n * model.GetAmmPoolsResponse.description\r\n * @export\r\n * @interface GetAmmPoolsResponse\r\n */\r\nexport interface GetAmmPoolsResponse {\r\n    /**\r\n     * AMM pool list\r\n     * @type {Array<AmmPoolInfoV3>}\r\n     * @memberof GetAmmPoolsResponse\r\n     */\r\n    pools: Array<AmmPoolInfoV3>;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface GetAmmPoolsStatsResponse\r\n */\r\nexport interface GetAmmPoolsStatsResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAmmPoolsStatsResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * model.AmmPoolStatistics\r\n     * @type {Array<AmmPoolStatistics>}\r\n     * @memberof GetAmmPoolsStatsResponse\r\n     */\r\n    data: Array<AmmPoolStatistics>;\r\n}\r\n/**\r\n * model.GetAmmSnapshotResponse\r\n * @export\r\n * @interface GetAmmSnapshotResponse\r\n */\r\nexport interface GetAmmSnapshotResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAmmSnapshotResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {AmmSnapshot}\r\n     * @memberof GetAmmSnapshotResponse\r\n     */\r\n    data: AmmSnapshot;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface GetAmmTradesResponseV2\r\n */\r\nexport interface GetAmmTradesResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAmmTradesResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {AmmTradeDataList}\r\n     * @memberof GetAmmTradesResponseV2\r\n     */\r\n    data: AmmTradeDataList;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface GetAmmTransactionResponseV2\r\n */\r\nexport interface GetAmmTransactionResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetAmmTransactionResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {AmmTransactionDataList}\r\n     * @memberof GetAmmTransactionResponseV2\r\n     */\r\n    data: AmmTransactionDataList;\r\n}\r\n/**\r\n * model.applyApiKey.description\r\n * @export\r\n * @interface GetApiKeyRequest\r\n */\r\nexport interface GetApiKeyRequest {\r\n    /**\r\n     * AccountID\r\n     * @type {number}\r\n     * @memberof GetApiKeyRequest\r\n     */\r\n    accountId: number;\r\n}\r\n/**\r\n * model.getApiKeyResponseV2\r\n * @export\r\n * @interface GetApiKeyResponseV2\r\n */\r\nexport interface GetApiKeyResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetApiKeyResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.getApiKeyResponseV2.data\r\n     * @type {string}\r\n     * @memberof GetApiKeyResponseV2\r\n     */\r\n    data: string;\r\n}\r\n/**\r\n * The Response of updating user\\'s ApiKey\r\n * @export\r\n * @interface GetApiKeyResponseV3\r\n */\r\nexport interface GetApiKeyResponseV3 {\r\n    /**\r\n     * ApiKey\r\n     * @type {string}\r\n     * @memberof GetApiKeyResponseV3\r\n     */\r\n    apiKey: string;\r\n}\r\n/**\r\n * The response of query Candlestick data\r\n * @export\r\n * @interface GetCandlestickResponseV2\r\n */\r\nexport interface GetCandlestickResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetCandlestickResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Candlestick data, each set of data includes start time, number of transactions, opening price, closing price, highest price, lowest price, total transaction volume of Base Token, total transaction volume of Quote Token\r\n     * @type {Array<Array<string>>}\r\n     * @memberof GetCandlestickResponseV2\r\n     */\r\n    data?: Array<Array<string>>;\r\n}\r\n/**\r\n * The response of query Candlestick data\r\n * @export\r\n * @interface GetCandlestickResponseV3\r\n */\r\nexport interface GetCandlestickResponseV3 {\r\n    /**\r\n     * Candlestick data, each set of data includes start time, number of transactions, opening price, closing price, highest price, lowest price, total transaction volume of Base Token, total transaction volume of Quote Token\r\n     * @type {Array<Array<string>>}\r\n     * @memberof GetCandlestickResponseV3\r\n     */\r\n    candlesticks?: Array<Array<string>>;\r\n}\r\n/**\r\n * response of querying order book\r\n * @export\r\n * @interface GetDepthResponseV2\r\n */\r\nexport interface GetDepthResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetDepthResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {Depth}\r\n     * @memberof GetDepthResponseV2\r\n     */\r\n    data?: Depth;\r\n}\r\n/**\r\n * The query result of Ethereum address ETH balance\r\n * @export\r\n * @interface GetEthBalancesV2Response\r\n */\r\nexport interface GetEthBalancesV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetEthBalancesV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Balance in wei\r\n     * @type {string}\r\n     * @memberof GetEthBalancesV2Response\r\n     */\r\n    data?: string;\r\n}\r\n/**\r\n * Query the result returned by Ethereum address nonce\r\n * @export\r\n * @interface GetEthNonceV2Response\r\n */\r\nexport interface GetEthNonceV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetEthNonceV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * The result of nonce\r\n     * @type {number}\r\n     * @memberof GetEthNonceV2Response\r\n     */\r\n    data?: number;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface GetExchangeInfoResponse\r\n */\r\nexport interface GetExchangeInfoResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetExchangeInfoResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {ExchangeInfo}\r\n     * @memberof GetExchangeInfoResponse\r\n     */\r\n    data?: ExchangeInfo;\r\n}\r\n/**\r\n * model.getMarketInfoResponse\r\n * @export\r\n * @interface GetMarketInfoResponse\r\n */\r\nexport interface GetMarketInfoResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetMarketInfoResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.getMarketInfoResponse.data\r\n     * @type {Array<MarketInfo>}\r\n     * @memberof GetMarketInfoResponse\r\n     */\r\n    data?: Array<MarketInfo>;\r\n}\r\n/**\r\n * Query market trades returns\r\n * @export\r\n * @interface GetMarketTradesV2Response\r\n */\r\nexport interface GetMarketTradesV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetMarketTradesV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {MarketTrades}\r\n     * @memberof GetMarketTradesV2Response\r\n     */\r\n    data?: MarketTrades;\r\n}\r\n/**\r\n * model.GetMarketsResponseV3.description\r\n * @export\r\n * @interface GetMarketsResponseV3\r\n */\r\nexport interface GetMarketsResponseV3 {\r\n    /**\r\n     * Markets list\r\n     * @type {Array<MarketInfo>}\r\n     * @memberof GetMarketsResponseV3\r\n     */\r\n    markets: Array<MarketInfo>;\r\n}\r\n/**\r\n * model.GetNextStorageIdResponseData.description\r\n * @export\r\n * @interface GetNextStorageIdResponseData\r\n */\r\nexport interface GetNextStorageIdResponseData {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetNextStorageIdResponseData\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {NextStorageIdResponse}\r\n     * @memberof GetNextStorageIdResponseData\r\n     */\r\n    data: NextStorageIdResponse;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetOrderDetailResponseV2\r\n */\r\nexport interface GetOrderDetailResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetOrderDetailResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {OrderDetail}\r\n     * @memberof GetOrderDetailResponseV2\r\n     */\r\n    data?: OrderDetail;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetOrdersResponseV2\r\n */\r\nexport interface GetOrdersResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetOrdersResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {OrdersDetail}\r\n     * @memberof GetOrdersResponseV2\r\n     */\r\n    data?: OrdersDetail;\r\n}\r\n/**\r\n * model.GetPriceResponseV3\r\n * @export\r\n * @interface GetPriceResponseV3\r\n */\r\nexport interface GetPriceResponseV3 {\r\n    /**\r\n     * field.GetPriceResponseV3.prices\r\n     * @type {Array<PriceV3>}\r\n     * @memberof GetPriceResponseV3\r\n     */\r\n    prices?: Array<PriceV3>;\r\n}\r\n/**\r\n * model.getPriceResponse\r\n * @export\r\n * @interface GetPriceV2Response\r\n */\r\nexport interface GetPriceV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetPriceV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.getPriceResponse.data\r\n     * @type {Array<Price>}\r\n     * @memberof GetPriceV2Response\r\n     */\r\n    data?: Array<Price>;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetRecommendedGasPriceResponseV2\r\n */\r\nexport interface GetRecommendedGasPriceResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetRecommendedGasPriceResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Response value of current recommended gas price in Gwei\r\n     * @type {string}\r\n     * @memberof GetRecommendedGasPriceResponseV2\r\n     */\r\n    data?: string;\r\n}\r\n/**\r\n * model.getTicker.description\r\n * @export\r\n * @interface GetTickerResponseV2\r\n */\r\nexport interface GetTickerResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetTickerResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Each item in the list is an array that contains the following: trading pair ID, update timestamp, base token volume, quote token volume, open-price, highest price, lowest price, closing price, number of trades, highest bid price, lowest ask price, base fee amount, quote fee amount. All values are returned as strings. Fee amount is for AMM only.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof GetTickerResponseV2\r\n     */\r\n    data?: Array<Array<string>>;\r\n}\r\n/**\r\n * model.getTicker.description\r\n * @export\r\n * @interface GetTickerResponseV3\r\n */\r\nexport interface GetTickerResponseV3 {\r\n    /**\r\n     * Each item in the list is an array that contains the following: trading pair ID, update timestamp, base token volume, quote token volume, open-price, highest price, lowest price, closing price, number of trades, highest bid price, lowest ask price, base fee amount, quote fee amount. All values are returned as strings. Fee amount is for AMM only.\r\n     * @type {Array<Array<string>>}\r\n     * @memberof GetTickerResponseV3\r\n     */\r\n    tickers?: Array<Array<string>>;\r\n}\r\n/**\r\n * model.getTimestampV2Response\r\n * @export\r\n * @interface GetTimestampV2Response\r\n */\r\nexport interface GetTimestampV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetTimestampV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.getTimestampV2Response.data\r\n     * @type {number}\r\n     * @memberof GetTimestampV2Response\r\n     */\r\n    data?: number;\r\n}\r\n/**\r\n * The query result of Ethereum address token balances\r\n * @export\r\n * @interface GetTokenBalancesV2Response\r\n */\r\nexport interface GetTokenBalancesV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetTokenBalancesV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Balance in wei\r\n     * @type {Array<string>}\r\n     * @memberof GetTokenBalancesV2Response\r\n     */\r\n    data?: Array<string>;\r\n}\r\n/**\r\n * Tokens information supported by the exchange\r\n * @export\r\n * @interface GetTokenInfoResponse\r\n */\r\nexport interface GetTokenInfoResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetTokenInfoResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Token list\r\n     * @type {Array<TokenInfo>}\r\n     * @memberof GetTokenInfoResponse\r\n     */\r\n    data?: Array<TokenInfo>;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserAccountUpdateResponseV2\r\n */\r\nexport interface GetUserAccountUpdateResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserAccountUpdateResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {UserAccountUpdateDataList}\r\n     * @memberof GetUserAccountUpdateResponseV2\r\n     */\r\n    data?: UserAccountUpdateDataList;\r\n}\r\n/**\r\n * The response of querying user\\'s exchange balance\r\n * @export\r\n * @interface GetUserBalancesResponseV2\r\n */\r\nexport interface GetUserBalancesResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserBalancesResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * field.Balance.balances\r\n     * @type {Array<Balance>}\r\n     * @memberof GetUserBalancesResponseV2\r\n     */\r\n    data: Array<Balance>;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserCreateResponseV2\r\n */\r\nexport interface GetUserCreateResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserCreateResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {UserCreateDataList}\r\n     * @memberof GetUserCreateResponseV2\r\n     */\r\n    data?: UserCreateDataList;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserDepositResponseV2\r\n */\r\nexport interface GetUserDepositResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserDepositResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {DepositDataList}\r\n     * @memberof GetUserDepositResponseV2\r\n     */\r\n    data?: DepositDataList;\r\n}\r\n/**\r\n * The results returned by query user fee rates\r\n * @export\r\n * @interface GetUserFeeRatesV2Response\r\n */\r\nexport interface GetUserFeeRatesV2Response {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserFeeRatesV2Response\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * The results returned by query user fee rates\r\n     * @type {Array<FeeRate>}\r\n     * @memberof GetUserFeeRatesV2Response\r\n     */\r\n    data?: Array<FeeRate>;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserOnchainWithdrawalResponseV2\r\n */\r\nexport interface GetUserOnchainWithdrawalResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserOnchainWithdrawalResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {OnchainWithdrawalDataList}\r\n     * @memberof GetUserOnchainWithdrawalResponseV2\r\n     */\r\n    data?: OnchainWithdrawalDataList;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserTradesResponseV2\r\n */\r\nexport interface GetUserTradesResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserTradesResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {TradeList}\r\n     * @memberof GetUserTradesResponseV2\r\n     */\r\n    data?: TradeList;\r\n}\r\n/**\r\n * Response body\r\n * @export\r\n * @interface GetUserTransferResponse\r\n */\r\nexport interface GetUserTransferResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetUserTransferResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {TransferDataList}\r\n     * @memberof GetUserTransferResponse\r\n     */\r\n    data?: TransferDataList;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface GetWithdrawalAgentsResponse\r\n */\r\nexport interface GetWithdrawalAgentsResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof GetWithdrawalAgentsResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * Necessary data to interact with the exchange\r\n     * @type {Array<AgentInfo>}\r\n     * @memberof GetWithdrawalAgentsResponse\r\n     */\r\n    data?: Array<AgentInfo>;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface MarketInfo\r\n */\r\nexport interface MarketInfo {\r\n    /**\r\n     * Trading pair ID\r\n     * @type {string}\r\n     * @memberof MarketInfo\r\n     */\r\n    market: string;\r\n    /**\r\n     * The base token ID\r\n     * @type {number}\r\n     * @memberof MarketInfo\r\n     */\r\n    baseTokenId: number;\r\n    /**\r\n     * The quote token ID\r\n     * @type {number}\r\n     * @memberof MarketInfo\r\n     */\r\n    quoteTokenId: number;\r\n    /**\r\n     * The precision of price\r\n     * @type {number}\r\n     * @memberof MarketInfo\r\n     */\r\n    precisionForPrice: number;\r\n    /**\r\n     * The max level of orderbook price aggregation\r\n     * @type {number}\r\n     * @memberof MarketInfo\r\n     */\r\n    orderbookAggLevels: number;\r\n    /**\r\n     * True if trading is enabled for this trading pair\r\n     * @type {boolean}\r\n     * @memberof MarketInfo\r\n     */\r\n    enabled: boolean;\r\n}\r\n/**\r\n * model.marketTrades\r\n * @export\r\n * @interface MarketTrades\r\n */\r\nexport interface MarketTrades {\r\n    /**\r\n     * field.marketTrades.totalNum\r\n     * @type {number}\r\n     * @memberof MarketTrades\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * field.marketTrades.trades\r\n     * @type {Array<Array<string>>}\r\n     * @memberof MarketTrades\r\n     */\r\n    trades: Array<Array<string>>;\r\n}\r\n/**\r\n * model.MarketTrades\r\n * @export\r\n * @interface MarketTradesV3\r\n */\r\nexport interface MarketTradesV3 {\r\n    /**\r\n     * field.MarketTradesV3.totalNum\r\n     * @type {number}\r\n     * @memberof MarketTradesV3\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * field.MarketTradesV3.trades\r\n     * @type {Array<Array<string>>}\r\n     * @memberof MarketTradesV3\r\n     */\r\n    trades: Array<Array<string>>;\r\n}\r\n/**\r\n * {{model.NextStorageIdResponse.description}\r\n * @export\r\n * @interface NextStorageIdResponse\r\n */\r\nexport interface NextStorageIdResponse {\r\n    /**\r\n     * Next storage ID for order request, must be even\r\n     * @type {number}\r\n     * @memberof NextStorageIdResponse\r\n     */\r\n    orderId?: number;\r\n    /**\r\n     * Next storage ID for offchain requests, i.e., transfer/withdraw/updateAccount, must be odd\r\n     * @type {number}\r\n     * @memberof NextStorageIdResponse\r\n     */\r\n    offchainId?: number;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface OffChainWithdrawalRequest\r\n */\r\nexport interface OffChainWithdrawalRequest {\r\n    /**\r\n     * exchange address\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * account id in exchange\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * owner of accountId in exchange\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    owner: string;\r\n    /**\r\n     * withdraw token id\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    token: number;\r\n    /**\r\n     * withdraw amount of token, decimal string in WEI\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    amount: string;\r\n    /**\r\n     * fee token id in exchange\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    feeToken: number;\r\n    /**\r\n     * fee amount of token, decimal string in WEI\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    maxFeeAmount: string;\r\n    /**\r\n     * dex offchain request storageID of the account\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * valid until\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * min gas\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    minGas: number;\r\n    /**\r\n     * to address\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    to: string;\r\n    /**\r\n     * extra data\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    extraData?: string;\r\n    /**\r\n     * fastWithdrawal mode\r\n     * @type {boolean}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    fastWithdrawalMode?: boolean;\r\n    /**\r\n     * eddsaSig of this request, hex string\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    eddsaSig?: string;\r\n    /**\r\n     * trading ecdsa_sig signature of this order, decimal string\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequest\r\n     */\r\n    ecdsaSig?: string;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface OffChainWithdrawalRequestV3\r\n */\r\nexport interface OffChainWithdrawalRequestV3 {\r\n    /**\r\n     * exchange address\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * account ID\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * account owner address\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    owner: string;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    token: TokenVolumeV3;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    maxFee: TokenVolumeV3;\r\n    /**\r\n     * offchain ID\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * Timestamp for order to become invalid\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * min gas for on-chain withdraw, Loopring exchange allocates gas for each distribution, but people can also assign this min gas, so Loopring have to allocate higher gas value for this specific distribution. Normally no need to take care of this value, 0 means let loopring choose the reasonable gas\r\n     * @type {number}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    minGas: number;\r\n    /**\r\n     * withdraw to address\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    to: string;\r\n    /**\r\n     * extra data for complex withdraw mode, normally none\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    extraData?: string;\r\n    /**\r\n     * is fast withdraw mode\r\n     * @type {boolean}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    fastWithdrawalMode?: boolean;\r\n    /**\r\n     * eddsa signature\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    eddsaSignature?: string;\r\n    /**\r\n     * ecdsa signature\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    ecdsaSignature?: string;\r\n    /**\r\n     * An approved hash string which was already submitted on eth mainnet\r\n     * @type {string}\r\n     * @memberof OffChainWithdrawalRequestV3\r\n     */\r\n    hashApproved?: string;\r\n}\r\n/**\r\n * Off-chain fee info charged by loopring exchange.\r\n * @export\r\n * @interface OffFeeInfo\r\n */\r\nexport interface OffFeeInfo {\r\n    /**\r\n     * fee token\r\n     * @type {string}\r\n     * @memberof OffFeeInfo\r\n     */\r\n    token: string;\r\n    /**\r\n     * fee amount\r\n     * @type {string}\r\n     * @memberof OffFeeInfo\r\n     */\r\n    fee: string;\r\n}\r\n/**\r\n * OnchainWithdrawalDataList\r\n * @export\r\n * @interface OnchainWithdrawalDataList\r\n */\r\nexport interface OnchainWithdrawalDataList {\r\n    /**\r\n     * Total number of records found\r\n     * @type {number}\r\n     * @memberof OnchainWithdrawalDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of OnchainWithdrawalRecord\r\n     * @type {Array<WithdrawalData>}\r\n     * @memberof OnchainWithdrawalDataList\r\n     */\r\n    transactions: Array<WithdrawalData>;\r\n}\r\n/**\r\n * Contains information about the order amounts that are valid for usage with the token in order-related APIs.\r\n * @export\r\n * @interface OrderAmountsV3\r\n */\r\nexport interface OrderAmountsV3 {\r\n    /**\r\n     * The minimum amount enforced when submitting orders for the token.\r\n     * @type {string}\r\n     * @memberof OrderAmountsV3\r\n     */\r\n    minimum: string;\r\n    /**\r\n     * The maximum amount enforced when submitting orders for the token.\r\n     * @type {string}\r\n     * @memberof OrderAmountsV3\r\n     */\r\n    maximum: string;\r\n    /**\r\n     * The dust amount enforced when submitting orders for the token.\r\n     * @type {string}\r\n     * @memberof OrderAmountsV3\r\n     */\r\n    dust: string;\r\n}\r\n/**\r\n * Response details of order\r\n * @export\r\n * @interface OrderDetail\r\n */\r\nexport interface OrderDetail {\r\n    /**\r\n     * Order hash\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Order\\'s client-side ID\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    clientOrderId: string;\r\n    /**\r\n     * field.OrderDetail.size\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    size: string;\r\n    /**\r\n     * field.OrderDetail.volume\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    volume: string;\r\n    /**\r\n     * Order price\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    price: string;\r\n    /**\r\n     * field.OrderDetail.filledSize\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    filledSize: string;\r\n    /**\r\n     * field.OrderDetail.filledVolume\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    filledVolume: string;\r\n    /**\r\n     * field.OrderDetail.filledFee\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    filledFee: string;\r\n    /**\r\n     * Order status\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    status: OrderDetailStatusEnum;\r\n    /**\r\n     * field.OrderDetail.validUntil\r\n     * @type {number}\r\n     * @memberof OrderDetail\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.OrderDetail.createdAt\r\n     * @type {number}\r\n     * @memberof OrderDetail\r\n     */\r\n    createdAt: number;\r\n    /**\r\n     * Order\\'s side\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    side: OrderDetailSideEnum;\r\n    /**\r\n     * Trading pair\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    market: string;\r\n    /**\r\n     * Whether the order has to be treated as a limit, maker, or taker operation.\r\n     * @type {string}\r\n     * @memberof OrderDetail\r\n     */\r\n    orderType: OrderDetailOrderTypeEnum;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Cancelling = 'cancelling',\r\n    Cancelled = 'cancelled',\r\n    Expired = 'expired',\r\n    Waiting = 'waiting'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailSideEnum {\r\n    Sell = 'SELL',\r\n    Buy = 'BUY'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailOrderTypeEnum {\r\n    LimitOrder = 'LIMIT_ORDER',\r\n    TakerOnly = 'TAKER_ONLY',\r\n    MakerOnly = 'MAKER_ONLY'\r\n}\r\n\r\n/**\r\n * Response details of order\r\n * @export\r\n * @interface OrderDetailV3\r\n */\r\nexport interface OrderDetailV3 {\r\n    /**\r\n     * Order hash\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Order\\'s client-side ID\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    clientOrderId: string;\r\n    /**\r\n     * Order\\'s side\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    side: OrderDetailV3SideEnum;\r\n    /**\r\n     * Trading pair\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    market: string;\r\n    /**\r\n     * Order price\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    price: string;\r\n    /**\r\n     * \r\n     * @type {OrderVolumesV3}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    volumes: OrderVolumesV3;\r\n    /**\r\n     * \r\n     * @type {OrderValidityV3}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    validity: OrderValidityV3;\r\n    /**\r\n     * Whether the order has to be treated as a limit, maker, or taker operation.\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    orderType: OrderDetailV3OrderTypeEnum;\r\n    /**\r\n     * Order status\r\n     * @type {string}\r\n     * @memberof OrderDetailV3\r\n     */\r\n    status: OrderDetailV3StatusEnum;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailV3SideEnum {\r\n    Sell = 'SELL',\r\n    Buy = 'BUY'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailV3OrderTypeEnum {\r\n    LimitOrder = 'LIMIT_ORDER',\r\n    TakerOnly = 'TAKER_ONLY',\r\n    MakerOnly = 'MAKER_ONLY'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum OrderDetailV3StatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Cancelling = 'cancelling',\r\n    Cancelled = 'cancelled',\r\n    Expired = 'expired',\r\n    Waiting = 'waiting'\r\n}\r\n\r\n/**\r\n * Wraps data regarding time validity constraints (since and until\r\n * @export\r\n * @interface OrderValidityV3\r\n */\r\nexport interface OrderValidityV3 {\r\n    /**\r\n     * Timestamp from when the order officially becomes valid and fillable\r\n     * @type {number}\r\n     * @memberof OrderValidityV3\r\n     */\r\n    start: number;\r\n    /**\r\n     * Timestamp from when the order ceases to be valid and fillable\r\n     * @type {number}\r\n     * @memberof OrderValidityV3\r\n     */\r\n    end: number;\r\n}\r\n/**\r\n * Wraps data regarding the orders volumes (base, quote, and filled.)\r\n * @export\r\n * @interface OrderVolumesV3\r\n */\r\nexport interface OrderVolumesV3 {\r\n    /**\r\n     * The amount of base tokens involved in the order.\r\n     * @type {string}\r\n     * @memberof OrderVolumesV3\r\n     */\r\n    baseAmount: string;\r\n    /**\r\n     * The amount of quote tokens involved in the order.\r\n     * @type {string}\r\n     * @memberof OrderVolumesV3\r\n     */\r\n    quoteAmount: string;\r\n    /**\r\n     * The amount of requested base tokens filled in the order.\r\n     * @type {string}\r\n     * @memberof OrderVolumesV3\r\n     */\r\n    baseFilled: string;\r\n    /**\r\n     * The amount of requested quote tokens filled in the order.\r\n     * @type {string}\r\n     * @memberof OrderVolumesV3\r\n     */\r\n    quoteFilled: string;\r\n    /**\r\n     * The amount of quote or base token amount used to pay for the orders fee. Whether this data refers to the base or quote token, one can find out by looking at the orders side\r\n     * @type {string}\r\n     * @memberof OrderVolumesV3\r\n     */\r\n    fee: string;\r\n}\r\n/**\r\n * Response orders\r\n * @export\r\n * @interface OrdersDetail\r\n */\r\nexport interface OrdersDetail {\r\n    /**\r\n     * Total number of orders\r\n     * @type {number}\r\n     * @memberof OrdersDetail\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of order\r\n     * @type {Array<OrderDetail>}\r\n     * @memberof OrdersDetail\r\n     */\r\n    orders?: Array<OrderDetail>;\r\n}\r\n/**\r\n * Response orders\r\n * @export\r\n * @interface OrdersDetailV3\r\n */\r\nexport interface OrdersDetailV3 {\r\n    /**\r\n     * Total number of orders\r\n     * @type {number}\r\n     * @memberof OrdersDetailV3\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of order\r\n     * @type {Array<OrderDetailV3>}\r\n     * @memberof OrdersDetailV3\r\n     */\r\n    orders?: Array<OrderDetailV3>;\r\n}\r\n/**\r\n * model.SubmitOriginTransferRequest.description\r\n * @export\r\n * @interface OriginTransferRequest\r\n */\r\nexport interface OriginTransferRequest {\r\n    /**\r\n     * field.SubmitOriginTransferRequest.exchange\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.payerId\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    payerId: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.payerAddr\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    payerAddr: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.payeeId\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    payeeId: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.payeeAddr\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    payeeAddr: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.token\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    token: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.amount\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    amount: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.feeToken\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    feeToken: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.maxFeeAmount\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    maxFeeAmount: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.storageId\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.validUntil\r\n     * @type {number}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    eddsaSig?: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.ecdsaSig\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    ecdsaSig?: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.memo\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    memo?: string;\r\n    /**\r\n     * field.SubmitOriginTransferRequest.clientId\r\n     * @type {string}\r\n     * @memberof OriginTransferRequest\r\n     */\r\n    clientId?: string;\r\n}\r\n/**\r\n * Submit internal transfer params\r\n * @export\r\n * @interface OriginTransferRequestV3\r\n */\r\nexport interface OriginTransferRequestV3 {\r\n    /**\r\n     * exchange address\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * payer account ID\r\n     * @type {number}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    payerId: number;\r\n    /**\r\n     * payer account address\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    payerAddr: string;\r\n    /**\r\n     * payee account ID\r\n     * @type {number}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    payeeId: number;\r\n    /**\r\n     * payer account address\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    payeeAddr: string;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    token: TokenVolumeV3;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    maxFee: TokenVolumeV3;\r\n    /**\r\n     * offchain Id\r\n     * @type {number}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * Timestamp for order to become invalid\r\n     * @type {number}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * eddsa signature\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    eddsaSignature?: string;\r\n    /**\r\n     * ecdsa signature\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    ecdsaSignature?: string;\r\n    /**\r\n     * An approved hash string which was already submitted on eth mainnet\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    hashApproved?: string;\r\n    /**\r\n     * transfer memo\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    memo?: string;\r\n    /**\r\n     * A user-defined id\r\n     * @type {string}\r\n     * @memberof OriginTransferRequestV3\r\n     */\r\n    clientId?: string;\r\n}\r\n/**\r\n * Users pending balances\r\n * @export\r\n * @interface PendingBalance\r\n */\r\nexport interface PendingBalance {\r\n    /**\r\n     * Withdrawal pending balance which means the token is in withdrawal state but not arrived L1\r\n     * @type {string}\r\n     * @memberof PendingBalance\r\n     */\r\n    withdraw: string;\r\n    /**\r\n     * Deposit pending balance which means the token is in deposit state but not arrived L2\r\n     * @type {string}\r\n     * @memberof PendingBalance\r\n     */\r\n    deposit: string;\r\n}\r\n/**\r\n * Token fiat price\r\n * @export\r\n * @interface Price\r\n */\r\nexport interface Price {\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof Price\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Fiat price\r\n     * @type {string}\r\n     * @memberof Price\r\n     */\r\n    price: string;\r\n    /**\r\n     * Last update timestamp\r\n     * @type {number}\r\n     * @memberof Price\r\n     */\r\n    timestamp: number;\r\n}\r\n/**\r\n * Token fiat price\r\n * @export\r\n * @interface PriceV3\r\n */\r\nexport interface PriceV3 {\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof PriceV3\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Fiat price\r\n     * @type {string}\r\n     * @memberof PriceV3\r\n     */\r\n    price: string;\r\n    /**\r\n     * Last update timestamp\r\n     * @type {number}\r\n     * @memberof PriceV3\r\n     */\r\n    updatedAt: number;\r\n}\r\n/**\r\n * Describes the users public key which is a point of the selected eclipse curve.\r\n * @export\r\n * @interface PublicKey\r\n */\r\nexport interface PublicKey {\r\n    /**\r\n     * The public keys x part.\r\n     * @type {string}\r\n     * @memberof PublicKey\r\n     */\r\n    x: string;\r\n    /**\r\n     * The public keys y part.\r\n     * @type {string}\r\n     * @memberof PublicKey\r\n     */\r\n    y: string;\r\n}\r\n/**\r\n * Information returned by the API\r\n * @export\r\n * @interface ResultInfo\r\n */\r\nexport interface ResultInfo {\r\n    /**\r\n     * The returned code\r\n     * @type {number}\r\n     * @memberof ResultInfo\r\n     */\r\n    code: number;\r\n    /**\r\n     * The returned message\r\n     * @type {string}\r\n     * @memberof ResultInfo\r\n     */\r\n    message: string;\r\n}\r\n/**\r\n * Response detail of submitted off chain requests\r\n * @export\r\n * @interface SubmitOffChainRequestItem\r\n */\r\nexport interface SubmitOffChainRequestItem {\r\n    /**\r\n     * The order hash identifier set by the user at the time of submission\r\n     * @type {string}\r\n     * @memberof SubmitOffChainRequestItem\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Whether the order was successfully submitted or not, please note, user may query after a while to get real process status, as most offchain requests are async processed\r\n     * @type {string}\r\n     * @memberof SubmitOffChainRequestItem\r\n     */\r\n    status: SubmitOffChainRequestItemStatusEnum;\r\n    /**\r\n     * Idempotent of submit order response, submit same order again when order was UNKNOWN or WAIT_FREEZE_BALANCE in relayer, idempotent will be true\r\n     * @type {boolean}\r\n     * @memberof SubmitOffChainRequestItem\r\n     */\r\n    isIdempotent: boolean;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum SubmitOffChainRequestItemStatusEnum {\r\n    Received = 'received',\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * model.submitOffChainRequest.response\r\n * @export\r\n * @interface SubmitOffChainRequestResponse\r\n */\r\nexport interface SubmitOffChainRequestResponse {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof SubmitOffChainRequestResponse\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {SubmitOffChainRequestItem}\r\n     * @memberof SubmitOffChainRequestResponse\r\n     */\r\n    data?: SubmitOffChainRequestItem;\r\n}\r\n/**\r\n * model.SubmitOrderRequest.description\r\n * @export\r\n * @interface SubmitOrderRequest\r\n */\r\nexport interface SubmitOrderRequest {\r\n    /**\r\n     * field.SubmitOrderRequest.exchange\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * field.SubmitOrderRequest.storageId\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * field.SubmitOrderRequest.accountId\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * field.SubmitOrderRequest.tokenSId\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    tokenSId: number;\r\n    /**\r\n     * field.SubmitOrderRequest.tokenBId\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    tokenBId: number;\r\n    /**\r\n     * field.SubmitOrderRequest.amountS\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    amountS: string;\r\n    /**\r\n     * field.SubmitOrderRequest.amountB\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    amountB: string;\r\n    /**\r\n     * field.SubmitOrderRequest.allOrNone\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    allOrNone?: string;\r\n    /**\r\n     * field.SubmitOrderRequest.fillAmountBOrS\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    fillAmountBOrS: string;\r\n    /**\r\n     * field.SubmitOrderRequest.validUntil\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.SubmitOrderRequest.maxFeeBips\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    maxFeeBips: number;\r\n    /**\r\n     * field.SubmitOrderRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    eddsaSig: string;\r\n    /**\r\n     * field.SubmitOrderRequest.clientOrderId\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    clientOrderId?: string;\r\n    /**\r\n     * field.SubmitOrderRequest.channelId\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    channelId?: string;\r\n    /**\r\n     * field.SubmitOrderRequest.orderType\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    orderType?: SubmitOrderRequestOrderTypeEnum;\r\n    /**\r\n     * field.SubmitOrderRequest.taker\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    taker?: string;\r\n    /**\r\n     * field.SubmitOrderRequest.taker\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequest\r\n     */\r\n    poolAddress?: string;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum SubmitOrderRequestOrderTypeEnum {\r\n    LimitOrder = 'LIMIT_ORDER',\r\n    TakerOnly = 'TAKER_ONLY',\r\n    MakerOnly = 'MAKER_ONLY',\r\n    ClassAmm = 'class_amm'\r\n}\r\n\r\n/**\r\n * Describes an orders structure.\r\n * @export\r\n * @interface SubmitOrderRequestV3\r\n */\r\nexport interface SubmitOrderRequestV3 {\r\n    /**\r\n     * The adderss of the exchange which has to process this order\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * Loopring\\'s account ID\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * The unique identifier of the L2 Merkle tree storage slot where the burn made in order to exit the pool will or has been stored.\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    storageId: number;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    sellToken: TokenVolumeV3;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    buyToken: TokenVolumeV3;\r\n    /**\r\n     * Whether the order supports partial fills or not.Currently only supports false as a valid value\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    allOrNone: string;\r\n    /**\r\n     * Fill size by buy token or by sell token\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    fillAmountBOrS: string;\r\n    /**\r\n     * Order expiration time, accuracy is in seconds\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * Maximum order fee that the user can accept, value range (in ten thousandths) 1 ~ 63\r\n     * @type {number}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    maxFeeBips: number;\r\n    /**\r\n     * The orders EdDSA signature. The signature is a hexadecimal string obtained by signing the order itself and concatenating the resulting signature parts (Rx, Ry, and S). Used to authenticate and authorize the operation.\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    eddsaSignature: string;\r\n    /**\r\n     * An arbitrary, client-set unique order identifier, max length is 120 bytes\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    clientOrderId?: string;\r\n    /**\r\n     * Order types, can be AMM, LIMIT_ORDER, MAKER_ONLY, TAKER_ONLY\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    orderType?: SubmitOrderRequestV3OrderTypeEnum;\r\n    /**\r\n     * Used by the P2P order which user specify the taker, so far its 0x0000000000000000000000000000000000000000\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    taker?: string;\r\n    /**\r\n     * The AMM pool address if order type is AMM\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    poolAddress?: string;\r\n    /**\r\n     * Aux data to mark the order source\r\n     * @type {string}\r\n     * @memberof SubmitOrderRequestV3\r\n     */\r\n    channelId?: string;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum SubmitOrderRequestV3OrderTypeEnum {\r\n    LimitOrder = 'LIMIT_ORDER',\r\n    TakerOnly = 'TAKER_ONLY',\r\n    MakerOnly = 'MAKER_ONLY',\r\n    ClassAmm = 'class_amm'\r\n}\r\n\r\n/**\r\n * Submit order response detail\r\n * @export\r\n * @interface SubmitOrderResponseItemV3\r\n */\r\nexport interface SubmitOrderResponseItemV3 {\r\n    /**\r\n     * Order hash of submit order response\r\n     * @type {string}\r\n     * @memberof SubmitOrderResponseItemV3\r\n     */\r\n    hash: string;\r\n    /**\r\n     * The clientOrderId of the submitted order\r\n     * @type {string}\r\n     * @memberof SubmitOrderResponseItemV3\r\n     */\r\n    clientOrderId: string;\r\n    /**\r\n     * Order status of submit order response\r\n     * @type {string}\r\n     * @memberof SubmitOrderResponseItemV3\r\n     */\r\n    status: SubmitOrderResponseItemV3StatusEnum;\r\n    /**\r\n     * Idempotent of submit order response, submit same order again when order was UNKNOWN or WAIT_FREEZE_BALANCE in relayer, idempotent will be true\r\n     * @type {boolean}\r\n     * @memberof SubmitOrderResponseItemV3\r\n     */\r\n    isIdempotent: boolean;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum SubmitOrderResponseItemV3StatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Cancelling = 'cancelling',\r\n    Cancelled = 'cancelled',\r\n    Expired = 'expired',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * model.SubmitOrderResponseV2.description\r\n * @export\r\n * @interface SubmitOrderResponseV2\r\n */\r\nexport interface SubmitOrderResponseV2 {\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof SubmitOrderResponseV2\r\n     */\r\n    resultInfo: ResultInfo;\r\n    /**\r\n     * \r\n     * @type {SubmitOrderResponseV2Item}\r\n     * @memberof SubmitOrderResponseV2\r\n     */\r\n    data: SubmitOrderResponseV2Item;\r\n}\r\n/**\r\n * model.SubmitOrderResponseV2Item.description\r\n * @export\r\n * @interface SubmitOrderResponseV2Item\r\n */\r\nexport interface SubmitOrderResponseV2Item {\r\n    /**\r\n     * field.SubmitOrderResponseV2Item.orderHash\r\n     * @type {string}\r\n     * @memberof SubmitOrderResponseV2Item\r\n     */\r\n    orderHash: string;\r\n    /**\r\n     * field.SubmitOrderResponseV2Item.status\r\n     * @type {string}\r\n     * @memberof SubmitOrderResponseV2Item\r\n     */\r\n    status: SubmitOrderResponseV2ItemStatusEnum;\r\n    /**\r\n     * field.SubmitOrderResponseV2Item.isIdempotent\r\n     * @type {boolean}\r\n     * @memberof SubmitOrderResponseV2Item\r\n     */\r\n    isIdempotent: boolean;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum SubmitOrderResponseV2ItemStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Cancelling = 'cancelling',\r\n    Cancelled = 'cancelled',\r\n    Expired = 'expired',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * Single order submission results.\r\n * @export\r\n * @interface SubmitOrderResult\r\n */\r\nexport interface SubmitOrderResult {\r\n    /**\r\n     * Hash of order submitted\r\n     * @type {string}\r\n     * @memberof SubmitOrderResult\r\n     */\r\n    hash: string;\r\n    /**\r\n     * \r\n     * @type {ResultInfo}\r\n     * @memberof SubmitOrderResult\r\n     */\r\n    error?: ResultInfo;\r\n}\r\n/**\r\n * model.timestampV3.description\r\n * @export\r\n * @interface TimestampV3\r\n */\r\nexport interface TimestampV3 {\r\n    /**\r\n     * Current time in millisecond\r\n     * @type {number}\r\n     * @memberof TimestampV3\r\n     */\r\n    timestamp?: number;\r\n}\r\n/**\r\n * field.tokenInfo.description\r\n * @export\r\n * @interface TokenInfo\r\n */\r\nexport interface TokenInfo {\r\n    /**\r\n     * field.tokenInfo.type\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    type: TokenInfoTypeEnum;\r\n    /**\r\n     * field.tokenInfo.tokenId\r\n     * @type {number}\r\n     * @memberof TokenInfo\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * field.tokenInfo.symbol\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * field.tokenInfo.name\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    name: string;\r\n    /**\r\n     * field.tokenInfo.address\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    address: string;\r\n    /**\r\n     * field.tokenInfo.decimals\r\n     * @type {number}\r\n     * @memberof TokenInfo\r\n     */\r\n    decimals: number;\r\n    /**\r\n     * field.tokenInfo.precision\r\n     * @type {number}\r\n     * @memberof TokenInfo\r\n     */\r\n    precision: number;\r\n    /**\r\n     * field.tokenInfo.minOrderAmount\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    minOrderAmount: string;\r\n    /**\r\n     * field.tokenInfo.maxOrderAmount\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    maxOrderAmount: string;\r\n    /**\r\n     * field.tokenInfo.dustOrderAmount\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    dustOrderAmount: string;\r\n    /**\r\n     * field.tokenInfo.fastWithdrawLimit\r\n     * @type {string}\r\n     * @memberof TokenInfo\r\n     */\r\n    fastWithdrawLimit: string;\r\n    /**\r\n     * field.tokenInfo.enabled\r\n     * @type {boolean}\r\n     * @memberof TokenInfo\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum TokenInfoTypeEnum {\r\n    Erc20 = 'ERC20',\r\n    Eth = 'ETH'\r\n}\r\n\r\n/**\r\n * Token Detail\r\n * @export\r\n * @interface TokenInfoV3\r\n */\r\nexport interface TokenInfoV3 {\r\n    /**\r\n     * Token Type\r\n     * @type {string}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    type: TokenInfoV3TypeEnum;\r\n    /**\r\n     * Token\\'s numeric ID\r\n     * @type {number}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    tokenId: number;\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Token name\r\n     * @type {string}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    name: string;\r\n    /**\r\n     * Token ERC20 contract address\r\n     * @type {string}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    address: string;\r\n    /**\r\n     * Token decimals\r\n     * @type {number}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    decimals: number;\r\n    /**\r\n     * Max decimals that relayer uses for the token, smaller amount will be treated as zero.\r\n     * @type {number}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    precision: number;\r\n    /**\r\n     * \r\n     * @type {OrderAmountsV3}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    orderAmounts: OrderAmountsV3;\r\n    /**\r\n     * The maximum amount for single fast withdrawal\r\n     * @type {string}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    fastWithdrawLimit: string;\r\n    /**\r\n     * Whether the token is currently enabled for deposits and withdrawals.\r\n     * @type {boolean}\r\n     * @memberof TokenInfoV3\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum TokenInfoV3TypeEnum {\r\n    Erc20 = 'ERC20',\r\n    Eth = 'ETH'\r\n}\r\n\r\n/**\r\n * Wrapper object used to describe a token associated with a certain quantity.\r\n * @export\r\n * @interface TokenVolumeV3\r\n */\r\nexport interface TokenVolumeV3 {\r\n    /**\r\n     * The Loopring\\'s token identifier.\r\n     * @type {string}\r\n     * @memberof TokenVolumeV3\r\n     */\r\n    tokenId: string;\r\n    /**\r\n     * The volume of the token\r\n     * @type {string}\r\n     * @memberof TokenVolumeV3\r\n     */\r\n    volume: string;\r\n}\r\n/**\r\n * A list of trades\r\n * @export\r\n * @interface TradeList\r\n */\r\nexport interface TradeList {\r\n    /**\r\n     * Total number of tradings\r\n     * @type {number}\r\n     * @memberof TradeList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * field.marketTrades.trades\r\n     * @type {Array<Array<string>>}\r\n     * @memberof TradeList\r\n     */\r\n    trades: Array<Array<string>>;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface TransferData\r\n */\r\nexport interface TransferData {\r\n    /**\r\n     * Unique ID\r\n     * @type {number}\r\n     * @memberof TransferData\r\n     */\r\n    id: number;\r\n    /**\r\n     * hash\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    hash: string;\r\n    /**\r\n     * User transaction type\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    txType: string;\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Amount requested by the user\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    amount: string;\r\n    /**\r\n     * field.TxData.senderAddress\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    senderAddress?: string;\r\n    /**\r\n     * Receiver ID\r\n     * @type {number}\r\n     * @memberof TransferData\r\n     */\r\n    receiver?: number;\r\n    /**\r\n     * The transfer receiver\\'s address\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    receiverAddress?: string;\r\n    /**\r\n     * Fee amount in wei\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    feeAmount: string;\r\n    /**\r\n     * Current status\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    status: TransferDataStatusEnum;\r\n    /**\r\n     * Progress\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    progress: string;\r\n    /**\r\n     * Create time\r\n     * @type {number}\r\n     * @memberof TransferData\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Update time\r\n     * @type {number}\r\n     * @memberof TransferData\r\n     */\r\n    updatedAt: number;\r\n    /**\r\n     * field.TxData.memo\r\n     * @type {string}\r\n     * @memberof TransferData\r\n     */\r\n    memo?: string;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum TransferDataStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Received = 'received',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * model.TransferDataList.description\r\n * @export\r\n * @interface TransferDataList\r\n */\r\nexport interface TransferDataList {\r\n    /**\r\n     * Total number of records found\r\n     * @type {number}\r\n     * @memberof TransferDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * User\\'s transfer list\r\n     * @type {Array<TransferData>}\r\n     * @memberof TransferDataList\r\n     */\r\n    transactions: Array<TransferData>;\r\n}\r\n/**\r\n * model.UpdateAccountRequest.description\r\n * @export\r\n * @interface UpdateAccountRequest\r\n */\r\nexport interface UpdateAccountRequest {\r\n    /**\r\n     * field.UpdateAccountRequest.exchange\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * field.UpdateAccountRequest.owner\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    owner: string;\r\n    /**\r\n     * field.UpdateAccountRequest.accountId\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * field.UpdateAccountRequest.validUntil\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * field.UpdateAccountRequest.nonce\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    nonce: number;\r\n    /**\r\n     * field.UpdateAccountRequest.publicKeyX\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    publicKeyX: string;\r\n    /**\r\n     * field.UpdateAccountRequest.publicKeyY\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    publicKeyY: string;\r\n    /**\r\n     * field.UpdateAccountRequest.feeTokenId\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    feeToken: number;\r\n    /**\r\n     * field.UpdateAccountRequest.maxFee\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    maxFeeAmount: string;\r\n    /**\r\n     * field.UpdateAccountRequest.eddsaSig\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    eddsaSig?: string;\r\n    /**\r\n     * field.UpdateAccountRequest.ecdsaSig\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequest\r\n     */\r\n    ecdsaSig?: string;\r\n}\r\n/**\r\n * Params to update account EDDSA key\r\n * @export\r\n * @interface UpdateAccountRequestV3\r\n */\r\nexport interface UpdateAccountRequestV3 {\r\n    /**\r\n     * exchange address\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    exchange: string;\r\n    /**\r\n     * owner address\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    owner: string;\r\n    /**\r\n     * user account ID\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    accountId: number;\r\n    /**\r\n     * \r\n     * @type {PublicKey}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    publicKey: PublicKey;\r\n    /**\r\n     * \r\n     * @type {TokenVolumeV3}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    maxFee: TokenVolumeV3;\r\n    /**\r\n     * Timestamp for order to become invalid\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    validUntil: number;\r\n    /**\r\n     * Nonce of users exchange account that used in off-chain requests.\r\n     * @type {number}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    nonce: number;\r\n    /**\r\n     * eddsa signature of this request\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    eddsaSignature?: string;\r\n    /**\r\n     * ecdsa signature of this request\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    ecdsaSignature?: string;\r\n    /**\r\n     * An approved hash string which was submitted on eth mainnet\r\n     * @type {string}\r\n     * @memberof UpdateAccountRequestV3\r\n     */\r\n    hashApproved?: string;\r\n}\r\n/**\r\n * Response data\r\n * @export\r\n * @interface UserAccountTxData\r\n */\r\nexport interface UserAccountTxData {\r\n    /**\r\n     * Unique ID\r\n     * @type {number}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    id: number;\r\n    /**\r\n     * hash\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Owner address of the Tx\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    owner: string;\r\n    /**\r\n     * Transaction hash\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    txHash: string;\r\n    /**\r\n     * Fee amount in wei\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    feeAmount: string;\r\n    /**\r\n     * Current status\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    status: UserAccountTxDataStatusEnum;\r\n    /**\r\n     * Progress\r\n     * @type {string}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    progress: string;\r\n    /**\r\n     * Create time\r\n     * @type {number}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Block height\r\n     * @type {number}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    blockNum: number;\r\n    /**\r\n     * Update time\r\n     * @type {number}\r\n     * @memberof UserAccountTxData\r\n     */\r\n    updatedAt: number;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum UserAccountTxDataStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Received = 'received',\r\n    Failed = 'failed'\r\n}\r\n\r\n/**\r\n * UserChangePasswordDataList\r\n * @export\r\n * @interface UserAccountUpdateDataList\r\n */\r\nexport interface UserAccountUpdateDataList {\r\n    /**\r\n     * Total number of records found\r\n     * @type {number}\r\n     * @memberof UserAccountUpdateDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of UserPasswordChangeRecord\r\n     * @type {Array<UserAccountTxData>}\r\n     * @memberof UserAccountUpdateDataList\r\n     */\r\n    transactions: Array<UserAccountTxData>;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface UserBill\r\n */\r\nexport interface UserBill {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof UserBill\r\n     */\r\n    id: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    from: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    to: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    token: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    amount: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    tokenF: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    amountF: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    status: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    txHash: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    billType: string;\r\n    /**\r\n     * \r\n     * @type {boolean}\r\n     * @memberof UserBill\r\n     */\r\n    income: boolean;\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof UserBill\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    memo: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    price: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    transferType: string;\r\n    /**\r\n     * \r\n     * @type {string}\r\n     * @memberof UserBill\r\n     */\r\n    label: string;\r\n}\r\n/**\r\n * \r\n * @export\r\n * @interface UserBillList\r\n */\r\nexport interface UserBillList {\r\n    /**\r\n     * \r\n     * @type {number}\r\n     * @memberof UserBillList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * \r\n     * @type {Array<UserBill>}\r\n     * @memberof UserBillList\r\n     */\r\n    bills: Array<UserBill>;\r\n}\r\n/**\r\n * UserCreateDataList\r\n * @export\r\n * @interface UserCreateDataList\r\n */\r\nexport interface UserCreateDataList {\r\n    /**\r\n     * Total number of records found\r\n     * @type {number}\r\n     * @memberof UserCreateDataList\r\n     */\r\n    totalNum: number;\r\n    /**\r\n     * List of UserRegistrationRecord\r\n     * @type {Array<UserAccountTxData>}\r\n     * @memberof UserCreateDataList\r\n     */\r\n    transactions: Array<UserAccountTxData>;\r\n}\r\n/**\r\n * Response data\r\n * @export\r\n * @interface WithdrawalData\r\n */\r\nexport interface WithdrawalData {\r\n    /**\r\n     * Unique ID\r\n     * @type {number}\r\n     * @memberof WithdrawalData\r\n     */\r\n    id: number;\r\n    /**\r\n     * User transaction type\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    txType: string;\r\n    /**\r\n     * hash\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    hash: string;\r\n    /**\r\n     * Token symbol\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    symbol: string;\r\n    /**\r\n     * Amount requested by the user\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    amount: string;\r\n    /**\r\n     * Transaction hash\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    txHash: string;\r\n    /**\r\n     * Fee amount in wei\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    feeAmount: string;\r\n    /**\r\n     * Current status\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    status: WithdrawalDataStatusEnum;\r\n    /**\r\n     * Progress\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    progress: string;\r\n    /**\r\n     * Create time\r\n     * @type {number}\r\n     * @memberof WithdrawalData\r\n     */\r\n    timestamp: number;\r\n    /**\r\n     * Block height\r\n     * @type {number}\r\n     * @memberof WithdrawalData\r\n     */\r\n    blockNum: number;\r\n    /**\r\n     * Update time\r\n     * @type {number}\r\n     * @memberof WithdrawalData\r\n     */\r\n    updatedAt: number;\r\n    /**\r\n     * Distribute Hash\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    distributeHash: string;\r\n    /**\r\n     * Request Id\r\n     * @type {number}\r\n     * @memberof WithdrawalData\r\n     */\r\n    requestId?: number;\r\n    /**\r\n     * Fast withdrawal status\r\n     * @type {string}\r\n     * @memberof WithdrawalData\r\n     */\r\n    fastStatus?: WithdrawalDataFastStatusEnum;\r\n}\r\n\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum WithdrawalDataStatusEnum {\r\n    Processing = 'processing',\r\n    Processed = 'processed',\r\n    Received = 'received',\r\n    Failed = 'failed'\r\n}\r\n/**\r\n    * @export\r\n    * @enum {string}\r\n    */\r\nexport enum WithdrawalDataFastStatusEnum {\r\n    Empty = 'EMPTY',\r\n    Proceeing = 'PROCEEING',\r\n    Successed = 'SUCCESSED',\r\n    Failed = 'FAILED'\r\n}\r\n\r\n\r\n/**\r\n * AuthApiKeyApi - axios parameter creator\r\n * @export\r\n */\r\nexport const AuthApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward: async (accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionReward`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n            if (taker !== undefined) {\r\n                localVarQueryParameter['taker'] = taker;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome: async (address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/financeIncome`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (address !== undefined) {\r\n                localVarQueryParameter['address'] = address;\r\n            }\r\n\r\n            if (financeType !== undefined) {\r\n                localVarQueryParameter['financeType'] = financeType;\r\n            }\r\n\r\n            if (tokenAddress !== undefined) {\r\n                localVarQueryParameter['tokenAddress'] = tokenAddress;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards: async (accountId?: number, market?: string, timestamp?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMining`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (timestamp !== undefined) {\r\n                localVarQueryParameter['timestamp'] = timestamp;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId: async (accountId: number, sellTokenId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'accountId', accountId)\r\n            // verify required parameter 'sellTokenId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'sellTokenId', sellTokenId)\r\n            const localVarPath = `/api/v3/storageId`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (sellTokenId !== undefined) {\r\n                localVarQueryParameter['sellTokenId'] = sellTokenId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail: async (accountId: number, orderHash: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'accountId', accountId)\r\n            // verify required parameter 'orderHash' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'orderHash', orderHash)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders: async (accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrders', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/orders`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (side !== undefined) {\r\n                localVarQueryParameter['side'] = side;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (orderTypes !== undefined) {\r\n                localVarQueryParameter['orderTypes'] = orderTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances: async (accountId: number, tokens?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserBalances', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokens !== undefined) {\r\n                localVarQueryParameter['tokens'] = tokens;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill: async (accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/bills`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserCreate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/createInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserDeposits', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/deposits`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates: async (accountId: number, markets: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'accountId', accountId)\r\n            // verify required parameter 'markets' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'markets', markets)\r\n            const localVarPath = `/api/v3/user/feeRates`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (markets !== undefined) {\r\n                localVarQueryParameter['markets'] = markets;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades: async (accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTrades', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (fromId !== undefined) {\r\n                localVarQueryParameter['fromId'] = fromId;\r\n            }\r\n\r\n            if (fillTypes !== undefined) {\r\n                localVarQueryParameter['fillTypes'] = fillTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTransfers', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/transfers`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (transferTypes !== undefined) {\r\n                localVarQueryParameter['transferTypes'] = transferTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserUpdate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/updateInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserWithdrawals', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (withdrawalTypes !== undefined) {\r\n                localVarQueryParameter['withdrawalTypes'] = withdrawalTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthApiKeyApi - functional programming interface\r\n * @export\r\n */\r\nexport const AuthApiKeyApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = AuthApiKeyApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionTotalReward(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionTotalReward(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewardTotal(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewardTotal(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewards(accountId, market, timestamp, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getNextStorageId(accountId: number, sellTokenId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextStorageId(accountId, sellTokenId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrderDetail(accountId: number, orderHash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderDetail(accountId, orderHash, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBalances(accountId: number, tokens?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBalances(accountId, tokens, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserFeeRates(accountId: number, markets: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFeeRates(accountId, markets, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUpdate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthApiKeyApi - factory interface\r\n * @export\r\n */\r\nexport const AuthApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = AuthApiKeyApiFp(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionTotalReward(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewardTotal(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId(accountId: number, sellTokenId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getNextStorageId(accountId, sellTokenId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail(accountId: number, orderHash: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrderDetail(accountId, orderHash, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances(accountId: number, tokens?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBalances(accountId, tokens, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates(accountId: number, markets: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserFeeRates(accountId, markets, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * AuthApiKeyApi - object-oriented interface\r\n * @export\r\n * @class AuthApiKeyApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class AuthApiKeyApi extends BaseAPI {\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {number} [tokenId] \r\n     * @param {number} [start] \r\n     * @param {number} [size] \r\n     * @param {number} [rewardType] \r\n     * @param {number} [taker] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getCommissionTotalReward(accountId?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getCommissionTotalReward(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [address] \r\n     * @param {string} [financeType] \r\n     * @param {string} [tokenAddress] \r\n     * @param {number} [offset] \r\n     * @param {number} [limit] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getLiquidityMiningRewardTotal(accountId?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getLiquidityMiningRewardTotal(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [market] \r\n     * @param {number} [timestamp] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n     * @summary Get next storage ID\r\n     * @param {number} accountId Looprings account identifier\r\n     * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getNextStorageId(accountId: number, sellTokenId: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getNextStorageId(accountId, sellTokenId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the details of an order based on order hash.\r\n     * @summary Get order details\r\n     * @param {number} accountId Account ID\r\n     * @param {string} orderHash Order hash\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getOrderDetail(accountId: number, orderHash: string, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getOrderDetail(accountId, orderHash, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get a list of orders satisfying certain criteria.\r\n     * @summary Get multiple orders\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n     * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n     * @param {number} [limit] Limit of orders (default 50)\r\n     * @param {number} [offset] Offset of orders (default 0)\r\n     * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether and token balances on exchange.\r\n     * @summary Get user exchange balances\r\n     * @param {number} accountId AccountID\r\n     * @param {string} [tokens] Query tokens\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserBalances(accountId: number, tokens?: string, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserBalances(accountId, tokens, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [billType] \r\n     * @param {number} [start] \r\n     * @param {number} [end] \r\n     * @param {number} [limit] \r\n     * @param {number} [offset] \r\n     * @param {number} [tokenId] \r\n     * @param {boolean} [income] \r\n     * @param {string} [transferAddress] \r\n     * @param {string} [fromAddress] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for exchange account registration.\r\n     * @summary Get user registration transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list of deposit records for the given user.\r\n     * @summary Get user deposit history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the fee rate of users placing orders in specific markets\r\n     * @summary Query user place order fee rate\r\n     * @param {number} accountId Account ID\r\n     * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserFeeRates(accountId: number, markets: string, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserFeeRates(accountId, markets, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user trade history.\r\n     * @summary Get user trade history\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {string} [orderHash] Order hash\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [fromId] The begin id of the query.\r\n     * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user transfer list.\r\n     * @summary Get user transfer list\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n     * @summary Get password reset transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user onchain withdrawal history.\r\n     * @summary Get user onchain withdrawal history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthApiKeyApi\r\n     */\r\n    public getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any) {\r\n        return AuthApiKeyApiFp(this.configuration).getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * AuthHasEcdsaSigApi - axios parameter creator\r\n * @export\r\n */\r\nexport const AuthHasEcdsaSigApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal: async (body: OffChainWithdrawalRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOffChainWithdrawal', 'body', body)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer: async (body: OriginTransferRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitTransfer', 'body', body)\r\n            const localVarPath = `/api/v3/transfer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount: async (body: UpdateAccountRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitUpdateAccount', 'body', body)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthHasEcdsaSigApi - functional programming interface\r\n * @export\r\n */\r\nexport const AuthHasEcdsaSigApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = AuthHasEcdsaSigApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOffChainWithdrawal(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitTransfer(body: OriginTransferRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransfer(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUpdateAccount(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthHasEcdsaSigApi - factory interface\r\n * @export\r\n */\r\nexport const AuthHasEcdsaSigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = AuthHasEcdsaSigApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOffChainWithdrawal(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer(body: OriginTransferRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitTransfer(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitUpdateAccount(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * AuthHasEcdsaSigApi - object-oriented interface\r\n * @export\r\n * @class AuthHasEcdsaSigApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class AuthHasEcdsaSigApi extends BaseAPI {\r\n    /**\r\n     * Submit offchain withdraw request\r\n     * @summary Submit offchain withdraw request\r\n     * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEcdsaSigApi\r\n     */\r\n    public submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any) {\r\n        return AuthHasEcdsaSigApiFp(this.configuration).submitOffChainWithdrawal(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit internal transfer\r\n     * @summary Submit internal transfer\r\n     * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEcdsaSigApi\r\n     */\r\n    public submitTransfer(body: OriginTransferRequestV3, options?: any) {\r\n        return AuthHasEcdsaSigApiFp(this.configuration).submitTransfer(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n     * @summary Update account EDDSA key\r\n     * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEcdsaSigApi\r\n     */\r\n    public submitUpdateAccount(body: UpdateAccountRequestV3, options?: any) {\r\n        return AuthHasEcdsaSigApiFp(this.configuration).submitUpdateAccount(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * AuthHasEddsaSigApi - axios parameter creator\r\n * @export\r\n */\r\nexport const AuthHasEddsaSigApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey: async (body: GetApiKeyRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('applyApiKey', 'body', body)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder: async (accountId: number, orderHash?: string, clientOrderId?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('cancelOrder', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (clientOrderId !== undefined) {\r\n                localVarQueryParameter['clientOrderId'] = clientOrderId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey: async (accountId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getApiKey', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/refer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit: async (body: AmmPoolExitRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolExit', 'body', body)\r\n            const localVarPath = `/api/v3/amm/exit`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin: async (body: AmmPoolJoinRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolJoin', 'body', body)\r\n            const localVarPath = `/api/v3/amm/join`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal: async (body: OffChainWithdrawalRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOffChainWithdrawal', 'body', body)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3: async (body: SubmitOrderRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOrderV3', 'body', body)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer: async (body: OriginTransferRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitTransfer', 'body', body)\r\n            const localVarPath = `/api/v3/transfer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount: async (body: UpdateAccountRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitUpdateAccount', 'body', body)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthHasEddsaSigApi - functional programming interface\r\n * @export\r\n */\r\nexport const AuthHasEddsaSigApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = AuthHasEddsaSigApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async applyApiKey(body: GetApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.applyApiKey(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(accountId, orderHash, clientOrderId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getApiKey(accountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async setReferrer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.setReferrer(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolExit(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolJoin(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOffChainWithdrawal(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOrderV3(body: SubmitOrderRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOrderV3(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitTransfer(body: OriginTransferRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransfer(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUpdateAccount(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthHasEddsaSigApi - factory interface\r\n * @export\r\n */\r\nexport const AuthHasEddsaSigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = AuthHasEddsaSigApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey(body: GetApiKeyRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.applyApiKey(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey(accountId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getApiKey(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer(options?: any): AxiosPromise<any> {\r\n            return localVarFp.setReferrer(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolExit(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolJoin(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOffChainWithdrawal(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3(body: SubmitOrderRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOrderV3(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer(body: OriginTransferRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitTransfer(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitUpdateAccount(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * AuthHasEddsaSigApi - object-oriented interface\r\n * @export\r\n * @class AuthHasEddsaSigApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class AuthHasEddsaSigApi extends BaseAPI {\r\n    /**\r\n     * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n     * @summary Update user\\'s ApiKey\r\n     * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public applyApiKey(body: GetApiKeyRequest, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).applyApiKey(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Cancel order using order hash or client-side ID.\r\n     * @summary Cancel order\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [orderHash] Order HASH\r\n     * @param {string} [clientOrderId] The unique order ID of the client\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the ApiKey associated with the user\\'s account.\r\n     * @summary Get user ApiKey\r\n     * @param {number} accountId AccountID\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public getApiKey(accountId: number, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).getApiKey(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public setReferrer(options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).setReferrer(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the exit request processing status\r\n     * @summary Exit an AMM pool\r\n     * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitAmmPoolExit(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the join request processing status\r\n     * @summary Join into AMM pool\r\n     * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitAmmPoolJoin(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit offchain withdraw request\r\n     * @summary Submit offchain withdraw request\r\n     * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitOffChainWithdrawal(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit an order\r\n     * @summary Submit an order\r\n     * @param {SubmitOrderRequestV3} body Submit order message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitOrderV3(body: SubmitOrderRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitOrderV3(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit internal transfer\r\n     * @summary Submit internal transfer\r\n     * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitTransfer(body: OriginTransferRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitTransfer(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n     * @summary Update account EDDSA key\r\n     * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthHasEddsaSigApi\r\n     */\r\n    public submitUpdateAccount(body: UpdateAccountRequestV3, options?: any) {\r\n        return AuthHasEddsaSigApiFp(this.configuration).submitUpdateAccount(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * AuthNoKeyApi - axios parameter creator\r\n * @export\r\n */\r\nexport const AuthNoKeyApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite: async (site?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/crawl`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (site !== undefined) {\r\n                localVarQueryParameter['site'] = site;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAccount', 'owner', owner)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAllowance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getAllowance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/allowances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance: async (poolAddress: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmPoolBalance', 'poolAddress', poolAddress)\r\n            const localVarPath = `/api/v3/amm/balance`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/pools`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades: async (ammPoolAddress: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'ammPoolAddress' is not null or undefined\r\n            assertParamExists('getAmmTrades', 'ammPoolAddress', ammPoolAddress)\r\n            const localVarPath = `/api/v3/amm/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (ammPoolAddress !== undefined) {\r\n                localVarQueryParameter['ammPoolAddress'] = ammPoolAddress;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions: async (poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'poolAddress', poolAddress)\r\n            // verify required parameter 'billType' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'billType', billType)\r\n            const localVarPath = `/api/v3/amm/transactions`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick: async (market: string, interval: string, start?: number, end?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getCandlestick', 'market', market)\r\n            // verify required parameter 'interval' is not null or undefined\r\n            assertParamExists('getCandlestick', 'interval', interval)\r\n            const localVarPath = `/api/v3/candlestick`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (interval !== undefined) {\r\n                localVarQueryParameter['interval'] = interval;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank: async (tokenId?: number, top?: number, rewardType?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth: async (market: string, level: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getDepth', 'market', market)\r\n            // verify required parameter 'level' is not null or undefined\r\n            assertParamExists('getDepth', 'level', level)\r\n            const localVarPath = `/api/v3/depth`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (level !== undefined) {\r\n                localVarQueryParameter['level'] = level;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthBalance', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthNonce', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/nonce`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/info`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf: async (market?: string, running?: boolean, pageIndex?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningConf`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (running !== undefined) {\r\n                localVarQueryParameter['running'] = running;\r\n            }\r\n\r\n            if (pageIndex !== undefined) {\r\n                localVarQueryParameter['pageIndex'] = pageIndex;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank: async (market?: string, top?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade: async (market: string, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getMarketTrade', 'market', market)\r\n            const localVarPath = `/api/v3/trade`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/markets`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice: async (legal: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'legal' is not null or undefined\r\n            assertParamExists('getPrice', 'legal', legal)\r\n            const localVarPath = `/api/v3/price`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (legal !== undefined) {\r\n                localVarQueryParameter['legal'] = legal;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/eth/recommendedGasPrice`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker: async (market: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getTicker', 'market', market)\r\n            const localVarPath = `/api/v3/ticker`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/timestamp`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/tokenBalances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/tokens`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents: async (tokenId?: number, amount?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/withdrawalAgents`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (amount !== undefined) {\r\n                localVarQueryParameter['amount'] = amount;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction: async (body: ForwardEthTxRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('sendTransaction', 'body', body)\r\n            const localVarPath = `/api/v3/eth/sendTx`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthNoKeyApi - functional programming interface\r\n * @export\r\n */\r\nexport const AuthNoKeyApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = AuthNoKeyApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async crawlSite(site?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlSite(site, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAccount(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAllowance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllowance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolBalance(poolAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolBalance(poolAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPools(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPools(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolsBalances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolsBalances(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTrades(ammPoolAddress, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestick(market, interval, start, end, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRewardRank(tokenId, top, rewardType, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getDepth(market: string, level: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepth(market, level, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthBalance(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthBalance(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthNonce(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthNonce(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getExchangeInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningConf(market, running, pageIndex, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRank(market?: string, top?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRank(market, top, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarketTrade(market: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketTrade(market, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarkets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkets(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getPrice(legal: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrice(legal, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getRecommendedGasPrice(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedGasPrice(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTicker(market: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(market, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTimestamp(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimestamp(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokenBalance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBalance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawalAgents(tokenId, amount, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async sendTransaction(body: ForwardEthTxRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTransaction(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * AuthNoKeyApi - factory interface\r\n * @export\r\n */\r\nexport const AuthNoKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = AuthNoKeyApiFp(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite(site?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.crawlSite(site, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAccount(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAllowance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance(poolAddress: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolBalance(poolAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPools(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolsBalances(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCandlestick(market, interval, start, end, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth(market: string, level: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getDepth(market, level, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthBalance(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthNonce(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getExchangeInfo(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank(market?: string, top?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRank(market, top, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade(market: string, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarketTrade(market, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarkets(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice(legal: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getPrice(legal, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getRecommendedGasPrice(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker(market: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTicker(market, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTimestamp(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokenBalance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokens(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getWithdrawalAgents(tokenId, amount, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction(body: ForwardEthTxRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.sendTransaction(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * AuthNoKeyApi - object-oriented interface\r\n * @export\r\n * @class AuthNoKeyApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class AuthNoKeyApi extends BaseAPI {\r\n    /**\r\n     * \r\n     * @param {string} [site] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public crawlSite(site?: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).crawlSite(site, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns data associated with the user\\'s exchange account.\r\n     * @summary Query user information\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAccount(owner: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAccount(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n     * @summary Get user token allowance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token The token address to query\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAllowance(owner: string, token: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAllowance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the snapshot of specific AMM pool\r\n     * @summary Get AMM pool balance snapshot\r\n     * @param {string} poolAddress input AMM pool address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAmmPoolBalance(poolAddress: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAmmPoolBalance(poolAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported AMM pools\r\n     * @summary Get AMM pool configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAmmPools(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAmmPools(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getAmmPoolsBalances.notes\r\n     * @summary api.getAmmPoolsBalances.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAmmPoolsBalances(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAmmPoolsBalances(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * get AMM pool trade transactions\r\n     * @summary get AMM pool trade transactions\r\n     * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the AMM join/exit transactions\r\n     * @summary get AMM involved join/exit transactions\r\n     * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n     * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n     * @param {number} [start] Date from which to start fetching AMM transactions.\r\n     * @param {number} [end] End Date of the query\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {number} [tokenId] A unique token identifier\r\n     * @param {boolean} [income] transfer in or out\r\n     * @param {string} [transferAddress] transfer to address\r\n     * @param {string} [fromAddress] transfer from address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the candlestick data of a given trading pair.\r\n     * @summary Get market candlestick\r\n     * @param {string} market Trading pair ID, multi-market is not supported\r\n     * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n     * @param {number} [start] Start time\r\n     * @param {number} [end] End time\r\n     * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getCandlestick(market, interval, start, end, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [tokenId] \r\n     * @param {number} [top] \r\n     * @param {number} [rewardType] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the order book of a given trading pair.\r\n     * @summary Get market orderbook\r\n     * @param {string} market The ID of a trading pair.\r\n     * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n     * @param {number} [limit] Maximum numbers of bids/asks.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getDepth(market: string, level: number, limit?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getDepth(market, level, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n     * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getEthBalance(owner: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getEthBalance(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n     * @summary Get user\\'s next Ethereum nonce\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getEthNonce(owner: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getEthNonce(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return various configurations of Loopring.io\r\n     * @summary Get exchange configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getExchangeInfo(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getExchangeInfo(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {boolean} [running] \r\n     * @param {number} [pageIndex] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {number} [top] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getLiquidityMiningRank(market?: string, top?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getLiquidityMiningRank(market, top, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Query trades with specified market\r\n     * @summary Get market recent trades\r\n     * @param {string} market Single market to query\r\n     * @param {number} [limit] Number of queries\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getMarketTrade(market: string, limit?: number, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getMarketTrade(market, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported markets (trading pairs)\r\n     * @summary Get market configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getMarkets(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getMarkets(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n     * @summary Get token fiat prices\r\n     * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getPrice(legal: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getPrice(legal, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get recommended gas price in Gwei.\r\n     * @summary Get recommended gas price\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getRecommendedGasPrice(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getRecommendedGasPrice(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n     * @summary Get market ticker\r\n     * @param {string} market Market pair, support multiple markets\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getTicker(market: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getTicker(market, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the relayer\\'s current time in millisecond\r\n     * @summary Get relayer\\'s current time\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getTimestamp(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getTimestamp(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n     * @summary Get user token balance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token Token\\&#39;s ERC20 address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getTokenBalance(owner: string, token: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getTokenBalance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported tokens, including Ether.\r\n     * @summary Get token configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getTokens(options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getWithdrawalAgents.notes\r\n     * @summary api.getWithdrawalAgents.value\r\n     * @param {number} [tokenId] \r\n     * @param {string} [amount] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public getWithdrawalAgents(tokenId?: number, amount?: string, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).getWithdrawalAgents(tokenId, amount, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n     * @summary Send a raw Ethereum transaction\r\n     * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof AuthNoKeyApi\r\n     */\r\n    public sendTransaction(body: ForwardEthTxRequest, options?: any) {\r\n        return AuthNoKeyApiFp(this.configuration).sendTransaction(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ClassAmmApi - axios parameter creator\r\n * @export\r\n */\r\nexport const ClassAmmApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance: async (poolAddress: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmPoolBalance', 'poolAddress', poolAddress)\r\n            const localVarPath = `/api/v3/amm/balance`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades: async (ammPoolAddress: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'ammPoolAddress' is not null or undefined\r\n            assertParamExists('getAmmTrades', 'ammPoolAddress', ammPoolAddress)\r\n            const localVarPath = `/api/v3/amm/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (ammPoolAddress !== undefined) {\r\n                localVarQueryParameter['ammPoolAddress'] = ammPoolAddress;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions: async (poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'poolAddress', poolAddress)\r\n            // verify required parameter 'billType' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'billType', billType)\r\n            const localVarPath = `/api/v3/amm/transactions`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmUserTransactions: async (accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/user/transactions`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (txTypes !== undefined) {\r\n                localVarQueryParameter['txTypes'] = txTypes;\r\n            }\r\n\r\n            if (txStatus !== undefined) {\r\n                localVarQueryParameter['txStatus'] = txStatus;\r\n            }\r\n\r\n            if (ammPoolAddress !== undefined) {\r\n                localVarQueryParameter['ammPoolAddress'] = ammPoolAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit: async (body: AmmPoolExitRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolExit', 'body', body)\r\n            const localVarPath = `/api/v3/amm/exit`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin: async (body: AmmPoolJoinRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolJoin', 'body', body)\r\n            const localVarPath = `/api/v3/amm/join`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassAmmApi - functional programming interface\r\n * @export\r\n */\r\nexport const ClassAmmApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = ClassAmmApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolBalance(poolAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolBalance(poolAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolsBalances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolsBalances(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTrades(ammPoolAddress, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolExit(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolJoin(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassAmmApi - factory interface\r\n * @export\r\n */\r\nexport const ClassAmmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = ClassAmmApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance(poolAddress: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolBalance(poolAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolsBalances(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolExit(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolJoin(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * ClassAmmApi - object-oriented interface\r\n * @export\r\n * @class ClassAmmApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class ClassAmmApi extends BaseAPI {\r\n    /**\r\n     * Returns the snapshot of specific AMM pool\r\n     * @summary Get AMM pool balance snapshot\r\n     * @param {string} poolAddress input AMM pool address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public getAmmPoolBalance(poolAddress: string, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).getAmmPoolBalance(poolAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getAmmPoolsBalances.notes\r\n     * @summary api.getAmmPoolsBalances.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public getAmmPoolsBalances(options?: any) {\r\n        return ClassAmmApiFp(this.configuration).getAmmPoolsBalances(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * get AMM pool trade transactions\r\n     * @summary get AMM pool trade transactions\r\n     * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the AMM join/exit transactions\r\n     * @summary get AMM involved join/exit transactions\r\n     * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n     * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n     * @param {number} [start] Date from which to start fetching AMM transactions.\r\n     * @param {number} [end] End Date of the query\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {number} [tokenId] A unique token identifier\r\n     * @param {boolean} [income] transfer in or out\r\n     * @param {string} [transferAddress] transfer to address\r\n     * @param {string} [fromAddress] transfer from address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the user\\'s AMM join/exit transactions\r\n     * @summary User\\'s AMM join/exit transactions\r\n     * @param {number} [accountId] Looprings account identifier.\r\n     * @param {number} [start] Date from which to start fetching AMM transactions.\r\n     * @param {number} [end] End Date of the query\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {string} [txTypes] Transaction type: join or exit\r\n     * @param {string} [txStatus] The AMM transaction status.\r\n     * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the exit request processing status\r\n     * @summary Exit an AMM pool\r\n     * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).submitAmmPoolExit(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the join request processing status\r\n     * @summary Join into AMM pool\r\n     * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassAmmApi\r\n     */\r\n    public submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any) {\r\n        return ClassAmmApiFp(this.configuration).submitAmmPoolJoin(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ClassEthApi - axios parameter creator\r\n * @export\r\n */\r\nexport const ClassEthApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAllowance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getAllowance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/allowances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthBalance', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthNonce', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/nonce`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/eth/recommendedGasPrice`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/tokenBalances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction: async (body: ForwardEthTxRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('sendTransaction', 'body', body)\r\n            const localVarPath = `/api/v3/eth/sendTx`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassEthApi - functional programming interface\r\n * @export\r\n */\r\nexport const ClassEthApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = ClassEthApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAllowance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllowance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthBalance(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthBalance(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthNonce(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthNonce(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getRecommendedGasPrice(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedGasPrice(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokenBalance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBalance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async sendTransaction(body: ForwardEthTxRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTransaction(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassEthApi - factory interface\r\n * @export\r\n */\r\nexport const ClassEthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = ClassEthApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAllowance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthBalance(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthNonce(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getRecommendedGasPrice(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokenBalance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction(body: ForwardEthTxRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.sendTransaction(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * ClassEthApi - object-oriented interface\r\n * @export\r\n * @class ClassEthApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class ClassEthApi extends BaseAPI {\r\n    /**\r\n     * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n     * @summary Get user token allowance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token The token address to query\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public getAllowance(owner: string, token: string, options?: any) {\r\n        return ClassEthApiFp(this.configuration).getAllowance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n     * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public getEthBalance(owner: string, options?: any) {\r\n        return ClassEthApiFp(this.configuration).getEthBalance(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n     * @summary Get user\\'s next Ethereum nonce\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public getEthNonce(owner: string, options?: any) {\r\n        return ClassEthApiFp(this.configuration).getEthNonce(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get recommended gas price in Gwei.\r\n     * @summary Get recommended gas price\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public getRecommendedGasPrice(options?: any) {\r\n        return ClassEthApiFp(this.configuration).getRecommendedGasPrice(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n     * @summary Get user token balance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token Token\\&#39;s ERC20 address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public getTokenBalance(owner: string, token: string, options?: any) {\r\n        return ClassEthApiFp(this.configuration).getTokenBalance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n     * @summary Send a raw Ethereum transaction\r\n     * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassEthApi\r\n     */\r\n    public sendTransaction(body: ForwardEthTxRequest, options?: any) {\r\n        return ClassEthApiFp(this.configuration).sendTransaction(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ClassExchangeApi - axios parameter creator\r\n * @export\r\n */\r\nexport const ClassExchangeApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite: async (site?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/crawl`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (site !== undefined) {\r\n                localVarQueryParameter['site'] = site;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAccount', 'owner', owner)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/pools`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick: async (market: string, interval: string, start?: number, end?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getCandlestick', 'market', market)\r\n            // verify required parameter 'interval' is not null or undefined\r\n            assertParamExists('getCandlestick', 'interval', interval)\r\n            const localVarPath = `/api/v3/candlestick`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (interval !== undefined) {\r\n                localVarQueryParameter['interval'] = interval;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank: async (tokenId?: number, top?: number, rewardType?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth: async (market: string, level: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getDepth', 'market', market)\r\n            // verify required parameter 'level' is not null or undefined\r\n            assertParamExists('getDepth', 'level', level)\r\n            const localVarPath = `/api/v3/depth`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (level !== undefined) {\r\n                localVarQueryParameter['level'] = level;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/info`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf: async (market?: string, running?: boolean, pageIndex?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningConf`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (running !== undefined) {\r\n                localVarQueryParameter['running'] = running;\r\n            }\r\n\r\n            if (pageIndex !== undefined) {\r\n                localVarQueryParameter['pageIndex'] = pageIndex;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank: async (market?: string, top?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade: async (market: string, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getMarketTrade', 'market', market)\r\n            const localVarPath = `/api/v3/trade`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/markets`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice: async (legal: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'legal' is not null or undefined\r\n            assertParamExists('getPrice', 'legal', legal)\r\n            const localVarPath = `/api/v3/price`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (legal !== undefined) {\r\n                localVarQueryParameter['legal'] = legal;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker: async (market: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getTicker', 'market', market)\r\n            const localVarPath = `/api/v3/ticker`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/timestamp`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/tokens`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents: async (tokenId?: number, amount?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/withdrawalAgents`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (amount !== undefined) {\r\n                localVarQueryParameter['amount'] = amount;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassExchangeApi - functional programming interface\r\n * @export\r\n */\r\nexport const ClassExchangeApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = ClassExchangeApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async crawlSite(site?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlSite(site, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAccount(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPools(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPools(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestick(market, interval, start, end, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRewardRank(tokenId, top, rewardType, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getDepth(market: string, level: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepth(market, level, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getExchangeInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningConf(market, running, pageIndex, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRank(market?: string, top?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRank(market, top, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarketTrade(market: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketTrade(market, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarkets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkets(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getPrice(legal: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrice(legal, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTicker(market: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(market, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTimestamp(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimestamp(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawalAgents(tokenId, amount, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassExchangeApi - factory interface\r\n * @export\r\n */\r\nexport const ClassExchangeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = ClassExchangeApiFp(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite(site?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.crawlSite(site, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAccount(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPools(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCandlestick(market, interval, start, end, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth(market: string, level: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getDepth(market, level, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getExchangeInfo(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank(market?: string, top?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRank(market, top, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade(market: string, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarketTrade(market, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarkets(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice(legal: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getPrice(legal, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker(market: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTicker(market, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTimestamp(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokens(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getWithdrawalAgents(tokenId, amount, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * ClassExchangeApi - object-oriented interface\r\n * @export\r\n * @class ClassExchangeApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class ClassExchangeApi extends BaseAPI {\r\n    /**\r\n     * \r\n     * @param {string} [site] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public crawlSite(site?: string, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).crawlSite(site, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns data associated with the user\\'s exchange account.\r\n     * @summary Query user information\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getAccount(owner: string, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getAccount(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported AMM pools\r\n     * @summary Get AMM pool configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getAmmPools(options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getAmmPools(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the candlestick data of a given trading pair.\r\n     * @summary Get market candlestick\r\n     * @param {string} market Trading pair ID, multi-market is not supported\r\n     * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n     * @param {number} [start] Start time\r\n     * @param {number} [end] End time\r\n     * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getCandlestick(market, interval, start, end, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [tokenId] \r\n     * @param {number} [top] \r\n     * @param {number} [rewardType] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the order book of a given trading pair.\r\n     * @summary Get market orderbook\r\n     * @param {string} market The ID of a trading pair.\r\n     * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n     * @param {number} [limit] Maximum numbers of bids/asks.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getDepth(market: string, level: number, limit?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getDepth(market, level, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return various configurations of Loopring.io\r\n     * @summary Get exchange configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getExchangeInfo(options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getExchangeInfo(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {boolean} [running] \r\n     * @param {number} [pageIndex] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {number} [top] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getLiquidityMiningRank(market?: string, top?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getLiquidityMiningRank(market, top, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Query trades with specified market\r\n     * @summary Get market recent trades\r\n     * @param {string} market Single market to query\r\n     * @param {number} [limit] Number of queries\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getMarketTrade(market: string, limit?: number, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getMarketTrade(market, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported markets (trading pairs)\r\n     * @summary Get market configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getMarkets(options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getMarkets(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n     * @summary Get token fiat prices\r\n     * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getPrice(legal: string, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getPrice(legal, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n     * @summary Get market ticker\r\n     * @param {string} market Market pair, support multiple markets\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getTicker(market: string, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getTicker(market, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the relayer\\'s current time in millisecond\r\n     * @summary Get relayer\\'s current time\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getTimestamp(options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getTimestamp(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported tokens, including Ether.\r\n     * @summary Get token configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getTokens(options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getWithdrawalAgents.notes\r\n     * @summary api.getWithdrawalAgents.value\r\n     * @param {number} [tokenId] \r\n     * @param {string} [amount] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassExchangeApi\r\n     */\r\n    public getWithdrawalAgents(tokenId?: number, amount?: string, options?: any) {\r\n        return ClassExchangeApiFp(this.configuration).getWithdrawalAgents(tokenId, amount, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ClassUserApi - axios parameter creator\r\n * @export\r\n */\r\nexport const ClassUserApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey: async (body: GetApiKeyRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('applyApiKey', 'body', body)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder: async (accountId: number, orderHash?: string, clientOrderId?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('cancelOrder', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (clientOrderId !== undefined) {\r\n                localVarQueryParameter['clientOrderId'] = clientOrderId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey: async (accountId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getApiKey', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward: async (accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionReward`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n            if (taker !== undefined) {\r\n                localVarQueryParameter['taker'] = taker;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome: async (address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/financeIncome`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (address !== undefined) {\r\n                localVarQueryParameter['address'] = address;\r\n            }\r\n\r\n            if (financeType !== undefined) {\r\n                localVarQueryParameter['financeType'] = financeType;\r\n            }\r\n\r\n            if (tokenAddress !== undefined) {\r\n                localVarQueryParameter['tokenAddress'] = tokenAddress;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards: async (accountId?: number, market?: string, timestamp?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMining`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (timestamp !== undefined) {\r\n                localVarQueryParameter['timestamp'] = timestamp;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId: async (accountId: number, sellTokenId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'accountId', accountId)\r\n            // verify required parameter 'sellTokenId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'sellTokenId', sellTokenId)\r\n            const localVarPath = `/api/v3/storageId`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (sellTokenId !== undefined) {\r\n                localVarQueryParameter['sellTokenId'] = sellTokenId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail: async (accountId: number, orderHash: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'accountId', accountId)\r\n            // verify required parameter 'orderHash' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'orderHash', orderHash)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders: async (accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrders', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/orders`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (side !== undefined) {\r\n                localVarQueryParameter['side'] = side;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (orderTypes !== undefined) {\r\n                localVarQueryParameter['orderTypes'] = orderTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances: async (accountId: number, tokens?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserBalances', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokens !== undefined) {\r\n                localVarQueryParameter['tokens'] = tokens;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill: async (accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/bills`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserCreate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/createInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserDeposits', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/deposits`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates: async (accountId: number, markets: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'accountId', accountId)\r\n            // verify required parameter 'markets' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'markets', markets)\r\n            const localVarPath = `/api/v3/user/feeRates`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (markets !== undefined) {\r\n                localVarQueryParameter['markets'] = markets;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades: async (accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTrades', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (fromId !== undefined) {\r\n                localVarQueryParameter['fromId'] = fromId;\r\n            }\r\n\r\n            if (fillTypes !== undefined) {\r\n                localVarQueryParameter['fillTypes'] = fillTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTransfers', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/transfers`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (transferTypes !== undefined) {\r\n                localVarQueryParameter['transferTypes'] = transferTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserUpdate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/updateInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserWithdrawals', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (withdrawalTypes !== undefined) {\r\n                localVarQueryParameter['withdrawalTypes'] = withdrawalTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/refer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal: async (body: OffChainWithdrawalRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOffChainWithdrawal', 'body', body)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3: async (body: SubmitOrderRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOrderV3', 'body', body)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer: async (body: OriginTransferRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitTransfer', 'body', body)\r\n            const localVarPath = `/api/v3/transfer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount: async (body: UpdateAccountRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitUpdateAccount', 'body', body)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassUserApi - functional programming interface\r\n * @export\r\n */\r\nexport const ClassUserApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = ClassUserApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async applyApiKey(body: GetApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.applyApiKey(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(accountId, orderHash, clientOrderId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getApiKey(accountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionTotalReward(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionTotalReward(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewardTotal(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewardTotal(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewards(accountId, market, timestamp, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getNextStorageId(accountId: number, sellTokenId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextStorageId(accountId, sellTokenId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrderDetail(accountId: number, orderHash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderDetail(accountId, orderHash, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBalances(accountId: number, tokens?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBalances(accountId, tokens, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserFeeRates(accountId: number, markets: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFeeRates(accountId, markets, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUpdate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async setReferrer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.setReferrer(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOffChainWithdrawal(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOrderV3(body: SubmitOrderRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOrderV3(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitTransfer(body: OriginTransferRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransfer(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUpdateAccount(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * ClassUserApi - factory interface\r\n * @export\r\n */\r\nexport const ClassUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = ClassUserApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey(body: GetApiKeyRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.applyApiKey(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey(accountId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getApiKey(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionTotalReward(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewardTotal(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId(accountId: number, sellTokenId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getNextStorageId(accountId, sellTokenId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail(accountId: number, orderHash: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrderDetail(accountId, orderHash, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances(accountId: number, tokens?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBalances(accountId, tokens, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates(accountId: number, markets: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserFeeRates(accountId, markets, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer(options?: any): AxiosPromise<any> {\r\n            return localVarFp.setReferrer(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOffChainWithdrawal(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3(body: SubmitOrderRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOrderV3(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer(body: OriginTransferRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitTransfer(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitUpdateAccount(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * ClassUserApi - object-oriented interface\r\n * @export\r\n * @class ClassUserApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class ClassUserApi extends BaseAPI {\r\n    /**\r\n     * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n     * @summary Update user\\'s ApiKey\r\n     * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public applyApiKey(body: GetApiKeyRequest, options?: any) {\r\n        return ClassUserApiFp(this.configuration).applyApiKey(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Cancel order using order hash or client-side ID.\r\n     * @summary Cancel order\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [orderHash] Order HASH\r\n     * @param {string} [clientOrderId] The unique order ID of the client\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the ApiKey associated with the user\\'s account.\r\n     * @summary Get user ApiKey\r\n     * @param {number} accountId AccountID\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getApiKey(accountId: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getApiKey(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {number} [tokenId] \r\n     * @param {number} [start] \r\n     * @param {number} [size] \r\n     * @param {number} [rewardType] \r\n     * @param {number} [taker] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getCommissionTotalReward(accountId?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getCommissionTotalReward(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [address] \r\n     * @param {string} [financeType] \r\n     * @param {string} [tokenAddress] \r\n     * @param {number} [offset] \r\n     * @param {number} [limit] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getLiquidityMiningRewardTotal(accountId?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getLiquidityMiningRewardTotal(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [market] \r\n     * @param {number} [timestamp] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n     * @summary Get next storage ID\r\n     * @param {number} accountId Looprings account identifier\r\n     * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getNextStorageId(accountId: number, sellTokenId: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getNextStorageId(accountId, sellTokenId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the details of an order based on order hash.\r\n     * @summary Get order details\r\n     * @param {number} accountId Account ID\r\n     * @param {string} orderHash Order hash\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getOrderDetail(accountId: number, orderHash: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getOrderDetail(accountId, orderHash, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get a list of orders satisfying certain criteria.\r\n     * @summary Get multiple orders\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n     * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n     * @param {number} [limit] Limit of orders (default 50)\r\n     * @param {number} [offset] Offset of orders (default 0)\r\n     * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any) {\r\n        return ClassUserApiFp(this.configuration).getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether and token balances on exchange.\r\n     * @summary Get user exchange balances\r\n     * @param {number} accountId AccountID\r\n     * @param {string} [tokens] Query tokens\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserBalances(accountId: number, tokens?: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserBalances(accountId, tokens, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [billType] \r\n     * @param {number} [start] \r\n     * @param {number} [end] \r\n     * @param {number} [limit] \r\n     * @param {number} [offset] \r\n     * @param {number} [tokenId] \r\n     * @param {boolean} [income] \r\n     * @param {string} [transferAddress] \r\n     * @param {string} [fromAddress] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for exchange account registration.\r\n     * @summary Get user registration transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list of deposit records for the given user.\r\n     * @summary Get user deposit history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the fee rate of users placing orders in specific markets\r\n     * @summary Query user place order fee rate\r\n     * @param {number} accountId Account ID\r\n     * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserFeeRates(accountId: number, markets: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserFeeRates(accountId, markets, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user trade history.\r\n     * @summary Get user trade history\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {string} [orderHash] Order hash\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [fromId] The begin id of the query.\r\n     * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user transfer list.\r\n     * @summary Get user transfer list\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n     * @summary Get password reset transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user onchain withdrawal history.\r\n     * @summary Get user onchain withdrawal history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any) {\r\n        return ClassUserApiFp(this.configuration).getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public setReferrer(options?: any) {\r\n        return ClassUserApiFp(this.configuration).setReferrer(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit offchain withdraw request\r\n     * @summary Submit offchain withdraw request\r\n     * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any) {\r\n        return ClassUserApiFp(this.configuration).submitOffChainWithdrawal(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit an order\r\n     * @summary Submit an order\r\n     * @param {SubmitOrderRequestV3} body Submit order message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public submitOrderV3(body: SubmitOrderRequestV3, options?: any) {\r\n        return ClassUserApiFp(this.configuration).submitOrderV3(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit internal transfer\r\n     * @summary Submit internal transfer\r\n     * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public submitTransfer(body: OriginTransferRequestV3, options?: any) {\r\n        return ClassUserApiFp(this.configuration).submitTransfer(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n     * @summary Update account EDDSA key\r\n     * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof ClassUserApi\r\n     */\r\n    public submitUpdateAccount(body: UpdateAccountRequestV3, options?: any) {\r\n        return ClassUserApiFp(this.configuration).submitUpdateAccount(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * LightConeWebSocketAPIApi - axios parameter creator\r\n * @export\r\n */\r\nexport const LightConeWebSocketAPIApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWsKeyV3: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/v3/ws/key`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        ws: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/v3/ws`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * LightConeWebSocketAPIApi - functional programming interface\r\n * @export\r\n */\r\nexport const LightConeWebSocketAPIApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = LightConeWebSocketAPIApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getWsKeyV3(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWsKeyV3(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async ws(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.ws(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * LightConeWebSocketAPIApi - factory interface\r\n * @export\r\n */\r\nexport const LightConeWebSocketAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = LightConeWebSocketAPIApiFp(configuration)\r\n    return {\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWsKeyV3(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getWsKeyV3(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        ws(options?: any): AxiosPromise<any> {\r\n            return localVarFp.ws(options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * LightConeWebSocketAPIApi - object-oriented interface\r\n * @export\r\n * @class LightConeWebSocketAPIApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class LightConeWebSocketAPIApi extends BaseAPI {\r\n    /**\r\n     * \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LightConeWebSocketAPIApi\r\n     */\r\n    public getWsKeyV3(options?: any) {\r\n        return LightConeWebSocketAPIApiFp(this.configuration).getWsKeyV3(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LightConeWebSocketAPIApi\r\n     */\r\n    public ws(options?: any) {\r\n        return LightConeWebSocketAPIApiFp(this.configuration).ws(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * LoopringDEXRestfulAPIApi - axios parameter creator\r\n * @export\r\n */\r\nexport const LoopringDEXRestfulAPIApiAxiosParamCreator = function (configuration?: Configuration) {\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey: async (body: GetApiKeyRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('applyApiKey', 'body', body)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder: async (accountId: number, orderHash?: string, clientOrderId?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('cancelOrder', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (clientOrderId !== undefined) {\r\n                localVarQueryParameter['clientOrderId'] = clientOrderId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite: async (site?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/crawl`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (site !== undefined) {\r\n                localVarQueryParameter['site'] = site;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAccount', 'owner', owner)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getAllowance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getAllowance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/allowances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance: async (poolAddress: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmPoolBalance', 'poolAddress', poolAddress)\r\n            const localVarPath = `/api/v3/amm/balance`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/pools`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades: async (ammPoolAddress: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'ammPoolAddress' is not null or undefined\r\n            assertParamExists('getAmmTrades', 'ammPoolAddress', ammPoolAddress)\r\n            const localVarPath = `/api/v3/amm/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (ammPoolAddress !== undefined) {\r\n                localVarQueryParameter['ammPoolAddress'] = ammPoolAddress;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions: async (poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'poolAddress' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'poolAddress', poolAddress)\r\n            // verify required parameter 'billType' is not null or undefined\r\n            assertParamExists('getAmmTransactions', 'billType', billType)\r\n            const localVarPath = `/api/v3/amm/transactions`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (poolAddress !== undefined) {\r\n                localVarQueryParameter['poolAddress'] = poolAddress;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmUserTransactions: async (accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/amm/user/transactions`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (txTypes !== undefined) {\r\n                localVarQueryParameter['txTypes'] = txTypes;\r\n            }\r\n\r\n            if (txStatus !== undefined) {\r\n                localVarQueryParameter['txStatus'] = txStatus;\r\n            }\r\n\r\n            if (ammPoolAddress !== undefined) {\r\n                localVarQueryParameter['ammPoolAddress'] = ammPoolAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey: async (accountId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getApiKey', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/apiKey`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick: async (market: string, interval: string, start?: number, end?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getCandlestick', 'market', market)\r\n            // verify required parameter 'interval' is not null or undefined\r\n            assertParamExists('getCandlestick', 'interval', interval)\r\n            const localVarPath = `/api/v3/candlestick`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (interval !== undefined) {\r\n                localVarQueryParameter['interval'] = interval;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward: async (accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionReward`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n            if (taker !== undefined) {\r\n                localVarQueryParameter['taker'] = taker;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank: async (tokenId?: number, top?: number, rewardType?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n            if (rewardType !== undefined) {\r\n                localVarQueryParameter['rewardType'] = rewardType;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/commissionRewardTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth: async (market: string, level: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getDepth', 'market', market)\r\n            // verify required parameter 'level' is not null or undefined\r\n            assertParamExists('getDepth', 'level', level)\r\n            const localVarPath = `/api/v3/depth`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (level !== undefined) {\r\n                localVarQueryParameter['level'] = level;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthBalance', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce: async (owner: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getEthNonce', 'owner', owner)\r\n            const localVarPath = `/api/v3/eth/nonce`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/info`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome: async (address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/financeIncome`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (address !== undefined) {\r\n                localVarQueryParameter['address'] = address;\r\n            }\r\n\r\n            if (financeType !== undefined) {\r\n                localVarQueryParameter['financeType'] = financeType;\r\n            }\r\n\r\n            if (tokenAddress !== undefined) {\r\n                localVarQueryParameter['tokenAddress'] = tokenAddress;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf: async (market?: string, running?: boolean, pageIndex?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningConf`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (running !== undefined) {\r\n                localVarQueryParameter['running'] = running;\r\n            }\r\n\r\n            if (pageIndex !== undefined) {\r\n                localVarQueryParameter['pageIndex'] = pageIndex;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank: async (market?: string, top?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningRank`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (top !== undefined) {\r\n                localVarQueryParameter['top'] = top;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal: async (accountId?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMiningTotal`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards: async (accountId?: number, market?: string, timestamp?: number, size?: number, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/sidecar/liquidityMining`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (timestamp !== undefined) {\r\n                localVarQueryParameter['timestamp'] = timestamp;\r\n            }\r\n\r\n            if (size !== undefined) {\r\n                localVarQueryParameter['size'] = size;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade: async (market: string, limit?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getMarketTrade', 'market', market)\r\n            const localVarPath = `/api/v3/trade`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/markets`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId: async (accountId: number, sellTokenId: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'accountId', accountId)\r\n            // verify required parameter 'sellTokenId' is not null or undefined\r\n            assertParamExists('getNextStorageId', 'sellTokenId', sellTokenId)\r\n            const localVarPath = `/api/v3/storageId`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (sellTokenId !== undefined) {\r\n                localVarQueryParameter['sellTokenId'] = sellTokenId;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail: async (accountId: number, orderHash: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'accountId', accountId)\r\n            // verify required parameter 'orderHash' is not null or undefined\r\n            assertParamExists('getOrderDetail', 'orderHash', orderHash)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders: async (accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getOrders', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/orders`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (side !== undefined) {\r\n                localVarQueryParameter['side'] = side;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (orderTypes !== undefined) {\r\n                localVarQueryParameter['orderTypes'] = orderTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice: async (legal: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'legal' is not null or undefined\r\n            assertParamExists('getPrice', 'legal', legal)\r\n            const localVarPath = `/api/v3/price`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (legal !== undefined) {\r\n                localVarQueryParameter['legal'] = legal;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/eth/recommendedGasPrice`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker: async (market: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'market' is not null or undefined\r\n            assertParamExists('getTicker', 'market', market)\r\n            const localVarPath = `/api/v3/ticker`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/timestamp`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance: async (owner: string, token: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'owner' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'owner', owner)\r\n            // verify required parameter 'token' is not null or undefined\r\n            assertParamExists('getTokenBalance', 'token', token)\r\n            const localVarPath = `/api/v3/eth/tokenBalances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (owner !== undefined) {\r\n                localVarQueryParameter['owner'] = owner;\r\n            }\r\n\r\n            if (token !== undefined) {\r\n                localVarQueryParameter['token'] = token;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/tokens`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances: async (accountId: number, tokens?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserBalances', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/balances`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (tokens !== undefined) {\r\n                localVarQueryParameter['tokens'] = tokens;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill: async (accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/user/bills`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (billType !== undefined) {\r\n                localVarQueryParameter['billType'] = billType;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (income !== undefined) {\r\n                localVarQueryParameter['income'] = income;\r\n            }\r\n\r\n            if (transferAddress !== undefined) {\r\n                localVarQueryParameter['transferAddress'] = transferAddress;\r\n            }\r\n\r\n            if (fromAddress !== undefined) {\r\n                localVarQueryParameter['fromAddress'] = fromAddress;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserCreate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/createInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserDeposits', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/deposits`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates: async (accountId: number, markets: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'accountId', accountId)\r\n            // verify required parameter 'markets' is not null or undefined\r\n            assertParamExists('getUserFeeRates', 'markets', markets)\r\n            const localVarPath = `/api/v3/user/feeRates`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (markets !== undefined) {\r\n                localVarQueryParameter['markets'] = markets;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades: async (accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTrades', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/trades`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (market !== undefined) {\r\n                localVarQueryParameter['market'] = market;\r\n            }\r\n\r\n            if (orderHash !== undefined) {\r\n                localVarQueryParameter['orderHash'] = orderHash;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (fromId !== undefined) {\r\n                localVarQueryParameter['fromId'] = fromId;\r\n            }\r\n\r\n            if (fillTypes !== undefined) {\r\n                localVarQueryParameter['fillTypes'] = fillTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserTransfers', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/transfers`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (transferTypes !== undefined) {\r\n                localVarQueryParameter['transferTypes'] = transferTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserUpdate', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/updateInfo`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals: async (accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'accountId' is not null or undefined\r\n            assertParamExists('getUserWithdrawals', 'accountId', accountId)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (accountId !== undefined) {\r\n                localVarQueryParameter['accountId'] = accountId;\r\n            }\r\n\r\n            if (start !== undefined) {\r\n                localVarQueryParameter['start'] = start;\r\n            }\r\n\r\n            if (end !== undefined) {\r\n                localVarQueryParameter['end'] = end;\r\n            }\r\n\r\n            if (status !== undefined) {\r\n                localVarQueryParameter['status'] = status;\r\n            }\r\n\r\n            if (limit !== undefined) {\r\n                localVarQueryParameter['limit'] = limit;\r\n            }\r\n\r\n            if (tokenSymbol !== undefined) {\r\n                localVarQueryParameter['tokenSymbol'] = tokenSymbol;\r\n            }\r\n\r\n            if (offset !== undefined) {\r\n                localVarQueryParameter['offset'] = offset;\r\n            }\r\n\r\n            if (withdrawalTypes !== undefined) {\r\n                localVarQueryParameter['withdrawalTypes'] = withdrawalTypes;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents: async (tokenId?: number, amount?: string, options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/exchange/withdrawalAgents`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n            if (tokenId !== undefined) {\r\n                localVarQueryParameter['tokenId'] = tokenId;\r\n            }\r\n\r\n            if (amount !== undefined) {\r\n                localVarQueryParameter['amount'] = amount;\r\n            }\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction: async (body: ForwardEthTxRequest, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('sendTransaction', 'body', body)\r\n            const localVarPath = `/api/v3/eth/sendTx`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer: async (options: any = {}): Promise<RequestArgs> => {\r\n            const localVarPath = `/api/v3/refer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit: async (body: AmmPoolExitRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolExit', 'body', body)\r\n            const localVarPath = `/api/v3/amm/exit`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin: async (body: AmmPoolJoinRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitAmmPoolJoin', 'body', body)\r\n            const localVarPath = `/api/v3/amm/join`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal: async (body: OffChainWithdrawalRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOffChainWithdrawal', 'body', body)\r\n            const localVarPath = `/api/v3/user/withdrawals`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3: async (body: SubmitOrderRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitOrderV3', 'body', body)\r\n            const localVarPath = `/api/v3/order`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer: async (body: OriginTransferRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitTransfer', 'body', body)\r\n            const localVarPath = `/api/v3/transfer`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount: async (body: UpdateAccountRequestV3, options: any = {}): Promise<RequestArgs> => {\r\n            // verify required parameter 'body' is not null or undefined\r\n            assertParamExists('submitUpdateAccount', 'body', body)\r\n            const localVarPath = `/api/v3/account`;\r\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\r\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\r\n            let baseOptions;\r\n            if (configuration) {\r\n                baseOptions = configuration.baseOptions;\r\n            }\r\n\r\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\r\n            const localVarHeaderParameter = {} as any;\r\n            const localVarQueryParameter = {} as any;\r\n\r\n\r\n    \r\n            localVarHeaderParameter['Content-Type'] = 'application/json';\r\n\r\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\r\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\r\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\r\n            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)\r\n\r\n            return {\r\n                url: toPathString(localVarUrlObj),\r\n                options: localVarRequestOptions,\r\n            };\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * LoopringDEXRestfulAPIApi - functional programming interface\r\n * @export\r\n */\r\nexport const LoopringDEXRestfulAPIApiFp = function(configuration?: Configuration) {\r\n    const localVarAxiosParamCreator = LoopringDEXRestfulAPIApiAxiosParamCreator(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async applyApiKey(body: GetApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.applyApiKey(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(accountId, orderHash, clientOrderId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async crawlSite(site?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlSite(site, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAccount(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAllowance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllowance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolBalance(poolAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolBalance(poolAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPools(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPools(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmPoolsBalances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmPoolsBalances(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTrades(ammPoolAddress, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getApiKey(accountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestick(market, interval, start, end, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionRewardRank(tokenId, top, rewardType, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getCommissionTotalReward(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommissionTotalReward(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getDepth(market: string, level: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepth(market, level, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthBalance(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthBalance(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getEthNonce(owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthNonce(owner, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getExchangeInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningConf(market, running, pageIndex, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRank(market?: string, top?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRank(market, top, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewardTotal(accountId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewardTotal(accountId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityMiningRewards(accountId, market, timestamp, size, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarketTrade(market: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketTrade(market, limit, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getMarkets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarkets(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getNextStorageId(accountId: number, sellTokenId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextStorageId(accountId, sellTokenId, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrderDetail(accountId: number, orderHash: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderDetail(accountId, orderHash, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getPrice(legal: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrice(legal, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getRecommendedGasPrice(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedGasPrice(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTicker(market: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicker(market, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTimestamp(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimestamp(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokenBalance(owner: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenBalance(owner, token, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBalances(accountId: number, tokens?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBalances(accountId, tokens, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserFeeRates(accountId: number, markets: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFeeRates(accountId, markets, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUpdate(accountId, start, end, status, limit, offset, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawalAgents(tokenId, amount, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async sendTransaction(body: ForwardEthTxRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTransaction(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async setReferrer(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.setReferrer(options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolExit(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAmmPoolJoin(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOffChainWithdrawal(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitOrderV3(body: SubmitOrderRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOrderV3(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitTransfer(body: OriginTransferRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTransfer(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        async submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {\r\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUpdateAccount(body, options);\r\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\r\n        },\r\n    }\r\n};\r\n\r\n/**\r\n * LoopringDEXRestfulAPIApi - factory interface\r\n * @export\r\n */\r\nexport const LoopringDEXRestfulAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\r\n    const localVarFp = LoopringDEXRestfulAPIApiFp(configuration)\r\n    return {\r\n        /**\r\n         * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n         * @summary Update user\\'s ApiKey\r\n         * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        applyApiKey(body: GetApiKeyRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.applyApiKey(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Cancel order using order hash or client-side ID.\r\n         * @summary Cancel order\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [orderHash] Order HASH\r\n         * @param {string} [clientOrderId] The unique order ID of the client\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [site] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        crawlSite(site?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.crawlSite(site, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns data associated with the user\\'s exchange account.\r\n         * @summary Query user information\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAccount(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAccount(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n         * @summary Get user token allowance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token The token address to query\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAllowance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAllowance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the snapshot of specific AMM pool\r\n         * @summary Get AMM pool balance snapshot\r\n         * @param {string} poolAddress input AMM pool address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolBalance(poolAddress: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolBalance(poolAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported AMM pools\r\n         * @summary Get AMM pool configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPools(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPools(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getAmmPoolsBalances.notes\r\n         * @summary api.getAmmPoolsBalances.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmPoolsBalances(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmPoolsBalances(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * get AMM pool trade transactions\r\n         * @summary get AMM pool trade transactions\r\n         * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the AMM join/exit transactions\r\n         * @summary get AMM involved join/exit transactions\r\n         * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n         * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {number} [tokenId] A unique token identifier\r\n         * @param {boolean} [income] transfer in or out\r\n         * @param {string} [transferAddress] transfer to address\r\n         * @param {string} [fromAddress] transfer from address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the user\\'s AMM join/exit transactions\r\n         * @summary User\\'s AMM join/exit transactions\r\n         * @param {number} [accountId] Looprings account identifier.\r\n         * @param {number} [start] Date from which to start fetching AMM transactions.\r\n         * @param {number} [end] End Date of the query\r\n         * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n         * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n         * @param {string} [txTypes] Transaction type: join or exit\r\n         * @param {string} [txStatus] The AMM transaction status.\r\n         * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the ApiKey associated with the user\\'s account.\r\n         * @summary Get user ApiKey\r\n         * @param {number} accountId AccountID\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getApiKey(accountId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getApiKey(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the candlestick data of a given trading pair.\r\n         * @summary Get market candlestick\r\n         * @param {string} market Trading pair ID, multi-market is not supported\r\n         * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n         * @param {number} [start] Start time\r\n         * @param {number} [end] End time\r\n         * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCandlestick(market, interval, start, end, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {number} [tokenId] \r\n         * @param {number} [start] \r\n         * @param {number} [size] \r\n         * @param {number} [rewardType] \r\n         * @param {number} [taker] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [tokenId] \r\n         * @param {number} [top] \r\n         * @param {number} [rewardType] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getCommissionTotalReward(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getCommissionTotalReward(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the order book of a given trading pair.\r\n         * @summary Get market orderbook\r\n         * @param {string} market The ID of a trading pair.\r\n         * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n         * @param {number} [limit] Maximum numbers of bids/asks.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getDepth(market: string, level: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getDepth(market, level, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n         * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthBalance(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthBalance(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n         * @summary Get user\\'s next Ethereum nonce\r\n         * @param {string} owner Ethereum address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getEthNonce(owner: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getEthNonce(owner, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return various configurations of Loopring.io\r\n         * @summary Get exchange configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getExchangeInfo(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getExchangeInfo(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [address] \r\n         * @param {string} [financeType] \r\n         * @param {string} [tokenAddress] \r\n         * @param {number} [offset] \r\n         * @param {number} [limit] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {boolean} [running] \r\n         * @param {number} [pageIndex] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {string} [market] \r\n         * @param {number} [top] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRank(market?: string, top?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRank(market, top, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewardTotal(accountId?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewardTotal(accountId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [market] \r\n         * @param {number} [timestamp] \r\n         * @param {number} [size] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Query trades with specified market\r\n         * @summary Get market recent trades\r\n         * @param {string} market Single market to query\r\n         * @param {number} [limit] Number of queries\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarketTrade(market: string, limit?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarketTrade(market, limit, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported markets (trading pairs)\r\n         * @summary Get market configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getMarkets(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getMarkets(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n         * @summary Get next storage ID\r\n         * @param {number} accountId Looprings account identifier\r\n         * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getNextStorageId(accountId: number, sellTokenId: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getNextStorageId(accountId, sellTokenId, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get the details of an order based on order hash.\r\n         * @summary Get order details\r\n         * @param {number} accountId Account ID\r\n         * @param {string} orderHash Order hash\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrderDetail(accountId: number, orderHash: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrderDetail(accountId, orderHash, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get a list of orders satisfying certain criteria.\r\n         * @summary Get multiple orders\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n         * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n         * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n         * @param {number} [limit] Limit of orders (default 50)\r\n         * @param {number} [offset] Offset of orders (default 0)\r\n         * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n         * @summary Get token fiat prices\r\n         * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getPrice(legal: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getPrice(legal, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get recommended gas price in Gwei.\r\n         * @summary Get recommended gas price\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getRecommendedGasPrice(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getRecommendedGasPrice(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n         * @summary Get market ticker\r\n         * @param {string} market Market pair, support multiple markets\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTicker(market: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTicker(market, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the relayer\\'s current time in millisecond\r\n         * @summary Get relayer\\'s current time\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTimestamp(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTimestamp(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n         * @summary Get user token balance\r\n         * @param {string} owner Ethereum address\r\n         * @param {string} token Token\\&#39;s ERC20 address\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokenBalance(owner: string, token: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokenBalance(owner, token, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the configurations of all supported tokens, including Ether.\r\n         * @summary Get token configurations\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getTokens(options?: any): AxiosPromise<any> {\r\n            return localVarFp.getTokens(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns user\\'s Ether and token balances on exchange.\r\n         * @summary Get user exchange balances\r\n         * @param {number} accountId AccountID\r\n         * @param {string} [tokens] Query tokens\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBalances(accountId: number, tokens?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBalances(accountId, tokens, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {number} [accountId] \r\n         * @param {string} [billType] \r\n         * @param {number} [start] \r\n         * @param {number} [end] \r\n         * @param {number} [limit] \r\n         * @param {number} [offset] \r\n         * @param {number} [tokenId] \r\n         * @param {boolean} [income] \r\n         * @param {string} [transferAddress] \r\n         * @param {string} [fromAddress] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for exchange account registration.\r\n         * @summary Get user registration transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list of deposit records for the given user.\r\n         * @summary Get user deposit history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns the fee rate of users placing orders in specific markets\r\n         * @summary Query user place order fee rate\r\n         * @param {number} accountId Account ID\r\n         * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserFeeRates(accountId: number, markets: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserFeeRates(accountId, markets, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user trade history.\r\n         * @summary Get user trade history\r\n         * @param {number} accountId Account ID\r\n         * @param {string} [market] Trading pair\r\n         * @param {string} [orderHash] Order hash\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [fromId] The begin id of the query.\r\n         * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user transfer list.\r\n         * @summary Get user transfer list\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n         * @summary Get password reset transactions\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Get user onchain withdrawal history.\r\n         * @summary Get user onchain withdrawal history\r\n         * @param {number} accountId Account ID\r\n         * @param {number} [start] Start time in milliseconds\r\n         * @param {number} [end] End time in milliseconds\r\n         * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n         * @param {number} [limit] Number of records to return\r\n         * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n         * @param {number} [offset] Number of records to skip\r\n         * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any): AxiosPromise<any> {\r\n            return localVarFp.getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * api.getWithdrawalAgents.notes\r\n         * @summary api.getWithdrawalAgents.value\r\n         * @param {number} [tokenId] \r\n         * @param {string} [amount] \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        getWithdrawalAgents(tokenId?: number, amount?: string, options?: any): AxiosPromise<any> {\r\n            return localVarFp.getWithdrawalAgents(tokenId, amount, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n         * @summary Send a raw Ethereum transaction\r\n         * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        sendTransaction(body: ForwardEthTxRequest, options?: any): AxiosPromise<any> {\r\n            return localVarFp.sendTransaction(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * \r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        setReferrer(options?: any): AxiosPromise<any> {\r\n            return localVarFp.setReferrer(options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the exit request processing status\r\n         * @summary Exit an AMM pool\r\n         * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolExit(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Return the join request processing status\r\n         * @summary Join into AMM pool\r\n         * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitAmmPoolJoin(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit offchain withdraw request\r\n         * @summary Submit offchain withdraw request\r\n         * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOffChainWithdrawal(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit an order\r\n         * @summary Submit an order\r\n         * @param {SubmitOrderRequestV3} body Submit order message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitOrderV3(body: SubmitOrderRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitOrderV3(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Submit internal transfer\r\n         * @summary Submit internal transfer\r\n         * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitTransfer(body: OriginTransferRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitTransfer(body, options).then((request) => request(axios, basePath));\r\n        },\r\n        /**\r\n         * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n         * @summary Update account EDDSA key\r\n         * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n         * @param {*} [options] Override http request option.\r\n         * @throws {RequiredError}\r\n         */\r\n        submitUpdateAccount(body: UpdateAccountRequestV3, options?: any): AxiosPromise<any> {\r\n            return localVarFp.submitUpdateAccount(body, options).then((request) => request(axios, basePath));\r\n        },\r\n    };\r\n};\r\n\r\n/**\r\n * LoopringDEXRestfulAPIApi - object-oriented interface\r\n * @export\r\n * @class LoopringDEXRestfulAPIApi\r\n * @extends {BaseAPI}\r\n */\r\nexport class LoopringDEXRestfulAPIApi extends BaseAPI {\r\n    /**\r\n     * Change the ApiKey associated with the user\\'s account. The current ApiKey must be provided as the value of the X-API-KEY HTTP header.\r\n     * @summary Update user\\'s ApiKey\r\n     * @param {GetApiKeyRequest} body api.applyApiKey.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public applyApiKey(body: GetApiKeyRequest, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).applyApiKey(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Cancel order using order hash or client-side ID.\r\n     * @summary Cancel order\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [orderHash] Order HASH\r\n     * @param {string} [clientOrderId] The unique order ID of the client\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public cancelOrder(accountId: number, orderHash?: string, clientOrderId?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).cancelOrder(accountId, orderHash, clientOrderId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [site] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public crawlSite(site?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).crawlSite(site, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns data associated with the user\\'s exchange account.\r\n     * @summary Query user information\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAccount(owner: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAccount(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the allowance of a given token that the user has authorized for Loopring.io\r\n     * @summary Get user token allowance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token The token address to query\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAllowance(owner: string, token: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAllowance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the snapshot of specific AMM pool\r\n     * @summary Get AMM pool balance snapshot\r\n     * @param {string} poolAddress input AMM pool address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmPoolBalance(poolAddress: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmPoolBalance(poolAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported AMM pools\r\n     * @summary Get AMM pool configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmPools(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmPools(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getAmmPoolsBalances.notes\r\n     * @summary api.getAmmPoolsBalances.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmPoolsBalances(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmPoolsBalances(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * get AMM pool trade transactions\r\n     * @summary get AMM pool trade transactions\r\n     * @param {string} ammPoolAddress The address of the pool on which the swap was submitted.\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmTrades(ammPoolAddress: string, limit?: number, offset?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmTrades(ammPoolAddress, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the AMM join/exit transactions\r\n     * @summary get AMM involved join/exit transactions\r\n     * @param {string} poolAddress The address of the pool on which the swap was submitted.\r\n     * @param {'order' | 'transfer' | 'offchain_withdrawal'} billType The bill type of the amm transaction\r\n     * @param {number} [start] Date from which to start fetching AMM transactions.\r\n     * @param {number} [end] End Date of the query\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {number} [tokenId] A unique token identifier\r\n     * @param {boolean} [income] transfer in or out\r\n     * @param {string} [transferAddress] transfer to address\r\n     * @param {string} [fromAddress] transfer from address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmTransactions(poolAddress: string, billType: 'order' | 'transfer' | 'offchain_withdrawal', start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmTransactions(poolAddress, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the user\\'s AMM join/exit transactions\r\n     * @summary User\\'s AMM join/exit transactions\r\n     * @param {number} [accountId] Looprings account identifier.\r\n     * @param {number} [start] Date from which to start fetching AMM transactions.\r\n     * @param {number} [end] End Date of the query\r\n     * @param {number} [limit] Used to limit the number of returned records. Useful in implementing pagination.\r\n     * @param {number} [offset] Used to apply an offset when looking for valid records. Useful in implementing\r\n     * @param {string} [txTypes] Transaction type: join or exit\r\n     * @param {string} [txStatus] The AMM transaction status.\r\n     * @param {string} [ammPoolAddress] The address of the pool on which the swap was submitted.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getAmmUserTransactions(accountId?: number, start?: number, end?: number, limit?: number, offset?: number, txTypes?: string, txStatus?: string, ammPoolAddress?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getAmmUserTransactions(accountId, start, end, limit, offset, txTypes, txStatus, ammPoolAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the ApiKey associated with the user\\'s account.\r\n     * @summary Get user ApiKey\r\n     * @param {number} accountId AccountID\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getApiKey(accountId: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getApiKey(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the candlestick data of a given trading pair.\r\n     * @summary Get market candlestick\r\n     * @param {string} market Trading pair ID, multi-market is not supported\r\n     * @param {string} interval Candlestick interval, Supported values are: 1min, 5min, 15min, 30min, 1hr, 2hr, 4hr, 12hr, 1d, 1w\r\n     * @param {number} [start] Start time\r\n     * @param {number} [end] End time\r\n     * @param {number} [limit] Number of data points. If more data points are available, the API will only return the first \\&#39;limit\\&#39; data points.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getCandlestick(market: string, interval: string, start?: number, end?: number, limit?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getCandlestick(market, interval, start, end, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {number} [tokenId] \r\n     * @param {number} [start] \r\n     * @param {number} [size] \r\n     * @param {number} [rewardType] \r\n     * @param {number} [taker] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getCommissionReward(accountId?: number, tokenId?: number, start?: number, size?: number, rewardType?: number, taker?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getCommissionReward(accountId, tokenId, start, size, rewardType, taker, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [tokenId] \r\n     * @param {number} [top] \r\n     * @param {number} [rewardType] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getCommissionRewardRank(tokenId?: number, top?: number, rewardType?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getCommissionRewardRank(tokenId, top, rewardType, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getCommissionTotalReward(accountId?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getCommissionTotalReward(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the order book of a given trading pair.\r\n     * @summary Get market orderbook\r\n     * @param {string} market The ID of a trading pair.\r\n     * @param {number} level Order book aggregation level, larger value means further price aggregation.\r\n     * @param {number} [limit] Maximum numbers of bids/asks.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getDepth(market: string, level: number, limit?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getDepth(market, level, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether balance on Ethereum mainnet (not the Ether balance on Loopring.io)\r\n     * @summary Get user\\'s Ether balance on Ethereum mainnet\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getEthBalance(owner: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getEthBalance(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the next nonce of the Ethereum address associated with the user\\'s account\r\n     * @summary Get user\\'s next Ethereum nonce\r\n     * @param {string} owner Ethereum address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getEthNonce(owner: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getEthNonce(owner, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return various configurations of Loopring.io\r\n     * @summary Get exchange configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getExchangeInfo(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getExchangeInfo(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [address] \r\n     * @param {string} [financeType] \r\n     * @param {string} [tokenAddress] \r\n     * @param {number} [offset] \r\n     * @param {number} [limit] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getFinanceIncome(address?: string, financeType?: string, tokenAddress?: string, offset?: number, limit?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getFinanceIncome(address, financeType, tokenAddress, offset, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {boolean} [running] \r\n     * @param {number} [pageIndex] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getLiquidityMiningConf(market?: string, running?: boolean, pageIndex?: number, size?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getLiquidityMiningConf(market, running, pageIndex, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} [market] \r\n     * @param {number} [top] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getLiquidityMiningRank(market?: string, top?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getLiquidityMiningRank(market, top, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getLiquidityMiningRewardTotal(accountId?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getLiquidityMiningRewardTotal(accountId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [market] \r\n     * @param {number} [timestamp] \r\n     * @param {number} [size] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getLiquidityMiningRewards(accountId?: number, market?: string, timestamp?: number, size?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getLiquidityMiningRewards(accountId, market, timestamp, size, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Query trades with specified market\r\n     * @summary Get market recent trades\r\n     * @param {string} market Single market to query\r\n     * @param {number} [limit] Number of queries\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getMarketTrade(market: string, limit?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getMarketTrade(market, limit, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported markets (trading pairs)\r\n     * @summary Get market configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getMarkets(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getMarkets(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one\r\n     * @summary Get next storage ID\r\n     * @param {number} accountId Looprings account identifier\r\n     * @param {number} sellTokenId The unique identifier of the token which the user wants to sell in the next order.\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getNextStorageId(accountId: number, sellTokenId: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getNextStorageId(accountId, sellTokenId, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get the details of an order based on order hash.\r\n     * @summary Get order details\r\n     * @param {number} accountId Account ID\r\n     * @param {string} orderHash Order hash\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getOrderDetail(accountId: number, orderHash: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getOrderDetail(accountId, orderHash, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get a list of orders satisfying certain criteria.\r\n     * @summary Get multiple orders\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {number} [start] Lower bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {number} [end] Upper bound of order\\&#39;s creation timestamp in millisecond\r\n     * @param {'BUY' | 'SELL'} [side] \\&quot;BUY\\&quot; or \\&quot;SELL\\&quot;\r\n     * @param {'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired'} [status] Order status. You can specify one of the following values:\r\n     * @param {number} [limit] Limit of orders (default 50)\r\n     * @param {number} [offset] Offset of orders (default 0)\r\n     * @param {'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm'} [orderTypes] request.getOrders.orderTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getOrders(accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getOrders(accountId, market, start, end, side, status, limit, offset, orderTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Fetches, for all the tokens supported by Loopring, their fiat price.\r\n     * @summary Get token fiat prices\r\n     * @param {string} legal The fiat currency to uses. Currently the following values are supported: USD,CNY,JPY,EUR,GBP,HKD\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getPrice(legal: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getPrice(legal, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get recommended gas price in Gwei.\r\n     * @summary Get recommended gas price\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getRecommendedGasPrice(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getRecommendedGasPrice(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Gets a markets ticker. Generally speaking, a ticker in Loopring consists in data from the market taken last 24Hours.\r\n     * @summary Get market ticker\r\n     * @param {string} market Market pair, support multiple markets\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getTicker(market: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getTicker(market, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the relayer\\'s current time in millisecond\r\n     * @summary Get relayer\\'s current time\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getTimestamp(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getTimestamp(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s token balance on Ethereum mainnet (not token\\'s balance on Loopring.io)\r\n     * @summary Get user token balance\r\n     * @param {string} owner Ethereum address\r\n     * @param {string} token Token\\&#39;s ERC20 address\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getTokenBalance(owner: string, token: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getTokenBalance(owner, token, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the configurations of all supported tokens, including Ether.\r\n     * @summary Get token configurations\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getTokens(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns user\\'s Ether and token balances on exchange.\r\n     * @summary Get user exchange balances\r\n     * @param {number} accountId AccountID\r\n     * @param {string} [tokens] Query tokens\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserBalances(accountId: number, tokens?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserBalances(accountId, tokens, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} [accountId] \r\n     * @param {string} [billType] \r\n     * @param {number} [start] \r\n     * @param {number} [end] \r\n     * @param {number} [limit] \r\n     * @param {number} [offset] \r\n     * @param {number} [tokenId] \r\n     * @param {boolean} [income] \r\n     * @param {string} [transferAddress] \r\n     * @param {string} [fromAddress] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserBill(accountId?: number, billType?: string, start?: number, end?: number, limit?: number, offset?: number, tokenId?: number, income?: boolean, transferAddress?: string, fromAddress?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserBill(accountId, billType, start, end, limit, offset, tokenId, income, transferAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for exchange account registration.\r\n     * @summary Get user registration transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserCreate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserCreate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list of deposit records for the given user.\r\n     * @summary Get user deposit history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserDeposits(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserDeposits(accountId, start, end, status, limit, tokenSymbol, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns the fee rate of users placing orders in specific markets\r\n     * @summary Query user place order fee rate\r\n     * @param {number} accountId Account ID\r\n     * @param {string} markets List of markets to be queried separated by \\&quot;,\\&quot;\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserFeeRates(accountId: number, markets: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserFeeRates(accountId, markets, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user trade history.\r\n     * @summary Get user trade history\r\n     * @param {number} accountId Account ID\r\n     * @param {string} [market] Trading pair\r\n     * @param {string} [orderHash] Order hash\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [fromId] The begin id of the query.\r\n     * @param {'dex' | 'class_amm'} [fillTypes] request.getUserTxs.fillTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserTrades(accountId: number, market?: string, orderHash?: string, offset?: number, limit?: number, fromId?: number, fillTypes?: 'dex' | 'class_amm', options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserTrades(accountId, market, orderHash, offset, limit, fromId, fillTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user transfer list.\r\n     * @summary Get user transfer list\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {string} [transferTypes] request.getUserTxs.transferTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserTransfers(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, transferTypes?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserTransfers(accountId, start, end, status, limit, tokenSymbol, offset, transferTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Returns a list Ethereum transactions from users for resetting exchange passwords.\r\n     * @summary Get password reset transactions\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserUpdate(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, offset?: number, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserUpdate(accountId, start, end, status, limit, offset, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Get user onchain withdrawal history.\r\n     * @summary Get user onchain withdrawal history\r\n     * @param {number} accountId Account ID\r\n     * @param {number} [start] Start time in milliseconds\r\n     * @param {number} [end] End time in milliseconds\r\n     * @param {'processing' | 'processed' | 'received' | 'failed'} [status] Comma separated status values\r\n     * @param {number} [limit] Number of records to return\r\n     * @param {string} [tokenSymbol] Token to filter. If you want to return deposit records for all tokens, omit this parameter\r\n     * @param {number} [offset] Number of records to skip\r\n     * @param {'force_withdrawal' | 'offchain_withdrawal'} [withdrawalTypes] request.getUserTxs.withdrawalTypes\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getUserWithdrawals(accountId: number, start?: number, end?: number, status?: 'processing' | 'processed' | 'received' | 'failed', limit?: number, tokenSymbol?: string, offset?: number, withdrawalTypes?: 'force_withdrawal' | 'offchain_withdrawal', options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getUserWithdrawals(accountId, start, end, status, limit, tokenSymbol, offset, withdrawalTypes, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * api.getWithdrawalAgents.notes\r\n     * @summary api.getWithdrawalAgents.value\r\n     * @param {number} [tokenId] \r\n     * @param {string} [amount] \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public getWithdrawalAgents(tokenId?: number, amount?: string, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).getWithdrawalAgents(tokenId, amount, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Relay a raw Ethereum transaction to Ethereum mainnet.\r\n     * @summary Send a raw Ethereum transaction\r\n     * @param {ForwardEthTxRequest} body Body of send raw transaction\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public sendTransaction(body: ForwardEthTxRequest, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).sendTransaction(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public setReferrer(options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).setReferrer(options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the exit request processing status\r\n     * @summary Exit an AMM pool\r\n     * @param {AmmPoolExitRequestV3} body AMM exit request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitAmmPoolExit(body: AmmPoolExitRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitAmmPoolExit(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Return the join request processing status\r\n     * @summary Join into AMM pool\r\n     * @param {AmmPoolJoinRequestV3} body AMM join request params\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitAmmPoolJoin(body: AmmPoolJoinRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitAmmPoolJoin(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit offchain withdraw request\r\n     * @summary Submit offchain withdraw request\r\n     * @param {OffChainWithdrawalRequestV3} body Submit offchain withdraw request post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitOffChainWithdrawal(body: OffChainWithdrawalRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitOffChainWithdrawal(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit an order\r\n     * @summary Submit an order\r\n     * @param {SubmitOrderRequestV3} body Submit order message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitOrderV3(body: SubmitOrderRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitOrderV3(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Submit internal transfer\r\n     * @summary Submit internal transfer\r\n     * @param {OriginTransferRequestV3} body Submit internal transfer post message body\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitTransfer(body: OriginTransferRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitTransfer(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n\r\n    /**\r\n     * Updates the EDDSA key associated with the specified account, making the previous one invalid in the process.\r\n     * @summary Update account EDDSA key\r\n     * @param {UpdateAccountRequestV3} body api.submitUpdateAccount.implicit.value\r\n     * @param {*} [options] Override http request option.\r\n     * @throws {RequiredError}\r\n     * @memberof LoopringDEXRestfulAPIApi\r\n     */\r\n    public submitUpdateAccount(body: UpdateAccountRequestV3, options?: any) {\r\n        return LoopringDEXRestfulAPIApiFp(this.configuration).submitUpdateAccount(body, options).then((request) => request(this.axios, this.basePath));\r\n    }\r\n}\r\n\r\n\r\n","import { Link } from 'react-router-dom'\n\nimport styled from 'styled-components/macro'\nimport styles from './menu.module.scss'\n\nconst SubMenuContent = styled.div`\ndisplay: none;\nz-index: 1;\npadding-top: 9px;\n`\n\nconst SubMenuContentInternal = styled.div`\nbackground-color: ${({ theme }) => theme.colors.subMenuBgColor};\nmin-width: 250px;\nmargin-left: 20px;\nbox-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\n`\n\nexport interface SubMenuItemProps {\n    active: boolean\n};\n\nconst SubMenuItem = styled.div<SubMenuItemProps>`\nheight: 56px;\npadding-top: 12px;\npadding-left: 10px;\nbackground-color: ${({ active, theme }) => active ? theme.colors.submenu_item_bg_color_a : theme.colors.submenu_item_bg_color_ia};\n\n&:hover {\n    background-color:  ${({ theme }) => theme.colors.submenu_item_bg_color_a};\n}\n\n.submenu_circle {\n    float: left;\n    margin-top: 5px;\n    background-color: ${({ active, theme }) => active ? theme.colors.submenu_circle_bg_color_a : theme.colors.submenu_circle_bg_color_ia};\n    border-radius: 50%;\n\twidth: 8px;\n\theight: 8px;\n}\n\n.submenu_title {\n    color: ${({ active, theme }) => active ? theme.colors.submenu_title_color_a : theme.colors.submenu_title_color_ia};\n    margin-left: 17px;\n    font-size: 14px;\n    line-height: 18px;\n}\n\n.submenu_desc {\n    padding-left: 17px;\n    color: ${({ theme }) => theme.colors.submenu_desc_color};\n    font-size: 12px;\n    line-height: 16px;\n    text-shadow: ${({ active, theme }) => active ? theme.effects.submenu_desc_text_shadow : ''};\n}\n\n&:hover .submenu_circle {\n    background-color: ${({ theme }) => theme.colors.submenu_circle_bg_color_a};\n}\n\n&:hover .submenu_title {\n    color:  ${({ theme }) => theme.colors.submenu_title_color_a};\n}\n\n&:hover .submenu_desc {\n    text-shadow: ${({ theme }) => theme.effects.submenu_desc_text_shadow};\n}\n\n`\n\nexport interface SubMenuProps {\n    submenus: any\n    location: any\n}\n\nconst SubMenu = ({ submenus, location, }: SubMenuProps) => {\n\n    return (\n        <SubMenuContent className={styles.dropdown_content}>\n            <SubMenuContentInternal>\n                {\n                    submenus.map((sub_value: any, sub_index: number) => {\n                        const isActive = location.pathname === sub_value['link']\n                        return (\n                            <Link to={sub_value['link']} key={sub_index}>\n                                <SubMenuItem active={isActive}>\n                                    <div className='submenu_circle'></div>\n                                    <div className='submenu_title'>{sub_value['title']}</div>\n                                    <div className='submenu_desc'>{sub_value['desc']}</div>\n                                </SubMenuItem>\n                            </Link>\n                        )\n                    })\n                }\n            </SubMenuContentInternal>\n        </SubMenuContent>\n    )\n}\n\nexport default SubMenu","import { Link } from 'react-router-dom'\n\nimport styled from 'styled-components/macro'\nimport styles from './menu.module.scss'\n\nimport SubMenu from './SubMenu'\n\nexport interface MenuLiProps {\n    children: React.ReactNode\n    active: boolean\n    width: number\n    font_family: string\n};\n\nconst MenuUl = styled.ul`\nfloat: left;\nmargin-left: 40px;\n`\n\nconst MenuLi = styled.li<MenuLiProps>`\nfloat: left;\nmargin-top: 29px;\nmargin-left: 10px;\npadding: 6px 0px;\n\ncursor: pointer;\n    .menu_txt_a {\n        list-style-type: none;\n        transition: 200ms;\n        width: ${({ width }) => width.toString() + 'px'};\n        text-align: center;\n\n        font-family: ${({ font_family }) => font_family};\n\n        color: ${({ active, theme }) => active ? theme.colors.menuActived : theme.colors.menuInactived};\n\n        &:hover {\n            color:  ${({ theme }) => theme.colors.menuActived};\n        }\n}\n`\n\nconst MenuLiImg = styled.img`\nmargin-top: 35px;\ndisplay: block;\n`\n\nconst MenuLiDiv = styled.div`\n`\n\nexport interface MenuProps {\n    menu_data: any\n    submenu_down: any\n    location: any\n    font_family: string\n}\n\nconst Menu = ({ menu_data, location, font_family, submenu_down }: MenuProps) => {\n\n    return (\n        <MenuUl>\n            {\n                menu_data.map((value: any, index: number) => {\n                    var isActive = location.pathname === value['link']\n                    const hasSubmenu = value['submenus'].length > 0\n                    if (!isActive && hasSubmenu) {\n                        value['submenus'].map((sub_value: any, sub_index: number) => {\n                            if (sub_value['link'] === location.pathname) {\n                                isActive = true\n                                return\n                            }\n                            return\n                        })\n                    }\n                    return (\n                        <MenuLiDiv className={styles.dropdown} key={index}>\n                            <MenuLi active={isActive} width={value['width']} font_family={font_family}>\n                                {\n                                    hasSubmenu ? <div className={'menu_txt_a'}>{value['title']}</div> : <Link to={value['link']}><div className={'menu_txt_a'}>{value['title']}</div></Link>\n                                }\n                            </MenuLi>\n                            {hasSubmenu && (<MenuLiImg src={submenu_down} />) }\n                            {hasSubmenu && (<SubMenu submenus={value['submenus']} location={location} />) }\n                        </MenuLiDiv>\n                    )\n                })\n            }\n        </MenuUl>\n    );\n\n}\n\nexport default Menu\n","import Menu from './Menu'\n\nexport default Menu\n","import Menu from './Menu'\n\nexport default Menu\n","import { useLocation } from 'react-router-dom'\nimport { useTranslation } from 'react-i18next'\n\nimport { useTheme } from 'styled-components'\n\nimport { getFontFamily } from 'utils/text_tools'\n\nimport MenuUI from 'components/menus/NormalMenu'\n\nconst Menu = () => {\n\n    const { t } = useTranslation()\n\n    const menu_data = [\n        {\n            'title': t('common:menu_quote'),\n            'link': '/quote',\n            'width': 60,\n            'submenus': [],\n        },\n        {\n            'title': t('common:menu_trading'),\n            'link': '',\n            'width': 60,\n            'submenus': [\n                {\n                    'title': t('common:submenu_simple_title'),\n                    'desc': t('common:submenu_simple_desc'),\n                    'link': '/trading/quick',\n                },\n                {\n                    'title': t('common:submenu_pro_title'),\n                    'desc': t('common:submenu_pro_desc'),\n                    'link': '/trading/pro',\n                }\n            ],\n        },\n        {\n            'title': t('common:menu_liquidity'),\n            'link': '/liquidity',\n            'width': 70,\n            'submenus': [],\n        },\n        {\n            'title': t('common:menu_l2wallet'),\n            'link': '/l2wallet',\n            'width': 80,\n            'submenus': [],\n        }\n    ]\n\n\n    const location = useLocation()\n    \n    const theme: any = useTheme()\n\n    const font_family: string = getFontFamily()\n\n    return (\n        <MenuUI menu_data={menu_data} location={location} font_family={font_family} submenu_down={theme.imgs.submenu_down} />\n    )\n\n}\n\nexport default Menu\n","import i18n from 'plugins/i18n'\n\nexport const getFontFamily = () => {\n    return i18n.language === 'zh_CN' ? 'Source Han Sans CN' : 'Roboto'\n}\n","import styled from 'styled-components/macro'\n\nexport interface ConnectWalletBtnProps {\n  txt?: string,\n  w?: string,\n  h?: string,\n  onClick?: any,\n}\n\nconst Button = styled.button<ConnectWalletBtnProps>`\ncursor: pointer;\nbackground: ${({ theme }) => theme.colors.cwBtnBgColor};\ncolor: ${({ theme }) => theme.colors.cwBtnColor};\nborder-radius: 8px;\nwidth: ${({ w }) => w ? w: '120px'};\nheight: ${({ h }) => h ? h: '36px'};\nline-height: 36px;\ntext-align: center;\n\nfont-family: Roboto-Black;\nfont-size: 16px;\nline-height: 19px;\n`\n\nconst ConnectWalletBtn = ({ txt, onClick, w, h, }: ConnectWalletBtnProps) => {\n\n  return (\n    <Button onClick={onClick} w={w} h={h}>\n      {txt}\n    </Button>\n  )\n}\n\nexport default ConnectWalletBtn\n","import ConnectWalletBtn from './ConnectWalletBtn'\n\nexport default ConnectWalletBtn\n","import ConnectWalletBtnUI, { ConnectWalletBtnProps } from 'components/btns/ConnectWalletBtn/ConnectWalletBtn'\nimport { useTranslation } from 'react-i18next'\n\nconst ConnectWalletBtn = ({ w, h, }: ConnectWalletBtnProps) => {\n\n  const { t } = useTranslation()\n\n  const onClick = () => {\n  }\n  \n  return (\n    <ConnectWalletBtnUI onClick={onClick} txt={t('common:connect_btn')} w={w} h={h} />\n  )\n}\n\nexport default ConnectWalletBtn\n","import styled from 'styled-components/macro'\n\nexport interface IconBtnProps {\n  src?: any\n  w?: string\n  h?: string\n  marginTop?: string\n  marginLeft?: string\n  onClick?: any\n}\n\nconst BtnImg = styled.img<IconBtnProps>`\n  cursor: pointer;\n  margin-top: ${({ marginTop }) => marginTop ? marginTop : 0};\n  margin-left: ${({ marginLeft }) => marginLeft ? marginLeft : 0};\n`\n\nconst IconBtn = ({ onClick, src, w, h, marginLeft, marginTop }: IconBtnProps) => {\n  return (\n    <BtnImg marginLeft={marginLeft} marginTop={marginTop} width={w} height={h} src={src} onClick={onClick}>\n    </BtnImg>\n  )\n}\n\nexport default IconBtn\n","import IconBtn from './IconBtn'\n\nexport default IconBtn\n","import React, { useState } from 'react'\n\nimport styled from 'styled-components/macro'\n\nimport styles from './lng_selector.module.scss'\n\nimport { useTheme } from 'styled-components'\n\nimport IconBtn from 'components/btns/IconBtn'\n\nexport interface LngSelectorProps {\n  lng_data: any[],\n  onLngChange?: any,\n}\n\nconst LngSelectMain = styled.div`\n  float: right;\n  margin-left: 28px;\n  font-family: sans-serif;\n`\n\nconst DropDownContainer = styled.div`\n  width: 20px;\n  z-index: 1;\n`\n\nconst DropDownHeader = styled.div`\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.15);\n`\n\nconst DropDownListContainer = styled.div``\n\nconst DropDownList = styled.ul`\n  background: ${({ theme }) => theme.colors.bodyBgColor};\n  width: 80px;\n  padding: 0;\n  margin: 0;\n  padding-left: 5px;\n  border: 1px solid #e5e5e5;\n  box-sizing: border-box;\n  color: ${({ theme }) => theme.colors.cwBtnColor};\n  font-weight: 500;\n  &:first-child {\n    padding-top: 2px;\n  }\n`\n\nconst ListItem = styled.li`\n  cursor: pointer;\n  list-style: none;\n  margin-bottom: 2px;\n`\n\nconst LngSelector = ({ lng_data, onLngChange, }: LngSelectorProps) => {\n\n  const theme: any = useTheme()\n\n  return (\n    <LngSelectMain>\n      <DropDownContainer className={styles.dropdown}>\n        <DropDownHeader>\n          <IconBtn marginLeft={'0px'} src={theme.imgs.lang_img} w={'20px'} h={'20px'} />\n        </DropDownHeader>\n        <DropDownListContainer className={styles.dropdown_content}>\n          <DropDownList>\n            {\n              lng_data.map((item: any, index: number) => {\n                return (<ListItem key={index} value={item['value']} onClick={() => { onLngChange(item['value']) }}>{item['title']}</ListItem>)\n              })\n            }\n          </DropDownList>\n        </DropDownListContainer>\n      </DropDownContainer>\n    </LngSelectMain>\n  )\n}\n\nexport default LngSelector","import LngSelector from './LngSelector'\n\nexport default LngSelector\n","import LngSelector from './LngSelector'\n\nexport default LngSelector\n","import i18n from 'plugins/i18n'\n\nimport LngSelectorUI from 'components/selects/LngSelector'\n\nconst LngSelector = () => {\n\n  const onLngChange = (lan: any) => {\n    i18n.changeLanguage(lan === 'zh_CN' ? 'zh_CN' : 'en_US')\n  }\n  \n  const lng_data = [\n    {\n      'title': 'English',\n      'value': 'en_US'\n    },\n    {\n      'title': '',\n      'value': 'zh_CN'\n    },\n  ]\n\n  return (\n    <LngSelectorUI lng_data={lng_data} onLngChange={onLngChange} />\n  )\n}\n\nexport default LngSelector\n","import React from 'react'\n\nimport { Link } from 'react-router-dom'\n\nimport { useTheme } from 'styled-components'\nimport styled from 'styled-components/macro'\nimport styles from './header.module.scss'\n\nimport i18n from 'plugins/i18n'\nimport { useDispatch } from 'react-redux'\n\nimport { changeTheme } from 'stores/reducers/settings_reducer'\n\nimport { useAccount } from 'hooks/account_hook'\n\nimport Menu from 'features/components/menu/NormalMenu'\nimport ConnectWalletBtn from 'features/components/btns/ConnectWalletBtn'\nimport IconBtn from 'components/btns/IconBtn'\nimport LngSelector from 'features/components/selects/LngSelector'\n\nconst HeaderDiv = styled.div`\n  width: 100%;\n  height: 110px;\n  background-color: ${({ theme }) => theme.colors.headerBgColor};\n`\n\nconst AdvDiv = styled.div`\n  width: 100%;\n  height: 50px;\n  text-align: center;\n  background-color: #5773FF;\n`\n\nconst AdvImg = styled.img`\n`\n\nconst Logo = styled.img`\n  width: 150px;\n  height: 50px;\n  float: left;\n`\n\nexport interface HeaderProps {\n}\n\nconst Header = ({ }: HeaderProps) => {\n\n  const theme: any = useTheme()\n\n  const acc = useAccount()\n\n  const dispatch = useDispatch()\n\n  const onDownload = () => {\n    console.log('onDownload')\n  }\n\n  const onNotification = () => {\n    console.log('onNotification')\n  }\n\n  const onModeChange = () => {\n    console.log('onModeChange')\n    dispatch(changeTheme())\n  }\n\n  const lng_data = [\n    {\n      'title': 'English',\n      'value': 'en_US'\n    },\n    {\n      'title': '',\n      'value': 'zh_CN'\n    },\n  ]\n\n  return (\n    <HeaderDiv>\n      <AdvDiv><AdvImg className={styles.advimg} src={theme.imgs.advImg}></AdvImg></AdvDiv>\n      <div className={styles.menu_bar}>\n        <div><Link to='/'><Logo src={theme.imgs.logo} /></Link></div>\n        <Menu />\n        <div className={styles.iconbtns}>\n          <IconBtn marginLeft={'48px'} onClick={onDownload} src={theme.imgs.download_img} w={'20px'} h={'20px'} />\n          <IconBtn marginLeft={'28px'} onClick={onNotification} src={theme.imgs.notification_img} w={'20px'} h={'20px'} />\n          <IconBtn marginLeft={'28px'} onClick={onModeChange} src={theme.imgs.mode_img} w={'20px'} h={'20px'} />\n          <LngSelector />\n        </div>\n        {acc.isLogined ? (\n          <IconBtn marginLeft={'28px'} onClick={onModeChange} src={theme.imgs.lang_img} w={'20px'} h={'20px'} />\n        ) :\n          (\n            <div className={styles.cwbtn}>\n              <ConnectWalletBtn />\n            </div>\n          )\n        }\n      </div>\n\n      <div className={styles.small_menu_bar}>\n        <div><Link to='/'><Logo src={theme.imgs.logo} /></Link></div>\n        <div className={styles.iconbtns}>\n          <IconBtn marginLeft={'48px'} onClick={onDownload} src={theme.imgs.download_img} w={'20px'} h={'20px'} />\n          <IconBtn marginLeft={'28px'} onClick={onNotification} src={theme.imgs.notification_img} w={'20px'} h={'20px'} />\n          <IconBtn marginLeft={'28px'} onClick={onModeChange} src={theme.imgs.mode_img} w={'20px'} h={'20px'} />\n          <IconBtn marginLeft={'28px'} onClick={onModeChange} src={theme.imgs.lang_img} w={'20px'} h={'20px'} />\n        </div>\n        <div className={styles.cwbtn}>\n          <ConnectWalletBtn />\n        </div>\n      </div>\n    </HeaderDiv>\n  );\n}\n\nexport default Header;\n","import Header from './Header'\n\nexport default Header\n","import styled from 'styled-components/macro'\n\nconst FooterDiv = styled.div`\n    background-color: #111111;\n    text-align: center;\n    height: 100px;\n    width: 100%;\n    div {\n        & .footer_internal {\n            text-align: center;\n            color: white;\n            width: 1280px\n            margin: 0 auto;\n            line-height: 35px;\n        }\n\n        @media screen and (max-width: 1280px) {\n        \n          .footer_internal {\n            width: 100%;\n          }\n        \n        }\n    }\n`\n\nconst Footer = () => {\n\n    return (\n        <FooterDiv>\n            <div>\n                <div className={'footer_internal'}>Copyright (c) 2017-{new Date().getFullYear()}. </div>\n                <div className={'footer_internal'}>All Rights Reversed by Loopring.</div>\n            </div>\n        </FooterDiv>\n    )\n\n}\n\nexport default Footer\n","import Footer from './Footer'\n\nexport default Footer\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\nexport interface IntroPanelProps {\n}\n\nconst Intro = styled.div`\n    height: 424px;\n    background-color: #444444;\n    text-align: center;\n`\n\nconst Line1 = styled.div`\n    padding-top: 160px;\n    font-size: 72px;\n`\n\nconst Line2 = styled.div`\n    margin-top: 10px;\n    font-size: 30px;\n`\n\nconst Line3 = styled.div`\n    margin-top: 10px;\n    font-size: 24px;\n`\n\nconst IntroPanel = ({ }: IntroPanelProps) => {\n\n    const { t } = useTranslation()\n\n    return (\n        <Intro>\n            <Line1></Line1>\n            <Line2>zkRollup</Line2>\n            <Line3></Line3>\n        </Intro>\n    )\n}\n\nexport default IntroPanel\n","import IntroPanel from './IntroPanel'\n\nexport default IntroPanel\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\ninterface ActivityItemProps {\n    margin_left?: string\n}\n\nconst ActivityRow = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n\n    text-align:justify;\n    text-align-last:center;\n`\n\nconst ActivityItem = styled.div<ActivityItemProps>`\n    cursor: pointer;\n    float: left;\n    width: 280px;\n    height: 140px;\n    line-height: 140px;\n    background-color: #F6F6F6;\n    margin-left: ${({ margin_left }) => margin_left ? margin_left : 0};\n    color: #000000;\n`\n\nexport interface ActivityPanelProps {\n}\n\nconst ActivityPanel = ({ }: ActivityPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const marginLeft = '50px'\n\n    return (\n        <ActivityRow>\n            <ActivityItem></ActivityItem>\n            <ActivityItem margin_left={marginLeft}></ActivityItem>\n            <ActivityItem margin_left={marginLeft}></ActivityItem>\n            <ActivityItem margin_left={marginLeft}></ActivityItem>\n        </ActivityRow>\n    )\n}\n\nexport default ActivityPanel\n","import ActivityPanel from './ActivityPanel'\n\nexport default ActivityPanel\n","import React from 'react'\nimport styled from 'styled-components'\n\nconst Styles = styled.div`\n\n  overflow-y: scroll;\n  height: 95%;\n  \n  &::-webkit-scrollbar {\n    display:none;\n  }\n\n  table {\n    border-spacing: 0;\n  \n    height: 500px;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding-top: 3px;\n\n      text-align: right;\n\n      :last-child {\n      }\n    }\n\n    .ask_row {\n      color: #00BBA8;\n    }\n\n    .bid_row {\n      color: #FF5677;\n    }\n\n  }\n`\nexport interface QuoteTableProps {\n  quotes: any\n  cols: any[]\n}\n\nconst Table = ({ quotes, cols }: QuoteTableProps) => {\n\n  return (\n    <Styles>\n      <table>\n        <thead>\n          <tr>\n            {\n              cols.map((col: any, order_index: number) => {\n                return (\n                  <th key={order_index}>\n                    {col.Header}\n                  </th>\n                )\n              })\n            }\n          </tr>\n        </thead>\n        <tbody>\n          {\n            quotes &&\n            quotes.map((quote: any, quote_index: number) => {\n              return (\n                <tr key={quote_index}>\n                  <td>{quote}</td>\n                </tr>\n              )\n            })\n          }\n        </tbody>\n      </table>\n    </Styles>\n  )\n}\n\nexport default Table\n","import QuoteTable from './QuoteTable'\n\nexport default QuoteTable\n","import { useState } from 'react'\nimport { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\nimport QuoteTable from 'components/tables/QuoteTable'\n\nimport { QuotesData } from 'defs/exchange_defs'\nimport { Link } from 'react-router-dom'\n\nexport interface ActivityPanelProps {\n}\n\nconst QuotePanel = styled.div`\n    height: 686px;\n`\n\nconst ViewMore = styled.div`\n    width: 100%;\n\n    div {\n        color: #ffffff;\n        cursor: pointer;\n        width: 120px;\n        text-align: center;\n        margin: 0 auto;\n        padding-bottom: 20px;\n    }\n`\n\nconst HomeQuotePanel = ({ }: ActivityPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const [quotes, setQuotes] = useState<QuotesData>()\n\n    const cols = [\n        {\n            Header: t('pages:quote_col_1'),\n            accessor: 'quote_col_1',\n        },\n        {\n            Header: t('pages:quote_col_2'),\n            accessor: 'quote_col_2',\n        },\n        {\n            Header: t('pages:quote_col_3'),\n            accessor: 'quote_col_3',\n        },\n        {\n            Header: t('pages:quote_col_4'),\n            accessor: 'quote_col_4',\n        },\n        {\n            Header: t('pages:quote_col_5'),\n            accessor: 'quote_col_5',\n        },\n        {\n            Header: t('pages:quote_col_6'),\n            accessor: 'quote_col_6',\n        },\n        {\n            Header: t('pages:quote_col_7'),\n            accessor: 'quote_col_7',\n        },\n    ]\n\n    return (\n        <QuotePanel>\n            <QuoteTable quotes={quotes} cols={cols} />\n            <ViewMore><Link to={'/quote'}><div>{t('pages:more_quotes')}</div></Link></ViewMore>\n        </QuotePanel>\n    )\n}\n\nexport default HomeQuotePanel\n","import HomeQuotePanel from './HomeQuotePanel'\n\nexport default HomeQuotePanel\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\ninterface TraitItemProps {\n    margin_left?: string\n}\n\nconst Intro = styled.div`\n    height: 206px;\n    text-align: center;\n`\n\nconst Line1 = styled.div`\n    padding-top: 100px;\n    font-size: 30px;\n`\n\nconst TraitRow = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n\n    text-align:justify;\n    text-align-last:center;\n`\n\nconst TraitItem = styled.div<TraitItemProps>`\n    cursor: pointer;\n    float: left;\n    width: 280px;\n    height: 368px;\n    line-height: 368px;\n    background-color: #F6F6F6;\n    margin-left: ${({ margin_left }) => margin_left ? margin_left : 0};\n    color: #000000;\n`\n\nexport interface TraitPanelProps {\n}\n\nconst TraitPanel = ({ }: TraitPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const marginLeft = '50px'\n\n    return (\n        <>\n            <Intro>\n                <Line1>\n                       \n                </Line1>\n            </Intro>\n            <TraitRow>\n                <TraitItem></TraitItem>\n                <TraitItem margin_left={marginLeft}></TraitItem>\n                <TraitItem margin_left={marginLeft}></TraitItem>\n                <TraitItem margin_left={marginLeft}></TraitItem>\n            </TraitRow>\n        </>\n    )\n}\n\nexport default TraitPanel\n","import TraitPanel from './TraitPanel'\n\nexport default TraitPanel\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\nconst Lv2Intro = styled.div`\n    display: flex;\n    height: 951px;\n`\n\nconst Left = styled.div`\n    float: left;\n    width: 50%;\n`\n\nconst Right = styled.div`\n    float: left;\n    width: 50%;\n`\n\nexport interface Lv2IntroPanelProps {\n}\n\nconst Lv2IntroPanel = ({ }: Lv2IntroPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const marginLeft = '50px'\n\n    return (\n        <Lv2Intro>\n            <Left>Left Img Placeholder</Left>\n            <Right></Right>\n        </Lv2Intro>\n    )\n}\n\nexport default Lv2IntroPanel\n","import Lv2IntroPanel from './Lv2IntroPanel'\n\nexport default Lv2IntroPanel\n","import styled from 'styled-components/macro'\n\nexport interface AnnouncementListProps {\n  data: any[],\n}\n\nconst AnnouncementItem = styled.div`\n  width: 100%;\n  color: #ffffff;\n  height: 110px;\n\n  .anno_title {\n  }\n  \n  .anno_date {\n  }\n  \n  border-top: 1px solid #E6E6E6;\n\n  border-bottom: 1px solid #E6E6E6;\n`\n\nconst AnnouncementList = ({ data }: AnnouncementListProps) => {\n  return (\n    <>\n      {\n        data.map((item: any, index: number) => {\n          return (\n            <AnnouncementItem  key={index}>\n              <div className={'anno_title'}>{item.text}</div>\n              <div className={'anno_date'}>{item.date_str}</div>\n            </AnnouncementItem>)\n        })\n      }\n    </>\n  )\n}\n\nexport default AnnouncementList\n","import AnnouncementList from './AnnouncementList'\n\nexport default AnnouncementList\n","const mock: any[] = [\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-18',\n    },\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-17',\n    },\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-16',\n    },\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-16',\n    },\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-16',\n    },\n    {\n        text: '(loopring.io)!!!',\n        date_str: '2021-02-16',\n    }\n]\n\nexport default mock\n","import AnnouncementList from './AnnouncementList'\n\nexport default AnnouncementList\n","import AnnouncementListUI from 'components/lists/AnnouncementList'\n\nimport mock_data from './mock_data'\n\nconst AnnouncementList = () => {\n  return (\n    <AnnouncementListUI data={mock_data}/>\n  )\n}\n\nexport default AnnouncementList\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\nimport { Link } from 'react-router-dom'\n\nimport AnnouncementList from 'features/components/lists/AnnouncementList'\n\nconst Announcement = styled.div`\n    height: 972px;\n    background-color: #222222;\n`\n\nconst Intro = styled.div`\n    width: 100%;\n    height: 134px;\n    text-align: center;\n`\n\nconst Line1 = styled.div`\n    padding-top: 20px;\n    font-size: 38px;\n`\n\nconst ViewMore = styled.div`\n    width: 100%;\n    padding-top: 60px;\n\n    div {\n        color: #ffffff;\n        cursor: pointer;\n        width: 200px;\n        text-align: center;\n        margin: 0 auto;\n        padding-bottom: 20px;\n    }\n`\n\nexport interface AnnouncementPanelProps {\n}\n\nconst AnnouncementPanel = ({ }: AnnouncementPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const marginLeft = '50px'\n\n    return (\n        <Announcement>\n            <Intro>\n                <Line1></Line1>\n            </Intro>\n            <AnnouncementList />\n            <ViewMore><Link to={'/quote'}><div>{t('pages:more_announcements')}</div></Link></ViewMore>\n        </Announcement>\n    )\n}\n\nexport default AnnouncementPanel\n","import AnnouncementPanel from './AnnouncementPanel'\n\nexport default AnnouncementPanel\n","import { useTranslation } from 'react-i18next'\n\nimport styled from 'styled-components'\n\nimport ConnectWalletBtn from 'features/components/btns/ConnectWalletBtn'\n\nconst HomeWallet = styled.div`\n    width: 100%;\n    height: 299px;\n`\n\nconst ConnectTxt = styled.div`\n    padding-top: 108px;\n    text-align: center;\n    font-size: 32px;\n`\n\nconst ConnectDiv = styled.div`\n    margin-top: 35px;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n`\n\nexport interface WalletPanelProps {\n}\n\nconst WalletPanel = ({ }: WalletPanelProps) => {\n\n    const { t } = useTranslation()\n\n    return (\n        <HomeWallet>\n            <ConnectTxt> </ConnectTxt>\n            <ConnectDiv>\n                <ConnectWalletBtn w={'321px'} h={'57px'}/>\n            </ConnectDiv>\n        </HomeWallet>\n    )\n}\n\nexport default WalletPanel\n","import WalletPanel from './WalletPanel'\n\nexport default WalletPanel\n","import HomePage from './HomePage'\n\nexport default HomePage\n","import IntroPanel from 'features/panels/home/IntroPanel'\nimport ActivityPanel from 'features/panels/home/ActivityPanel'\nimport HomeQuotePanel from 'features/panels/home/HomeQuotePanel'\nimport TraitPanel from 'features/panels/home/TraitPanel'\nimport Lv2IntroPanel from 'features/panels/home/Lv2IntroPanel'\nimport AnnouncementPanel from 'features/panels/home/AnnouncementPanel'\nimport WalletPanel from 'features/panels/home/WalletPanel'\n\nconst HomePage = () => {\n\n  return (\n    <>\n      <IntroPanel />\n      <ActivityPanel />\n      <HomeQuotePanel />\n      <TraitPanel />\n      <Lv2IntroPanel />\n      <AnnouncementPanel />\n      <WalletPanel />\n    </>\n  )\n\n}\n\nexport default HomePage\n","import QuotePage from './QuotePage'\n\nexport default QuotePage\n","const QuotePage = () => {\n    return (\n      <div>\n        QuotePage\n      </div>\n    )\n  }\n  \n  export default QuotePage\n  ","const upper_panel_h = 18\n\nconst basic_info_h = 2\nconst order_book_h = upper_panel_h - basic_info_h\n\nconst trading_chart_h = 10\nconst order_inputs_h = upper_panel_h - basic_info_h - trading_chart_h\n\nconst trade_records_h = upper_panel_h\n\nconst order_records_h = 5\n\nconst lg_layout = [\n    { i: 'basic_info', x: 0, y: 0, w: 19, h: basic_info_h, static: true },\n    { i: 'order_book', x: 0, y: basic_info_h, w: 5, h: order_book_h, static: false },\n    { i: 'trading_chart', x: 5, y: basic_info_h, w: 14, h: trading_chart_h, static: false },\n    { i: 'order_actions', x: 5, y: basic_info_h + trading_chart_h, w: 14, h: order_inputs_h, static: false },\n    { i: 'trade_records', x: 19, y: 0, w: 5, h: trade_records_h, static: false },\n    { i: 'order_records', x: 0, y: upper_panel_h, w: 24, h: order_records_h, static: false },\n];\n\nexport const breakpoints = { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }\n\nexport const cols = { lg: 24, md: 10, sm: 6, xs: 4, xxs: 2 }\n\nexport const rowHeight = 50;\n\nexport const layouts = {\n    lg: lg_layout,\n    md: lg_layout,\n    sm: lg_layout,\n    xs: lg_layout,\n    xxs: lg_layout,\n}\n","import { Link } from 'react-router-dom'\n\nimport styled from 'styled-components/macro'\nimport styles from './symbollist.module.scss'\n\nconst SymbolSelector = styled.select`\n`\n\nexport interface SymbolListProps {\n    listData: any\n    location: any\n}\n\nconst SymbolList = ({ listData, location, }: SymbolListProps) => {\n\n    return (<SymbolSelector className={styles.dropdown_content}>\n        {\n            listData.map((sub_value: any, sub_index: number) => {\n                return (\n                    <option key={sub_index} value={location.pathname + sub_value['link']}>{sub_value['title']}</option>\n                )\n            })\n        }\n    </SymbolSelector>)\n}\n\nexport default SymbolList\n","import SymbolList from './SymbolList'\n\nexport default SymbolList\n","/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n * LightCone 2.0 API Documentation\r\n * LightCone DEX function interpretation\r\n *\r\n * The version of the OpenAPI document: 1.0\r\n * \r\n *\r\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\r\n * https://openapi-generator.tech\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nimport { Configuration } from \"./configuration\";\r\n// Some imports not used depending on template conditions\r\n// @ts-ignore\r\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\r\n\r\nexport const BASE_PATH = \"https://uat2.loopring.io\".replace(/\\/+$/, \"\");\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const COLLECTION_FORMATS = {\r\n    csv: \",\",\r\n    ssv: \" \",\r\n    tsv: \"\\t\",\r\n    pipes: \"|\",\r\n};\r\n\r\n/**\r\n *\r\n * @export\r\n * @interface RequestArgs\r\n */\r\nexport interface RequestArgs {\r\n    url: string;\r\n    options: any;\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n * @class BaseAPI\r\n */\r\nexport class BaseAPI {\r\n    protected configuration: Configuration | undefined;\r\n\r\n    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @export\r\n * @class RequiredError\r\n * @extends {Error}\r\n */\r\nexport class RequiredError extends Error {\r\n    name: \"RequiredError\" = \"RequiredError\";\r\n    constructor(public field: string, msg?: string) {\r\n        super(msg);\r\n    }\r\n}\r\n","/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n * LightCone 2.0 API Documentation\r\n * LightCone DEX function interpretation\r\n *\r\n * The version of the OpenAPI document: 1.0\r\n * \r\n *\r\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\r\n * https://openapi-generator.tech\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nimport { Configuration } from \"./configuration\";\r\nimport { RequiredError,RequestArgs } from \"./base\";\r\nimport { AxiosInstance } from 'axios';\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const DUMMY_BASE_URL = 'https://example.com'\r\n\r\n/**\r\n *\r\n * @throws {RequiredError}\r\n * @export\r\n */\r\nexport const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {\r\n    if (paramValue === null || paramValue === undefined) {\r\n        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const setApiKeyToObject = async function (object: any, keyParamName: string, configuration?: Configuration) {\r\n    if (configuration && configuration.apiKey) {\r\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\r\n            ? await configuration.apiKey(keyParamName)\r\n            : await configuration.apiKey;\r\n        object[keyParamName] = localVarApiKeyValue;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const setBasicAuthToObject = function (object: any, configuration?: Configuration) {\r\n    if (configuration && (configuration.username || configuration.password)) {\r\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const setBearerAuthToObject = async function (object: any, configuration?: Configuration) {\r\n    if (configuration && configuration.accessToken) {\r\n        const accessToken = typeof configuration.accessToken === 'function'\r\n            ? await configuration.accessToken()\r\n            : await configuration.accessToken;\r\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const setOAuthToObject = async function (object: any, name: string, scopes: string[], configuration?: Configuration) {\r\n    if (configuration && configuration.accessToken) {\r\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\r\n            ? await configuration.accessToken(name, scopes)\r\n            : await configuration.accessToken;\r\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const setSearchParams = function (url: URL, ...objects: any[]) {\r\n    const searchParams = new URLSearchParams(url.search);\r\n    for (const object of objects) {\r\n        for (const key in object) {\r\n            searchParams.set(key, object[key]);\r\n        }\r\n    }\r\n    url.search = searchParams.toString();\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\r\n    const nonString = typeof value !== 'string';\r\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\r\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\r\n        : nonString;\r\n    return needsSerialization\r\n        ? JSON.stringify(value !== undefined ? value : {})\r\n        : (value || \"\");\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const toPathString = function (url: URL) {\r\n    return url.pathname + url.search + url.hash\r\n}\r\n\r\n/**\r\n *\r\n * @export\r\n */\r\nexport const createRequestFunction = function (axiosArgs: RequestArgs, globalAxios: AxiosInstance, BASE_PATH: string, configuration?: Configuration) {\r\n    return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {\r\n        const axiosRequestArgs = {...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url};\r\n        return axios.request(axiosRequestArgs);\r\n    };\r\n}\r\n","/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n * LightCone 2.0 API Documentation\r\n * LightCone DEX function interpretation\r\n *\r\n * The version of the OpenAPI document: 1.0\r\n * \r\n *\r\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\r\n * https://openapi-generator.tech\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport interface ConfigurationParameters {\r\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\r\n    username?: string;\r\n    password?: string;\r\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\r\n    basePath?: string;\r\n    baseOptions?: any;\r\n    formDataCtor?: new () => any;\r\n}\r\n\r\nexport class Configuration {\r\n    /**\r\n     * parameter for apiKey security\r\n     * @param name security name\r\n     * @memberof Configuration\r\n     */\r\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\r\n    /**\r\n     * parameter for basic security\r\n     *\r\n     * @type {string}\r\n     * @memberof Configuration\r\n     */\r\n    username?: string;\r\n    /**\r\n     * parameter for basic security\r\n     *\r\n     * @type {string}\r\n     * @memberof Configuration\r\n     */\r\n    password?: string;\r\n    /**\r\n     * parameter for oauth2 security\r\n     * @param name security name\r\n     * @param scopes oauth2 scope\r\n     * @memberof Configuration\r\n     */\r\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\r\n    /**\r\n     * override base path\r\n     *\r\n     * @type {string}\r\n     * @memberof Configuration\r\n     */\r\n    basePath?: string;\r\n    /**\r\n     * base options for axios calls\r\n     *\r\n     * @type {any}\r\n     * @memberof Configuration\r\n     */\r\n    baseOptions?: any;\r\n    /**\r\n     * The FormData constructor that will be used to create multipart form data\r\n     * requests. You can inject this here so that execution environments that\r\n     * do not support the FormData class can still run the generated client.\r\n     *\r\n     * @type {new () => FormData}\r\n     */\r\n    formDataCtor?: new () => any;\r\n\r\n    constructor(param: ConfigurationParameters = {}) {\r\n        this.apiKey = param.apiKey;\r\n        this.username = param.username;\r\n        this.password = param.password;\r\n        this.accessToken = param.accessToken;\r\n        this.basePath = param.basePath;\r\n        this.baseOptions = param.baseOptions;\r\n        this.formDataCtor = param.formDataCtor;\r\n    }\r\n\r\n    /**\r\n     * Check if the given MIME is a JSON MIME.\r\n     * JSON MIME examples:\r\n     *   application/json\r\n     *   application/json; charset=UTF8\r\n     *   APPLICATION/JSON\r\n     *   application/vnd.company+json\r\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\r\n     * @return True if the given MIME is JSON, false otherwise.\r\n     */\r\n    public isJsonMime(mime: string): boolean {\r\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\r\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\r\n    }\r\n}\r\n","import {\n  addHexPrefix,\n  clearHexPrefix,\n  toBuffer,\n  toHex,\n} from 'lightcone_api/api_wrapper/common/formatter'\nimport { methodID, rawDecode, rawEncode } from 'ethereumjs-abi'\nimport BN from 'bn.js'\n\nexport default class AbiFunction {\n  constructor({ inputs, name, outputs, constant }) {\n    this.name = name;\n    this.inputTypes = inputs.map(({ type }) => type);\n    this.inputs = inputs;\n    this.outputTypes = outputs.map(({ type }) => type);\n    this.outputs = outputs;\n    this.constant = constant;\n    this.methodAbiHash = toHex(methodID(name, this.inputTypes));\n  }\n\n  /**\n   * @description Returns encoded methodId and inputs\n   * @param inputs Object, examples {owner:'0x000...}\n   * @returns {string}\n   */\n  encodeInputs(inputs) {\n    const abiInputs = this.parseInputs(inputs);\n    return (\n      this.methodAbiHash +\n      clearHexPrefix(toHex(rawEncode(this.inputTypes, abiInputs)))\n    );\n  }\n\n  /**\n   * @description decode ethereum jsonrpc response result\n   * @param outputs\n   * @returns {*}\n   */\n  decodeOutputs(outputs) {\n    return this.parseOutputs(rawDecode(this.outputTypes, toBuffer(outputs)));\n  }\n\n  /**\n   * @description decode encoded inputs\n   * @param encoded\n   * @returns {*}\n   */\n  decodeEncodedInputs(encoded) {\n    return this.parseOutputs(\n      rawDecode(this.inputTypes, toBuffer(addHexPrefix(encoded)))\n    );\n  }\n\n  parseInputs(inputs = {}) {\n    return this.inputs.map(({ name, type }) => {\n      if (inputs[name] === undefined) {\n        console.log('inputs', inputs);\n        throw new Error(`Parameter ${name} of type ${type} is required!`);\n      }\n      return inputs[name];\n    });\n  }\n\n  parseOutputs(outputs) {\n    return outputs.map((output) => {\n      if (output instanceof BN) {\n        return toHex(output);\n      }\n      return output;\n    });\n  }\n}\n","import { methodID } from 'ethereumjs-abi';\nimport { toHex } from '../../common/formatter';\nimport AbiFunction from './AbiFunction';\n\nexport default class Contract {\n  constructor(abi) {\n    const funAbi = abi.filter(({ type }) => type === 'function');\n    this.abiFunctions = funAbi.reduce((acc, item) => {\n      const inputTypes = item.inputs.map(({ type }) => type);\n      const key = `${item.name}(${inputTypes.toString()})`;\n      const methodHash = methodID(item.name, inputTypes);\n      return {\n        ...acc,\n        [item.name]: new AbiFunction(item),\n        [key]: new AbiFunction(item),\n        [methodHash]: new AbiFunction(item),\n      };\n    }, {});\n  }\n\n  /**\n   * @description Encodes inputs data according to  ethereum abi\n   * @param method string can be full method or just method name, examples: 'balanceOf' or balanceOf(address)\n   * @param inputs array\n   * @returns {*|string}\n   */\n  encodeInputs(method, inputs) {\n    console.log('encodeInputs', method, inputs);\n    const abiFunction = this.abiFunctions[method];\n    if (abiFunction) {\n      return abiFunction.encodeInputs(inputs);\n    } else {\n      throw new Error(`No  ${method} method according to abi `);\n    }\n  }\n\n  /**\n   * @description Decodes outputs\n   * @param method string can be full method or just method name, examples: 'balanceOf' or balanceOf(address)\n   * @param outputs string\n   * @returns {*}\n   */\n  decodeOutputs(method, outputs) {\n    const abiFunction = this.abiFunctions[method];\n    if (abiFunction) {\n      return abiFunction.decodeOutputs(outputs);\n    } else {\n      throw new Error(`No  ${method} method according to abi `);\n    }\n  }\n\n  /**\n   * @description Decode encoded method and inputs\n   * @param encode string | Buffer\n   * @returns {*}\n   */\n  decodeEncodeInputs(encode) {\n    encode = toHex(encode);\n    const methodId = encode.slice(0, 10);\n    const abiFunction = this.abiFunctions[methodId];\n    if (abiFunction) {\n      return abiFunction.decodeEncodedInputs(encode.slice(10));\n    } else {\n      throw new Error(`No corresponding method according to abi `);\n    }\n  }\n}\n","import Contract from './Contract';\n\nconst erc20Abi = require('../../config/abis/erc20.json');\nconst exchange31Abi = require('../../config/abis/exchange_3_1.json');\nconst exchange36Abi = require('../../config/abis/exchange_3_6.json');\nconst contractWalletAbi = require('../../config/abis/contractWallet.json');\n\nconst ERC20Token = new Contract(erc20Abi);\nconst Exchange31Contract = new Contract(exchange31Abi);\nconst ExchangeContract = new Contract(exchange36Abi);\nconst ContractWallet = new Contract(contractWalletAbi);\n\nexport default {\n  ERC20Token,\n  Exchange31Contract,\n  ExchangeContract,\n  ContractWallet,\n};\n","import AbiFunction from './AbiFunction';\nimport Contract from './Contract';\nimport Contracts from './Contracts';\n\nexport default {\n  AbiFunction,\n  Contract,\n  Contracts,\n};\n","\nimport {\n  ecrecover,\n  fromRpcSig,\n  hashPersonalMessage,\n  keccak256,\n  pubToAddress,\n} from 'ethereumjs-util'\nimport Transaction from 'ethereumjs-tx'\n\nimport { addHexPrefix, toBuffer, toHex, toNumber } from 'lightcone_api/api_wrapper/common/formatter'\nimport ABI from './contracts'\n\n/**\n * @description sign hash\n * @param web3\n * @param account\n * @param hash\n * @returns {Promise.<*>}\n */\nexport async function sign(web3, account, pwd, hash) {\n  return new Promise((resolve) => {\n    web3.eth.sign(hash, account, pwd, function (err, result) {\n      if (!err) {\n        console.log('sig result', result);\n        const r = result.slice(0, 66);\n        const s = addHexPrefix(result.slice(66, 130));\n        let v = toNumber(addHexPrefix(result.slice(130, 132)));\n        if (v === 0 || v === 1) v = v + 27; // ledger\n        resolve({ result: { r, s, v } });\n      } else {\n        const errorMsg = err.message.substring(0, err.message.indexOf(' at '));\n        resolve({ error: { message: errorMsg } });\n      }\n    });\n  });\n}\n\n/**\n * @description sign EIP217\n * @param web3\n * @param account\n * @param method\n * @param params\n * @returns {Promise.<*>}\n */\nexport async function signEip712(web3, account, method, params) {\n  const response = await new Promise((resolve) => {\n    web3.currentProvider.sendAsync(\n      {\n        method,\n        params,\n        account,\n      },\n      function (err, result) {\n        if (err) {\n          resolve({ error: { message: err.message } });\n          return;\n        }\n\n        if (result.error) {\n          resolve({ error: { message: result.error.message } });\n          return;\n        }\n\n        resolve({ result: result.result });\n      }\n    );\n  });\n\n  if (response['result']) {\n    return response;\n  } else {\n    throw new Error(response['error']['message']);\n  }\n}\n\n/**\n * @description sign message\n * @param web3\n * @param account\n * @param message\n * @returns {Promise}\n */\nexport async function signMessage(web3, account, pwd, message) {\n  const hash = toHex(hashPersonalMessage(keccak256(message)));\n  return await sign(web3, account, pwd, hash);\n}\n\nexport async function personalSign(web3, account, pwd, msg, walletType) {\n  return new Promise((resolve) => {\n    web3.eth.personal.sign(msg, account, pwd, async function (err, result) {\n      if (!err) {\n        // ecRecover not implemented in WalletLink\n        if (walletType === 'WalletLink') {\n          const valid = await walletLinkValid(web3, account, msg, result);\n          if (valid.result) {\n            resolve({ sig: result });\n          } else {\n            resolve({ error: 'Failed to valid using WalletLink' });\n          }\n          return;\n        }\n\n        if (walletType === 'Authereum') {\n          const valid = await authereumValid(web3, account, msg, result);\n          if (valid.result) {\n            resolve({ sig: result });\n          } else {\n            resolve({ error: 'invalid sig using Authereum' });\n          }\n          return;\n        }\n\n        const valid = await ecRecover(web3, account, msg, result);\n        if (valid.result) {\n          resolve({ sig: result });\n        } else {\n          const walletValid = await contractWalletValidate(\n            web3,\n            account,\n            msg,\n            result\n          );\n\n          if (walletValid.result) {\n            resolve({ sig: result });\n          } else {\n            const walletValid2 = await contractWalletValidate2(\n              web3,\n              account,\n              msg,\n              result\n            );\n\n            if (walletValid2.result) {\n              resolve({ sig: result });\n            } else {\n              const myKeyValid = await mykeyWalletValid(\n                web3,\n                account,\n                msg,\n                result\n              );\n              // console.log(JSON.stringify(myKeyValid));\n\n              if (myKeyValid.result) {\n                resolve({ sig: result });\n              } else {\n                resolve({ error: 'invalid sig' });\n              }\n            }\n          }\n        }\n      } else resolve({ error: err });\n    });\n  });\n}\n\nexport async function ecRecover(web3, account, msg, sig) {\n  return new Promise((resolve) => {\n    web3.eth.personal.ecRecover(msg, sig, function (err, address) {\n      if (!err)\n        resolve({\n          result: address.toLowerCase() === account.toLowerCase(),\n        });\n      else {\n        console.log('in web3.eth.personal.ecRecover', err, address);\n        resolve({ error: err });\n      }\n    });\n  });\n}\n\nexport async function contractWalletValidate(web3, account, msg, sig) {\n  return new Promise((resolve) => {\n    const hash = hashPersonalMessage(toBuffer(msg));\n    const data = ABI.Contracts.ContractWallet.encodeInputs(\n      'isValidSignature(bytes,bytes)',\n      {\n        _data: hash,\n        _signature: toBuffer(sig),\n      }\n    );\n\n    web3.eth.call(\n      {\n        to: account, // contract addr\n        data: data,\n      },\n      function (err, result) {\n        if (!err) {\n          const valid = ABI.Contracts.ContractWallet.decodeOutputs(\n            'isValidSignature(bytes,bytes)',\n            result\n          );\n          resolve({\n            result: toHex(toBuffer(valid[0])) === data.slice(0, 10),\n          });\n        } else resolve({ error: err });\n      }\n    );\n  });\n}\n\nexport async function contractWalletValidate2(web3, account, msg, sig) {\n  return new Promise((resolve) => {\n    const hash = hashPersonalMessage(toBuffer(msg));\n    const data = ABI.Contracts.ContractWallet.encodeInputs(\n      'isValidSignature(bytes32,bytes)',\n      {\n        _data: hash,\n        _signature: toBuffer(sig),\n      }\n    );\n\n    web3.eth.call(\n      {\n        to: account, // contract addr\n        data: data,\n      },\n      function (err, result) {\n        console.log(result);\n        if (!err) {\n          const valid = ABI.Contracts.ContractWallet.decodeOutputs(\n            'isValidSignature(bytes32,bytes)',\n            result\n          );\n          resolve({\n            result: toHex(toBuffer(valid[0])) === data.slice(0, 10),\n          });\n        } else resolve({ error: err });\n      }\n    );\n  });\n}\n\nexport async function mykeyWalletValid(web3, account, msg, sig) {\n  const myKeyContract = '0xADc92d1fD878580579716d944eF3460E241604b7';\n  return new Promise((resolve) => {\n    web3.eth.call(\n      {\n        to: myKeyContract,\n        data: ABI.Contracts.ContractWallet.encodeInputs('getKeyData', {\n          _account: account,\n          _index: 3,\n        }),\n      },\n      function (err, res) {\n        if (!err) {\n          const signature = fromRpcSig(sig);\n          const hash = hashPersonalMessage(keccak256(toBuffer(msg)));\n          const address = addHexPrefix(\n            ABI.Contracts.ContractWallet.decodeOutputs('getKeyData', res)[0]\n          );\n          const recAddress = toHex(\n            pubToAddress(ecrecover(hash, signature.v, signature.r, signature.s))\n          );\n          resolve({\n            result: recAddress.toLowerCase() === address.toLowerCase(),\n          });\n        } else {\n          resolve({ error: err });\n        }\n      }\n    );\n  });\n}\n\n// Authereum account contract hashes the data in the validation function,\n// so we must send the data plain text.\nexport async function authereumValid(web3, account, msg, sig) {\n  return new Promise((resolve) => {\n    const hash = toBuffer(msg);\n    const data = ABI.Contracts.ContractWallet.encodeInputs(\n      'isValidSignature(bytes,bytes)',\n      {\n        _data: hash,\n        _signature: toBuffer(sig),\n      }\n    );\n\n    web3.eth.call(\n      {\n        to: account, // contract addr\n        data: data,\n      },\n      function (err, result) {\n        if (!err) {\n          const valid = ABI.Contracts.ContractWallet.decodeOutputs(\n            'isValidSignature(bytes,bytes)',\n            result\n          );\n          resolve({\n            result: toHex(toBuffer(valid[0])) === data.slice(0, 10),\n          });\n        } else resolve({ error: err });\n      }\n    );\n  });\n}\n\nexport async function walletLinkValid(web3, account, msg, sig) {\n  return new Promise((resolve) => {\n    const signature = fromRpcSig(sig);\n    const hash = hashPersonalMessage(toBuffer(msg));\n    const recAddress = toHex(\n      pubToAddress(ecrecover(hash, signature.v, signature.r, signature.s))\n    );\n    resolve({\n      result: recAddress.toLowerCase() === account.toLowerCase(),\n    });\n  });\n}\n\n/**\n * @description Signs ethereum tx\n * @param web3\n * @param account\n * @param rawTx\n * @returns {Promise.<*>}\n */\nexport async function signEthereumTx(web3, account, rawTx) {\n  const ethTx = new Transaction(rawTx);\n  const hash = toHex(ethTx.hash(false));\n  const response = await sign(web3, account, hash);\n  if (!response['error']) {\n    const signature = response['result'];\n    signature.v += ethTx.getChainId() * 2 + 8;\n    Object.assign(ethTx, signature);\n    return { result: toHex(ethTx.serialize()) };\n  } else {\n    throw new Error(response['error']['message']);\n  }\n}\n\n/**\n * @description Sends ethereum tx through MetaMask\n * @param web3\n * @param tx\n * @returns {*}\n */\nexport async function sendTransaction(web3, tx) {\n  delete tx.gasPrice;\n  // delete tx.gas;\n  const response = await new Promise((resolve) => {\n    web3.eth.sendTransaction(tx, function (err, transactionHash) {\n      if (!err) {\n        resolve({ result: transactionHash });\n      } else {\n        resolve({ error: { message: err.message } });\n      }\n    });\n  });\n\n  if (response['result']) {\n    return response;\n  } else {\n    throw new Error(response['error']['message']);\n  }\n}\n\nexport async function isContract(web3, address) {\n  const code = await web3.eth.getCode(address);\n  return code && code.length > 2;\n}\n","import sha256 from 'crypto-js/sha256'\n\nimport * as Poseidon from 'lightcone_api/api_wrapper/sign/poseidon'\n\nimport EdDSA from 'lightcone_api/api_wrapper/sign/eddsa'\n\nimport BigInteger from 'bignumber.js'\n\nimport * as sigUtil from 'eth-sig-util'\n\nimport * as fm from 'lightcone_api/api_wrapper/common/formatter'\n\nimport { personalSign } from 'lightcone_api/api_wrapper/ethereum/metaMask'\n\nconst SNARK_SCALAR_FIELD = new BigInteger('21888242871839275222246405745257275088548364400416034343698204186575808495617', 10)\n\nconst makeRequestParamStr = (request: Map<string, any>) => {\n\n  // @ts-ignore\n  var mapAsc = new Map([...request.entries()].sort())\n\n  console.log('mapAsc:', mapAsc)\n\n  var paramlist: Array<string> = new Array()\n  \n  mapAsc.forEach((value, key) => {\n    if (value !== undefined && value !== '')\n      paramlist.push(encodeURIComponent(`${key}=${value}`))\n  })\n\n  console.log('paramlist:', paramlist)\n\n  return paramlist.join('&')\n\n}\n\nconst makeObjectStr = (request: any) => {\n  return JSON.stringify(request)\n}\n\nconst genSig = (PrivateKey: string, hash: any) => {\n\n  const signature = EdDSA.sign(PrivateKey, hash)\n\n  return (\n    fm.formatEddsaKey(fm.toHex(fm.toBig(signature.Rx))) +\n    fm.clearHexPrefix(fm.formatEddsaKey(fm.toHex(fm.toBig(signature.Ry)))) +\n    fm.clearHexPrefix(fm.formatEddsaKey(fm.toHex(fm.toBig(signature.s))))\n  )\n\n}\n\nexport function getEdDSASig(method:string, basePath: string, api_url: string, requestInfo: any, PrivateKey: string) {\n\n    var params = makeRequestParamStr(requestInfo)\n    \n    /*\n    if (method === 'GET') {\n    } else if (method === 'POST' || method === 'PUT' || method === 'DELETE')  {\n      params = makeObjectStr(requestInfo)\n    } else {\n      throw new Error(`${method} is not supported yet!`)\n    }\n    */\n\n    const uri = encodeURIComponent(`${basePath}${api_url}`)\n\n    const message = `${method}&${uri}&${params}`\n\n    console.log('-->message:', message)\n\n    const hash = (new BigInteger(sha256(message).toString(), 16).mod(SNARK_SCALAR_FIELD)).toFormat(0, 0, {\n    })\n\n    console.log('-->message hash:', hash)\n\n    console.log('-->PrivateKey', PrivateKey)\n\n    const sig = genSig(PrivateKey, hash)\n\n    console.log('genEddsaSig:', sig)\n\n    return sig\n\n}\n\nexport const getEdDSASigWithPoseidon = (inputs: any, PrivateKey: string) => {\n\n  const hasher = Poseidon.createHash(13, 6, 53)\n  const hash = hasher(inputs).toString(10)\n\n  return genSig(PrivateKey, hash)\n\n}\n\nexport async function getEcDSASig(web3: any, typedData: any, address: string, pwd: string = '', hasDataStruct: boolean = true) {\n  \n  if (hasDataStruct) {\n\n    const msgParams = JSON.stringify(typedData)\n    const params = [address, msgParams]\n    const method = 'eth_signTypedData_v4'\n\n    console.log(params)\n\n    const response: any = await new Promise((resolve) => {\n      web3.currentProvider.send(\n        {\n          method,\n          params,\n          address,\n        },\n        function (err: any, result: any) {\n          if (err) {\n            resolve({ error: { message: err.message } })\n            return\n          }\n  \n          if (result.error) {\n            resolve({ error: { message: result.error.message } })\n            return\n          }\n  \n          resolve({ result: result.result })\n        }\n      )\n    })\n  \n    if (!response['result']) {\n      throw new Error(response['error']['message'])\n    }\n  \n    return {\n      ecdsaSig: response.result,\n    }\n\n  } else { // without\n\n    const hash = fm.toHex(sigUtil.TypedDataUtils.sign(typedData))\n    const signature = await personalSign(web3, address, pwd, hash)\n\n    if (signature['sig']) {\n      return {\n        ecdsaSig: signature.sig,\n      }\n    }\n\n    throw new Error(signature.error)\n\n  }\n\n}\n","import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'\nimport { createRequestFunction } from 'lightcone_api/api/common'\nimport {\n  BASE_PATH,\n  COLLECTION_FORMATS,\n  RequestArgs,\n  BaseAPI,\n  RequiredError,\n} from 'lightcone_api/api/base'\n\nimport { UpdateAccountRequestV3 } from 'lightcone_api/api'\n\nimport * as api from 'lightcone_api/api'\n\nimport { getEdDSASig, getEdDSASigWithPoseidon, getEcDSASig } from 'lightcone_api/api_wrapper/sign_tools'\n\nclass AuthHasEcdsaSigApi {\n\n    localVarAxiosParamCreator: any\n    conf: any\n\n    constructor(conf: any) {\n        this.conf = conf\n        this.localVarAxiosParamCreator = api.AuthHasEcdsaSigApiAxiosParamCreator(conf)\n    }\n\n    async submitUpdateAccount(exAddr: string, owner: string, accountId: number, PublicKeyX: string, PublicKeyY: string, \n        tokenId: string, volume: string, validUntil: number, nonce: number, web3: any, hasDataStruct: boolean = true) {\n\n        const reqData: UpdateAccountRequestV3 = {\n          exchange: exAddr,\n          owner: owner,\n          accountId: accountId,\n          publicKey: {\n            x: PublicKeyX,\n            y: PublicKeyY,\n          },\n          maxFee: {\n            tokenId: tokenId,\n            volume: volume,\n          },\n          validUntil: validUntil,\n          nonce: nonce,\n        }\n\n        const localVarAxiosArgs = await this.localVarAxiosParamCreator.submitUpdateAccount(\n          reqData\n        )\n\n        const ecdsaSig = await getEcDSASig(web3, reqData, owner, '', hasDataStruct)\n\n        console.log('ecdsaSig:', ecdsaSig)\n\n        localVarAxiosArgs.options.headers['X-API-SIG'] = ecdsaSig\n\n        const request = createRequestFunction(\n          localVarAxiosArgs,\n          globalAxios,\n          BASE_PATH,\n          this.conf\n        )\n\n        return await request()\n        \n    }\n\n}\n\nexport { AuthHasEcdsaSigApi }\n","import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'\nimport { createRequestFunction } from 'lightcone_api/api/common'\n\nimport { GetApiKeyRequest, SubmitOrderRequestV3 } from 'lightcone_api/api'\n\nimport {\n  BASE_PATH,\n  COLLECTION_FORMATS,\n  RequestArgs,\n  BaseAPI,\n  RequiredError,\n} from 'lightcone_api/api/base'\n\nimport * as api from 'lightcone_api/api'\n\nimport { getEdDSASig, getEdDSASigWithPoseidon, getEcDSASig } from 'lightcone_api/api_wrapper/sign_tools'\n\nclass AuthHasEddsaSigApi {\n\n  localVarAxiosParamCreator: any\n  conf: any\n  basePath: string\n\n  constructor(conf: any) {\n    this.conf = conf\n\n    this.basePath = this.conf.basePath ? this.conf.basePath : BaseAPI\n    this.localVarAxiosParamCreator = api.AuthHasEddsaSigApiAxiosParamCreator(conf)\n  }\n\n  async getApiKey(PrivateKey: string, accountId: number) {\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getApiKey(\n      accountId\n    )\n\n    const requestMap: Map<string, any> = new Map()\n    requestMap.set('accountId', accountId)\n\n    const eddsaSig = getEdDSASig(localVarAxiosArgs.options.method, this.basePath, '/api/v3/apiKey', requestMap, PrivateKey)\n\n    localVarAxiosArgs.options.headers['X-API-SIG'] = eddsaSig\n\n    const request = createRequestFunction(\n      localVarAxiosArgs,\n      globalAxios,\n      this.basePath,\n      this.conf\n    )\n\n    return await request()\n\n  }\n\n  async applyApiKey(PrivateKey: string, accountId: number) {\n\n    const reqData: GetApiKeyRequest = {\n      accountId: accountId\n    }\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.applyApiKey(reqData)\n\n    const requestMap: Map<string, any> = new Map()\n    requestMap.set('accountId', accountId)\n\n    const eddsaSig = getEdDSASig(localVarAxiosArgs.options.method, this.basePath, '/api/v3/apiKey', requestMap, PrivateKey)\n\n    // localVarAxiosArgs.options.headers['X-API-KEY'] = 'r70Bbf5eUzvyicHUBLqBMvqGjdMkHwU3W7FEeQGXJ7zRh4ML31EXI9N7Ef94K7ya'\n    localVarAxiosArgs.options.headers['X-API-SIG'] = eddsaSig\n\n    const request = createRequestFunction(\n      localVarAxiosArgs,\n      globalAxios,\n      this.basePath,\n      this.conf\n    )\n\n    return await request()\n\n  }\n\n  async submitOrderV3(PrivateKey: string, apiKey: string, exchange: string, accountId: number, storageId: number, sell_tokenId: string, sell_volume: string,  buy_tokenId: string, buy_volume: string, \n    allOrNone: string, fillAmountBOrS: string, validUntil: number, maxFeeBips: number) {\n\n    const inputs = {}\n\n    const eddsaSig = getEdDSASigWithPoseidon(inputs, PrivateKey)\n\n    const reqData: SubmitOrderRequestV3 = {\n      exchange: exchange,\n      accountId: accountId,\n      storageId: storageId,\n      sellToken: {\n        tokenId: sell_tokenId,\n        volume: sell_volume\n      },\n      buyToken:  {\n        tokenId: buy_tokenId,\n        volume: buy_volume\n      },\n      allOrNone: allOrNone,\n      fillAmountBOrS: fillAmountBOrS,\n      validUntil: validUntil,\n      maxFeeBips: maxFeeBips,\n      eddsaSignature: eddsaSig,\n    }\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.submitOrderV3(reqData)\n\n    localVarAxiosArgs.options.headers['X-API-SIG'] = eddsaSig\n\n    const request = createRequestFunction(\n      localVarAxiosArgs,\n      globalAxios,\n      this.basePath,\n      this.conf\n    )\n\n    return await request()\n\n  }\n\n  async cancelOrder(PrivateKey: string, apiKey: string, accountId: number, orderHash?: string, clientOrderId?: string) {\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelOrder(accountId, orderHash, clientOrderId)\n\n    console.log('localVarAxiosArgs:', localVarAxiosArgs)\n\n    const requestMap: Map<string, any> = new Map()\n\n    requestMap.set('accountId', accountId)\n    if (orderHash)\n      requestMap.set('orderHash', orderHash)\n    if (clientOrderId)\n      requestMap.set('clientOrderId', clientOrderId)\n\n    const eddsaSig = getEdDSASig(localVarAxiosArgs.options.method, this.basePath, '/api/v3/order', requestMap, PrivateKey)\n\n    console.log(localVarAxiosArgs)\n\n    localVarAxiosArgs.options.headers['X-API-KEY'] = apiKey\n    localVarAxiosArgs.options.headers['X-API-SIG'] = eddsaSig\n\n    const request = createRequestFunction(\n      localVarAxiosArgs,\n      globalAxios,\n      this.basePath,\n      this.conf\n    )\n\n    return await request()\n\n  }\n\n}\n\nexport { AuthHasEddsaSigApi }\n","import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'\nimport { createRequestFunction } from 'lightcone_api/api/common'\n\nimport { GetApiKeyRequest, AuthApiKeyApiAxiosParamCreator } from 'lightcone_api/api'\n\nimport {\n  BASE_PATH,\n  COLLECTION_FORMATS,\n  RequestArgs,\n  BaseAPI,\n  RequiredError,\n} from 'lightcone_api/api/base'\n\nimport * as api from 'lightcone_api/api'\n\nimport { getEdDSASig, getEdDSASigWithPoseidon, getEcDSASig } from 'lightcone_api/api_wrapper/sign_tools'\n\nclass AuthApiKeyApi {\n\n  localVarAxiosParamCreator: any\n  conf: any\n\n  constructor(conf: any) {\n    this.conf = conf\n    this.localVarAxiosParamCreator = api.AuthApiKeyApiAxiosParamCreator(conf)\n  }\n\n  // getOrders: async (accountId: number, market?: string, start?: number, end?: number, side?: 'BUY' | 'SELL', \n  // status?: 'processing' | 'processed' | 'failed' | 'cancelled' | 'cancelling' | 'expired', limit?: number, \n  // offset?: number, orderTypes?: 'LIMIT_ORDER' | 'MAKER_ONLY' | 'TAKER_ONLY' | 'class_amm', options: any = {})\n  async getOrders(accountId: number, apiKey: string) {\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrders(accountId)\n\n    const request = createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, this.conf)\n\n    localVarAxiosArgs.options.headers['X-API-KEY'] = apiKey\n\n    const response = await request()\n\n    return response\n  }\n\n  async getUserTrades(accountId: number, apiKey: string) {\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getUserTrades(accountId)\n\n    const request = createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, this.conf)\n\n    localVarAxiosArgs.options.headers['X-API-KEY'] = apiKey\n\n    const response = await request()\n\n    return response\n  }\n\n  async getNextStorageId(accountId: number, sellTokenId: number, apiKey: string) {\n\n    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getNextStorageId(accountId, sellTokenId)\n\n    const request = createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, this.conf)\n\n    localVarAxiosArgs.options.headers['X-API-KEY'] = apiKey\n\n    const response = await request()\n\n    return response\n  }\n\n}\n\nexport { AuthApiKeyApi }\n","import * as api from 'lightcone_api/api'\nimport { TickerData, DepthData, TradesData } from 'defs/exchange_defs'\nimport { getLocaleDt } from 'utils/dt_tools'\n\nimport BigNumber from 'bignumber.js'\n\nclass AuthNoKeyApi extends api.AuthNoKeyApi {\n\n    public async getMarketTicker(market: string[], options?: any) {\n        const market_str = market.join(',')\n        const raw_data = (await super.getTicker(market_str, options)).data['tickers']\n        var tick_map: any = {}\n        raw_data.forEach((item: any, ind: number, arr: any) => {\n            const tick: TickerData = {\n                date_time: new Date(parseInt(item[1])),\n                base_token_amt: parseInt(item[2]),\n                quote_token_amt: parseInt(item[3]),\n                open: parseFloat(item[4]),\n                high: parseFloat(item[5]),\n                low: parseFloat(item[6]),\n                close: parseFloat(item[7]),\n                count: parseInt(item[8]),\n                bid: parseFloat(item[9]),\n                ask: parseFloat(item[10]),\n            }\n            tick_map[item[0]] = tick\n        })\n\n        return tick_map\n    }\n\n    private genAB(data: any[], isReverse: boolean = false) {\n\n        var ab_arr: any[] = []\n        var amtTotal = 0\n\n        var ab_prices : any[] = []\n        var ab_amtTotals :any [] = []\n        \n        data.forEach((item: any, ind: number, arr: any) => {\n            const price = parseFloat(item[0])\n            const amt = new BigNumber(item[1]).dividedBy(1e+18).toNumber()\n            amtTotal += amt\n            ab_arr.push({\n                price: price,\n                amt: amt,\n                amtTotal: amtTotal,\n            })\n            ab_prices.push(price)\n            ab_amtTotals.push(amtTotal)\n        })\n\n        if (isReverse) {\n            ab_arr.reverse()\n            ab_prices.reverse()\n            ab_amtTotals.reverse()\n        }\n\n        return { ab_arr, ab_prices, ab_amtTotals }\n\n    }\n\n    public async getDepthData(market: string, level: number = 2, limit: number = 50, options?: any) {\n        const raw_data = (await super.getDepth(market, level, limit, options)).data\n        const bids = this.genAB(raw_data['bids'])\n        const asks = this.genAB(raw_data['asks'], true)\n\n        const depth: DepthData = {\n            version: parseInt(raw_data['version']),\n            date_time: new Date(raw_data['timestamp']),\n            bids: bids.ab_arr,\n            bids_prices: bids.ab_prices,\n            bids_amtTotals: bids.ab_amtTotals,\n            asks: asks.ab_arr,\n            asks_prices: asks.ab_prices,\n            asks_amtTotals: asks.ab_amtTotals,\n        }\n        return depth\n    }\n\n    public async getMarketTradeData(market: string, limit: number = 20, options?: any) {\n        const raw_data = (await super.getMarketTrade(market, limit, options)).data\n        const trades: TradesData = {\n            totalNum: parseInt(raw_data['totalNum']),\n            trades: raw_data['trades'],\n        }\n        return trades\n    }\n\n}\n\nexport { AuthNoKeyApi }\n","\nimport * as api from 'lightcone_api/api'\n\nconst conf = new api.Configuration()\nconf.basePath = process.env.REACT_APP_API_URL || 'https://uat3.loopring.io'\n\nexport default conf\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nexport enum TradingInterval {\n  min1 = '1min',\n  min5 = '5min',\n  min15 = '15min',\n  min30 = '30min',\n  hr1 = '1hr',\n  hr2 = '2hr',\n  hr4 = '4hr',\n  hr12 = '12hr',\n  d1 = '1d',\n  w1 = '1w',\n}\n\nexport interface TradingInfo {\n  symbol: string\n  symbol_base: string\n  symbol_quote: string\n  interval: TradingInterval\n  markets: any[]\n  refreshRate: number\n  refreshRateSlow: number\n}\n\nconst getBaseQuote = (symbol: string) => {\n  const ind = symbol.indexOf('-')\n  const symbol_base = symbol.substr(ind + 1)\n  const symbol_quote = symbol.substr(0, ind)\n  return {symbol_base, symbol_quote}\n}\n\nconst defaultSymbol = process.env.REACT_APP_TEST_SYMBOL ? process.env.REACT_APP_TEST_SYMBOL : 'LRC-USDT'\nconst defaultInterval = process.env.REACT_APP_TEST_INTERVAL ? process.env.REACT_APP_TEST_INTERVAL : TradingInterval.hr1\n\nconst { symbol_base, symbol_quote } = getBaseQuote(defaultSymbol)\n\nconst initialState = {\n  symbol: defaultSymbol,\n  symbol_base: symbol_base,\n  symbol_quote: symbol_quote,\n  interval: defaultInterval,\n  markets: [],\n  refreshRate: 1000,\n  refreshRateSlow: 3000,\n} as TradingInfo\n\nconst tradingSlice = createSlice({\n  name: 'trading',\n  initialState,\n  reducers: {\n    changeSymbol(state, action: PayloadAction<any>) {\n      state.symbol = action.payload\n      const { symbol_base, symbol_quote } = getBaseQuote(state.symbol)\n      state.symbol_base = symbol_base\n      state.symbol_quote = symbol_quote\n    },\n    changeTradingInterval(state, action: PayloadAction<any>) {\n      state.interval = action.payload\n    },\n    changeRefreshRate(state, action: PayloadAction<any>) {\n      state.refreshRate = parseInt(action.payload)\n    },\n    changeRefreshRateSlow(state, action: PayloadAction<any>) {\n      state.refreshRateSlow = parseInt(action.payload)\n    },\n    setMarkets(state, action: PayloadAction<any>) {\n      state.markets = action.payload\n    },\n  },\n})\n\nexport const { changeSymbol, changeTradingInterval, setMarkets } = tradingSlice.actions\nexport default tradingSlice\n","import { AuthHasEcdsaSigApi } from './AuthHasEcdsaSigApi'\nimport { AuthHasEddsaSigApi } from './AuthHasEddsaSigApi'\nimport { AuthApiKeyApi } from './AuthApiKeyApi'\nimport { AuthNoKeyApi } from './AuthNoKeyApi'\n\nimport conf from './global'\n\nconst authHasEcdsaSigApi = new AuthHasEcdsaSigApi(conf)\nconst authHasEddsaSigApi = new AuthHasEddsaSigApi(conf)\nconst authApiKeyApi = new AuthApiKeyApi(conf)\nconst authNoKeyApi = new AuthNoKeyApi(conf)\n\nexport { AuthHasEcdsaSigApi, AuthHasEddsaSigApi, AuthApiKeyApi, AuthNoKeyApi, }\n\nexport { authHasEcdsaSigApi, authHasEddsaSigApi, authApiKeyApi, authNoKeyApi, }\n","import { useEffect } from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nimport { RootState } from 'stores'\n\nimport { authNoKeyApi } from 'lightcone_api/api_wrapper'\n\nimport { setMarkets } from 'stores/reducers/trading_reducer'\n\nexport function useTradingInfo() {\n\n    const tradingInfo = useSelector((state: RootState) => state.trading)\n\n    return tradingInfo\n\n}\n\nexport function useExchangeMarkets() {\n\n    console.log('app useExchangeMarkets')\n\n    const dispatch = useDispatch()\n\n    useEffect(() => {\n\n        authNoKeyApi.getMarkets().then((response) => {\n    \n            var symbols: any[] = []\n            \n            response.data.markets.forEach((item: any, index: number, array: any)=>{\n                symbols.push({'title': item.market, 'link': item.market})\n            })\n    \n            dispatch(setMarkets(symbols))\n    \n        }, (reject) => {\n\n            console.log(reject)\n    \n        })\n\n    })\n\n}\n\nexport function useTokenTicker(market: string) {\n\n    console.log('app useTokenTicker')\n\n    const dispatch = useDispatch()\n\n    useEffect(() => {\n\n        authNoKeyApi.getTicker(market).then((response) => {\n            \n            console.log(response.data)\n    \n        }, (reject) => {\n\n            console.log(reject)\n    \n        })\n\n    })\n\n}\n","import i18n from 'plugins/i18n'\n\nexport function getLocaleDtFromTs(ts: number | string, locale: string = i18n.language) {\n    if (typeof(ts) === 'string') {\n        ts = parseInt(ts)\n    }\n    const newLocale = locale.replace('_', '-')\n    const dt = new Date(ts).toLocaleString(newLocale)\n    return dt\n}\n\nexport function getLocaleDt(dt?: Date, locale: string = i18n.language) {\n    if (dt) {\n        const newLocale = locale.replace('_', '-')\n        return dt.toLocaleString(newLocale)\n    }\n    return ''\n}\n","import { useEffect, useState } from 'react'\nimport { useTranslation } from 'react-i18next'\nimport { useLocation } from 'react-router-dom'\nimport styles from './basic_info.module.scss'\n\nimport SymbolList from 'components/selects/SymbolList'\n\nimport { useTradingInfo } from 'hooks/trading_hook'\n\nimport { authNoKeyApi } from 'lightcone_api/api_wrapper'\nimport { TickerData } from 'defs/exchange_defs'\n\nimport { getLocaleDt } from 'utils/dt_tools'\n\nexport interface BasicInfoPanelProps {\n}\n\nconst BasicInfoPanel = ({ }: BasicInfoPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const [ticker, setTicker] = useState<TickerData>()\n\n    const location = useLocation()\n\n    const tradingInfo = useTradingInfo()\n\n    useEffect(() => {\n\n        const id = setInterval(async () => {\n            const tick_data = (await authNoKeyApi.getMarketTicker([tradingInfo.symbol]))\n            setTicker(tick_data[tradingInfo.symbol])\n        }, tradingInfo.refreshRate)\n\n        return () => clearInterval(id)\n    })\n\n    return (\n        <div className='draggable_panel'>\n            <div className={styles.basic_info_panel}>\n                <div className={styles.basic_info_row}><SymbolList location={location} listData={tradingInfo.markets}></SymbolList></div>\n                <div className={styles.basic_info_row}><div>{getLocaleDt(ticker?.date_time)}</div></div>\n                <div className={styles.basic_info_row}><div>{t('pages:basic_24hrs_updown')}</div><div className={styles.basic_info_row2}></div></div>\n                <div className={styles.basic_info_row}><div>{t('pages:basic_24hrs_low')}</div><div className={styles.basic_info_row2}>{ticker?.low}</div></div>\n                <div className={styles.basic_info_row}><div>{t('pages:basic_24hrs_high')}</div><div className={styles.basic_info_row2}>{ticker?.high}</div></div>\n                <div className={styles.basic_info_row}><div>{t('pages:basic_24hrs_volume')}({tradingInfo.symbol_quote})</div><div className={styles.basic_info_row2}>{ticker?.quote_token_amt}</div></div>\n                <div className={styles.basic_info_row}><div>{t('pages:basic_24hrs_volume')}({tradingInfo.symbol_base})</div><div className={styles.basic_info_row2}>{ticker?.base_token_amt}</div></div>\n            </div>\n        </div>\n    )\n}\n\nexport default BasicInfoPanel\n","import BasicInfoPanel from './BasicInfoPanel'\n\nexport default BasicInfoPanel\n","import OrderActionsPanel from './OrderActionsPanel'\n\nexport default OrderActionsPanel\n","import React from 'react'\nimport { useTranslation } from 'react-i18next'\nimport styles from './order_actions.module.scss'\n\nimport { option } from './mock_data'\n\nexport interface OrderActionsPanelProps {\n}\n\nconst OrderActionsPanel = ({ }: OrderActionsPanelProps) => {\n\n    const { t } = useTranslation()\n\n    return (\n        <div className='draggable_panel'>\n            <div className='draggable_header' >\n            </div>\n        </div>\n    );\n};\n\nexport default OrderActionsPanel\n","import React from 'react'\nimport styled from 'styled-components'\n\nconst Styles = styled.div`\n\n  overflow-y: scroll;\n  height: 100%;\n  \n  &::-webkit-scrollbar {\n    display:none;\n  }\n\n  table {\n    border-spacing: 0;\n  \n    height: 500px;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding-top: 3px;\n\n      text-align: right;\n\n      :last-child {\n      }\n    }\n\n    .ab_col1 {\n      float: left;\n      width: 40%;\n    }\n  \n    .ab_col2 {\n      padding-left: 20px;\n      float: left;\n      width: 30%;\n    }\n  \n    .ab_col3 {\n      padding-left: 20px;\n      float: left;\n      width: 30%;\n    }\n  \n    .ask_row {\n      color: #00BBA8;\n    }\n\n    .bid_row {\n      color: #FF5677;\n    }\n\n  }\n`\nexport interface OrderBookTableProps {\n  depth: any\n}\n\nconst Table = ({ depth }: OrderBookTableProps) => {\n\n  return (\n    <Styles>\n      <table>\n        <thead>\n        </thead>\n        <tbody>\n          {\n            depth && depth.asks &&\n            depth.asks.map((ask: any, ask_index: number) => {\n              return (\n                <tr className={'ask_row'} key={ask_index}>\n                  <td className={'ab_col1'}>{ask.price}</td>\n                  <td className={'ab_col2'}>{ask.amt.toFixed(4)}</td>\n                  <td className={'ab_col3'}>{ask.amtTotal.toFixed(4)}</td>\n                </tr>\n              )\n            })\n          }\n          {\n            depth && depth.bids &&\n            depth.bids.map((bid: any, bid_index: number) => {\n              return (\n                <tr className={'bid_row'} key={bid_index}>\n                  <td className={'ab_col1'}>{bid.price}</td>\n                  <td className={'ab_col2'}>{bid.amt.toFixed(4)}</td>\n                  <td className={'ab_col3'}>{bid.amtTotal.toFixed(4)}</td>\n                </tr>\n              )\n            })\n          }\n        </tbody>\n      </table>\n    </Styles>\n  )\n}\n\nexport default Table\n","import OrderBookTable from './OrderBookTable'\n\nexport default OrderBookTable\n","import OrderBookPanel from './OrderBookPanel'\n\nexport default OrderBookPanel\n","import { useTranslation } from 'react-i18next'\n\nimport { useTheme } from 'styled-components'\n\nimport IconBtn from 'components/btns/IconBtn'\nimport OrderBookTable from 'components/tables/OrderBookTable'\n\nexport interface OrderBookPanelProps {\n    depth: any\n}\n\nconst OrderBookPanel = ({ depth }: OrderBookPanelProps) => {\n\n    const theme: any = useTheme()\n\n    const { t } = useTranslation()\n\n    const onOrderBookTypeChange = (event: any) => {\n        console.log('onOrderBookTypeChange')\n    }\n\n    return (\n        <div className='draggable_panel'>\n            <div className='draggable_header' >\n                {t('pages:order_book_title')}\n            </div>\n            <IconBtn marginLeft={'12px'} onClick={onOrderBookTypeChange} src={theme.imgs.obt1_img} w={'15px'} h={'10px'} />\n            <IconBtn marginLeft={'18px'} onClick={onOrderBookTypeChange} src={theme.imgs.obt2_img} w={'15px'} h={'10px'} />\n            <IconBtn marginLeft={'18px'} onClick={onOrderBookTypeChange} src={theme.imgs.obt3_img} w={'15px'} h={'10px'} />\n            <OrderBookTable depth={depth} />\n        </div>\n    );\n};\n\nexport default OrderBookPanel\n","import styled from 'styled-components'\n\nexport interface TabProps {\n    active: boolean\n    isRight? : boolean\n}\n\nexport const Tabs = styled.div`\n  overflow: hidden;\n  background: #2A2D34;\n  height: 40px;\n`\n\nexport const Tab = styled.button<TabProps>`\n  float: ${props => (props.isRight ? 'right' : 'float')};\n  border: none;\n  outline: none;\n  cursor: pointer;\n  width: 120px;\n  // position: relative;\n\n  margin-right: 0.1em;\n  font-size: 1em;\n  border-top: ${props => (props.active ? '2px solid #5773FF' : '')};\n  color: ${props => (props.active ? '#FFFFFF' : '#76808F')};\n  background-color: ${props => (props.active ? '#181C20' : '#2A2D34')};\n  height: ${props => (props.active ? '40px' : '36px; top:4px')};\n  transition: background-color 0.5s ease-in-out;\n\n  :hover {\n    border-top: 2px solid #5773FF;\n    color: #FFFFFF;\n    background-color: #181C20;\n  }\n`\n\nexport const Content = styled.div<TabProps>`\n  height: 100%;\n  ${props => (props.active ? '' : 'display:none;')}\n`\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport BigNumber from 'bignumber.js'\nimport { useTable } from 'react-table'\nimport { getLocaleDtFromTs } from 'utils/dt_tools'\n\nconst Styles = styled.div`\n\n  overflow-y: scroll;\n  height: 100%;\n  \n  &::-webkit-scrollbar {\n    display:none;\n  }\n\n  table {\n    border-spacing: 0;\n  \n    height: 500px;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding-top: 3px;\n\n      text-align: right;\n\n      :last-child {\n      }\n    }\n\n    .ask_row {\n      color: #00BBA8;\n    }\n\n    .bid_row {\n      color: #FF5677;\n    }\n\n  }\n`\nexport interface OrderRecordTableProps {\n  orders: any\n  cols: any\n}\n\nconst getAmt = (rawAmt: any, precision: number = 4) => {\n  return new BigNumber(rawAmt).dividedBy(1e+18).toNumber().toFixed(precision)\n}\n\nconst OrderRecordTable = ({ orders, cols }: OrderRecordTableProps) => {\n\n  return (\n    <Styles>\n      <table>\n        <thead>\n          <tr>\n            {\n              cols.map((col: any, order_index: number) => {\n                return (\n                  <th key={order_index}>\n                    {col.Header}\n                  </th>\n                )\n              })\n            }\n          </tr>\n        </thead>\n        <tbody>\n          {\n            orders && orders.orders &&\n            orders.orders.map((order: any, order_index: number) => {\n              return (\n                <tr key={order_index}>\n                  <td>{getLocaleDtFromTs(order.validity.start * 1000)}</td>\n                  <td>{order.market}</td>\n                  <td>{order.orderType}</td>\n                  <td>{order.side}</td>\n                  <td>{order.price}</td>\n                  <td>{order.volumes.quoteAmount}</td>\n                  <td>{order.status}</td>\n                  <td></td>\n                </tr>\n              )\n            })\n          }\n        </tbody>\n      </table>\n    </Styles>\n  )\n}\n\nexport default OrderRecordTable\n","import OrderRecordTable from './OrderRecordTable'\n\nexport default OrderRecordTable\n","import OrderRecordsPanel from './OrderRecordsPanel'\n\nexport default OrderRecordsPanel\n","import { useState, useEffect } from 'react'\nimport { useTranslation } from 'react-i18next'\n\nimport { Tabs, Tab, Content } from 'components/tabs/HTabs'\nimport OrderRecordTable from 'components/tables/OrderRecordTable'\n\nimport { useTradingInfo } from 'hooks/trading_hook'\nimport { useAccount } from 'hooks/account_hook'\n\nimport { authApiKeyApi } from 'lightcone_api/api_wrapper'\nimport { OrdersData } from 'defs/exchange_defs'\n\nexport interface OrderRecordsPanelProps {\n}\n\nconst OrderRecordsPanel = ({ }: OrderRecordsPanelProps) => {\n\n    const tradingInfo = useTradingInfo()\n\n    const acc = useAccount()\n\n    const { t } = useTranslation()\n\n    const [orders, setOrders] = useState<OrdersData>()\n\n    const [active, setActive] = useState('0')\n    const handleClick = (e: any) => {\n        const index = e.target.id\n        if (index !== active) {\n            setActive(index)\n        }\n    }\n\n    const cols = [\n        {\n            Header: t('pages:order_col_1'),\n            accessor: 'order_col_1',\n        },\n        {\n            Header: t('pages:order_col_2'),\n            accessor: 'order_col_2',\n        },\n        {\n            Header: t('pages:order_col_3'),\n            accessor: 'order_col_3',\n        },\n        {\n            Header: t('pages:order_col_4'),\n            accessor: 'order_col_4',\n        },\n        {\n            Header: t('pages:order_col_5'),\n            accessor: 'order_col_5',\n        },\n        {\n            Header: t('pages:order_col_6'),\n            accessor: 'order_col_6',\n        },\n        {\n            Header: t('pages:order_col_7'),\n            accessor: 'order_col_7',\n        },\n        {\n            Header: t('pages:order_col_8'),\n            accessor: 'order_col_8',\n        },\n    ]\n\n    useEffect(() => {\n\n        const id = setInterval(async () => {\n            try {\n                const orders_data = (await authApiKeyApi.getOrders(acc.account.accountId, acc.account.apiKey)).data\n                setOrders(orders_data)\n            } catch(err) {\n                return\n            }\n        }, tradingInfo.refreshRateSlow)\n\n        return () => clearInterval(id)\n    })\n\n    return (\n        <div className='draggable_panel'>\n            <div className='draggable_header' >\n                {t('pages:order_record_title')}\n            </div>\n\n            <Tabs>\n                <Tab onClick={handleClick} active={active === '0'} id={'0'}>\n                    {t('pages:order_record_current')}\n                </Tab>\n\n                <Tab onClick={handleClick} active={active === '1'} id={'1'}>\n                    {t('pages:order_record_history')}\n                </Tab>\n            </Tabs>\n            <>\n                <Content active={active === '0'}>\n                    <OrderRecordTable cols={cols} orders={orders}/>\n                </Content>\n                <Content active={active === '1'}>\n                    <OrderRecordTable cols={cols} orders={orders}/>\n                </Content>\n            </>\n        </div>\n    );\n};\n\nexport default OrderRecordsPanel\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport BigNumber from 'bignumber.js'\nimport { getLocaleDtFromTs } from 'utils/dt_tools'\n\nconst Styles = styled.div`\n\n  overflow-y: scroll;\n  height: 100%;\n  \n  &::-webkit-scrollbar {\n    display:none;\n  }\n\n  table {\n    border-spacing: 0;\n  \n    height: 500px;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding-top: 3px;\n\n      text-align: right;\n\n      :last-child {\n      }\n    }\n\n    .ask_row {\n      color: #00BBA8;\n    }\n\n    .bid_row {\n      color: #FF5677;\n    }\n\n  }\n`\nexport interface TradeRecordTableProps {\n  trades: any\n  cols: any\n}\n\nconst getAmt = (rawAmt: any, precision: number = 4) => {\n  return new BigNumber(rawAmt).dividedBy(1e+18).toNumber().toFixed(precision)\n}\n\nconst TradeRecordTable = ({ trades, cols }: TradeRecordTableProps) => {\n\n  return (\n    <Styles>\n      <table>\n        <thead>\n          <tr>\n            {\n              cols.map((col: any, trade_index: number) => {\n                return (\n                  <th key={trade_index}>\n                    {col.Header}\n                  </th>\n                )\n              })\n            }\n          </tr>\n        </thead>\n        <tbody>\n          {\n            trades && trades.trades &&\n            trades.trades.map((trade: any, trade_index: number) => {\n              return (\n                <tr key={trade_index}>\n                  <td>{trade[4]}</td>\n                  <td>{(parseInt(trade[3]) / 1e18).toFixed(4)}</td>\n                  <td>{getLocaleDtFromTs(trade[0])}</td>\n                </tr>\n              )\n            })\n          }\n        </tbody>\n      </table>\n    </Styles>\n  )\n}\n\nexport default TradeRecordTable\n","import TradeRecordTable from './TradeRecordTable'\n\nexport default TradeRecordTable\n","import TradeRecordsPanel from './TradeRecordsPanel'\n\nexport default TradeRecordsPanel\n","import { useState, useEffect } from 'react'\nimport { useTranslation } from 'react-i18next'\n\nimport { Tabs, Tab, Content } from 'components/tabs/HTabs'\nimport TradeRecordTable from 'components/tables/TradeRecordTable'\n\nimport { useTradingInfo } from 'hooks/trading_hook'\n\nimport { authNoKeyApi } from 'lightcone_api/api_wrapper'\nimport { TradesData } from 'defs/exchange_defs'\n\nexport interface TradeRecordsPanelProps {\n}\n\nconst TradeRecordsPanel = ({ }: TradeRecordsPanelProps) => {\n\n    const { t } = useTranslation()\n\n    const [active, setActive] = useState('0')\n\n    const [trades, setTrades] = useState<TradesData>()\n\n    const tradingInfo = useTradingInfo()\n\n    const cols = [\n        {\n            Header: t('pages:trade_col_1') + '(' + tradingInfo.symbol_quote + ')',\n            accessor: 'trade_col_1',\n        },\n        {\n            Header: t('pages:trade_col_2'),\n            accessor: 'trade_col_2',\n        },\n        {\n            Header: t('pages:trade_col_3'),\n            accessor: 'trade_col_3',\n        },\n    ]\n\n    useEffect(() => {\n\n        const id = setInterval(async () => {\n            const trades_data = (await authNoKeyApi.getMarketTradeData(tradingInfo.symbol))\n            setTrades(trades_data)\n        }, tradingInfo.refreshRate)\n\n        return () => clearInterval(id)\n    })\n\n    const handleClick = (e: any) => {\n        const index = e.target.id\n        if (index !== active) {\n            setActive(index)\n        }\n    }\n\n    return (\n        <div className='draggable_panel'>\n            <div className='draggable_header' >\n                {t('pages:trade_record_title')}\n            </div>\n\n            <Tabs>\n                <Tab onClick={handleClick} active={active === '0'} id={'0'}>\n                    {t('pages:trade_record_latest')}\n                </Tab>\n\n                <Tab onClick={handleClick} active={active === '1'} id={'1'}>\n                    {t('pages:trade_record_mine')}\n                </Tab>\n            </Tabs>\n            <>\n                <Content active={active === '0'}>\n                    <TradeRecordTable cols={cols} trades={trades}/>\n                </Content>\n                <Content active={active === '1'}>\n                    <TradeRecordTable cols={cols} trades={trades}/>\n                </Content>\n            </>\n        </div>\n    )\n}\n\nexport default TradeRecordsPanel\n","import TradingChart from './TradingChart'\n\nexport default TradingChart\n","import { useEffect, useState } from 'react'\n\nimport ReactECharts from 'echarts-for-react'\n\nexport interface TradingChartProps {\n    refreshRate: number,\n    defaultOption: any,\n    getOption: any,\n}\n\nconst TradingChart = ({ refreshRate, defaultOption, getOption }: TradingChartProps) => {\n\n    const [option, setOption] = useState(defaultOption)\n\n    useEffect(() => {\n        const id = setInterval(async () => {\n            const opt = await getOption()\n            setOption(opt)\n        }, refreshRate)\n\n        return () => clearInterval(id)\n    })\n\n    const onChartReadyCallback = () => {\n    }\n\n    return (\n        <ReactECharts\n            style={{ height: '100%', width: '100%' }}\n            option={option}\n            notMerge={true}\n            lazyUpdate={true}\n            onChartReady={onChartReadyCallback}\n        />\n    )\n}\n\nexport default TradingChart\n","import * as echarts from 'echarts'\n\nimport { getLocaleDtFromTs } from './dt_tools'\n\nimport { DepthData } from 'defs/exchange_defs'\nimport { type } from 'os';\n\nexport function getKlineSign(data: any, dataIndex: number, openVal: number, closeVal: number, closeDimIdx: number) {\n    var sign;\n    if (openVal > closeVal) {\n        sign = -1;\n    }\n    else if (openVal < closeVal) {\n        sign = 1;\n    }\n    else {\n        sign = dataIndex > 0\n            // If close === open, compare with close of last record\n            ? (data[dataIndex - 1][closeDimIdx] <= closeVal ? 1 : -1)\n            // No record of previous, set to be positive\n            : 1\n    }\n\n    return sign;\n}\n\nexport const genOHLC = (rawData: any[]) => {\n    var data: any[] = []\n\n    rawData = rawData.reverse()\n\n    for (var i = 0; i < rawData.length; i++) {\n        const ts = rawData[i][0]\n\n        const close_ind = 3\n\n        const open = parseFloat(rawData[i][2]).toFixed(6)\n        const high = parseFloat(rawData[i][4]).toFixed(6)\n        const low = parseFloat(rawData[i][5]).toFixed(6)\n        const close = parseFloat(rawData[i][close_ind]).toFixed(6)\n\n        const volume = parseInt(rawData[i][6])\n        const amt = parseFloat(rawData[i][7]).toFixed(2)\n\n        data[i] = [\n            getLocaleDtFromTs(ts),\n            open, // open\n            high, // highest\n            low, // lowest\n            close,  // close\n            volume,\n            getKlineSign(data, i, Number(open), Number(close), close_ind) // sign\n        ]\n    }\n\n    return data\n}\n\nexport const genOption = (data: any, upColor: string, upBorderColor: string, downColor: string, downBorderColor: string) => {\n\n    return {\n        backgroundColor: '#111111',\n        dataset: {\n            source: data,\n        },\n        title: {\n        },\n        tooltip: {\n            trigger: 'axis',\n            axisPointer: {\n                animation: false,\n                type: 'cross',\n                lineStyle: {\n                    color: '#444444',\n                    width: 2,\n                    opacity: 1\n                }\n            }\n        },\n        toolbox: {\n            feature: {\n            }\n        },\n        grid: [\n            {\n                left: '5%',\n                right: '5%',\n                bottom: 200\n            },\n            {\n                left: '5%',\n                right: '5%',\n                height: 80,\n                bottom: 80\n            }\n        ],\n        xAxis: [\n            {\n                type: 'category',\n                scale: true,\n                boundaryGap: false,\n                axisLine: { onZero: false },\n                splitLine: {\n                    show: true,\n                    lineStyle: {\n                        color: ['#373739']\n                    }\n                },\n                splitNumber: 20,\n                min: 'dataMin',\n                max: 'dataMax'\n            },\n            {\n                type: 'category',\n                gridIndex: 1,\n                scale: true,\n                boundaryGap: false,\n                axisLine: { onZero: false },\n                axisTick: { show: false },\n                splitLine: { show: false },\n                axisLabel: { show: false },\n                splitNumber: 50,\n                min: 'dataMin',\n                max: 'dataMax'\n            }\n        ],\n        yAxis: [\n            {\n                scale: true,\n                splitArea: {\n                    show: false\n                }\n            },\n            {\n                scale: true,\n                gridIndex: 1,\n                splitNumber: 2,\n                axisLabel: { show: false },\n                axisLine: { show: false },\n                axisTick: { show: false },\n                splitLine: { show: false }\n            }\n        ],\n        dataZoom: [\n            {\n                type: 'inside',\n                xAxisIndex: [0, 1],\n                start: 10,\n                end: 100\n            },\n            {\n                show: false,\n                xAxisIndex: [0, 1],\n                type: 'slider',\n                bottom: 10,\n                start: 10,\n                end: 100\n            }\n        ],\n        visualMap: {\n            show: false,\n            seriesIndex: 1,\n            dimension: 6,\n            pieces: [{\n                value: 1,\n                color: upColor\n            }, {\n                value: -1,\n                color: downColor\n            }]\n        },\n        series: [\n            {\n                type: 'candlestick',\n                itemStyle: {\n                    color: upColor,\n                    color0: downColor,\n                    borderColor: upBorderColor,\n                    borderColor0: downBorderColor\n                },\n                encode: {\n                    x: 0,\n                    y: [1, 4, 3, 2]\n                }\n            },\n            {\n                name: 'Volume',\n                type: 'bar',\n                xAxisIndex: 1,\n                yAxisIndex: 1,\n                itemStyle: {\n                    color: '#7fbe9e'\n                },\n                large: true,\n                encode: {\n                    x: 0,\n                    y: 5\n                }\n            }\n        ]\n    }\n\n}\n\nexport const genDepthOption = (data: DepthData, upColor: string, downColor: string, alpha: string = '00') => {\n    \n    if (!data) {\n        return {}\n    }\n\n    var a_xdata = [...data.asks_prices].reverse()\n    var a_ydata = [...data.asks_amtTotals].reverse()\n    var b_xdata = [...data.bids_prices].reverse()\n    var b_ydata = [...data.bids_amtTotals].reverse()\n\n    //console.log('a_xdata:', a_xdata)\n    //console.log('b_xdata:', b_xdata)\n\n    const xdata = b_xdata?.concat(a_xdata)\n    const new_b_ydata = b_ydata.concat(new Array(a_ydata.length).fill(0))\n    const new_a_ydata = new Array(b_ydata.length).fill(0).concat(a_ydata)\n\n    return {\n        tooltip: {\n            trigger: 'axis',\n            position: function (pt: any) {\n                return [pt[0], '10%'];\n            }\n        },\n        title: {\n        },\n        toolbox: {\n        },\n        xAxis: [{\n            type: 'category',\n            boundaryGap: false,\n            data: xdata,\n            min: 'dataMin',\n            max: 'dataMax'\n        }],\n        yAxis: {\n            type: 'value',\n            boundaryGap: [0, '100%']\n        },\n        dataZoom: [{\n            type: 'inside',\n            start: 0,\n            end: 1000\n        }, {\n            show: false,\n            start: 0,\n            end: 1000\n        }],\n        series: [\n            {\n                name: 'ask',\n                type: 'line',\n                symbol: 'none',\n                sampling: 'lttb',\n                itemStyle: {\n                    color: upColor + alpha\n                },\n                areaStyle: {\n                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{\n                        offset: 0,\n                        color: upColor\n                    }, {\n                        offset: 1,\n                        color: upColor\n                    }])\n                },\n                data: new_a_ydata\n            },\n            {\n                name: 'bid',\n                type: 'line',\n                symbol: 'none',\n                sampling: 'lttb',\n                itemStyle: {\n                    color: downColor + alpha\n                },\n                areaStyle: {\n                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{\n                        offset: 0,\n                        color: downColor\n                    }, {\n                        offset: 1,\n                        color: downColor\n                    }])\n                },\n                data: new_b_ydata\n            }\n        ]\n    }\n}","import React, { useEffect, useState } from 'react'\nimport { useTranslation } from 'react-i18next'\n\nimport { useTheme } from 'styled-components'\nimport styled from 'styled-components'\n\nimport TradingChart from 'components/charts/TradingChart'\n\nimport { authNoKeyApi } from 'lightcone_api/api_wrapper'\n\nimport { genOHLC, genOption, genDepthOption } from 'utils/kline_tools'\n\nimport { useTradingInfo } from 'hooks/trading_hook'\n\nimport { Tabs, Tab, Content } from 'components/tabs/HTabs'\n\nconst Title = styled.div`\n    float: left;\n`\n\nexport interface ChartWrapperProps {\n    depth: any\n}\n\nconst TradingChartPanel = ({ depth }: ChartWrapperProps) => {\n\n    const theme: any = useTheme()\n\n    const tradingInfo = useTradingInfo()\n\n    const upColor = theme.colors.upColor\n    const upBorderColor = theme.colors.upBorderColor\n    const downColor = theme.colors.downColor\n    const downBorderColor = theme.colors.downBorderColor\n\n    const { t } = useTranslation()\n\n    const [active, setActive] = useState('0')\n    const handleClick = (e: any) => {\n        const index = e.target.id\n        if (index !== active) {\n            setActive(index)\n        }\n    }\n\n    const defaultOption = genOption([], upColor, upBorderColor, downColor, downBorderColor)\n    const defaultDepthOption = genDepthOption(depth, upColor, downColor)\n\n    const getOption = async () => {\n        const data1 = await authNoKeyApi.getCandlestick(tradingInfo.symbol, tradingInfo.interval)\n        var data = []\n        if (data1.status == 200) {\n            data = genOHLC(data1.data['candlesticks'])\n        }\n        return genOption(data, upColor, upBorderColor, downColor, downBorderColor)\n    }\n\n    const getDepthOption = async () => {\n        return genDepthOption(depth, upColor, downColor)\n    }\n\n    return (\n        <div className='draggable_panel'>\n            <div className='draggable_header' >\n                <Title>{t('pages:chart_title')}</Title>\n            </div>\n\n            <Tabs>\n                <Tab onClick={handleClick} active={active === '1'} isRight={true} id={'1'}>\n                    {t('pages:chart_toggle_right')}\n                </Tab>\n                <Tab onClick={handleClick} active={active === '0'} isRight={true} id={'0'}>\n                    {t('pages:chart_toggle_left')}\n                </Tab>\n            </Tabs>\n\n            <>\n                <Content active={active === '0'}>\n                    <TradingChart refreshRate={tradingInfo.refreshRate} defaultOption={defaultOption} getOption={getOption} />\n                </Content>\n                <Content active={active === '1'}>\n                    <TradingChart refreshRate={tradingInfo.refreshRate} defaultOption={defaultDepthOption} getOption={getDepthOption} />\n                </Content>\n            </>\n        </div>\n    );\n};\n\nexport default TradingChartPanel;\n","import TradingChartPanel from './TradingChartPanel'\n\nexport default TradingChartPanel\n","import { useEffect, useState } from 'react'\n\nimport { Responsive, WidthProvider } from 'react-grid-layout'\n\nimport { rowHeight, layouts, breakpoints, cols } from 'layouts/responsive_layout/pages/trading_page'\n\nimport BasicInfoPanel from 'features/panels/trading/BasicInfoPanel'\nimport OrderActionsPanel from 'features/panels/trading/OrderActionsPanel'\nimport OrderBookPanel from 'features/panels/trading/OrderBookPanel'\nimport OrderRecordsPanel from 'features/panels/trading/OrderRecordsPanel'\nimport TradeRecordsPanel from 'features/panels/trading/TradeRecordsPanel'\nimport TradingChartPanel from 'features/panels/trading/TradingChartPanel'\n\nimport { useTradingInfo } from 'hooks/trading_hook'\n\nimport { authNoKeyApi } from 'lightcone_api/api_wrapper'\nimport { DepthData } from 'defs/exchange_defs'\n\nconst ResponsiveGridLayout = WidthProvider(Responsive)\n\nconst TradingPage = () => {\n\n  const tradingInfo = useTradingInfo()\n\n  const [depth, setDepth] = useState<DepthData>()\n\n  useEffect(() => {\n\n      const id = setInterval(async () => {\n          const depth_data = (await authNoKeyApi.getDepthData(tradingInfo.symbol, 0, 20))\n          setDepth(depth_data)\n          // console.log(depth)\n      }, tradingInfo.refreshRate)\n\n      return () => clearInterval(id)\n  })\n\n  return (\n    <ResponsiveGridLayout className='layout'\n      layouts={layouts}\n      rowHeight={rowHeight}\n      draggableHandle={'.draggable_header'}\n      breakpoints={breakpoints}\n      isResizable={true}\n      cols={cols}>\n      <div key='basic_info'><BasicInfoPanel /></div>\n      <div key='order_book'><OrderBookPanel depth={depth} /></div>\n      <div key='trading_chart'><TradingChartPanel depth={depth} /></div>\n      <div key='order_actions'><OrderActionsPanel/></div>\n      <div key='trade_records'><TradeRecordsPanel /></div>\n      <div key='order_records'><OrderRecordsPanel /></div>\n    </ResponsiveGridLayout>\n  )\n}\n\nexport default TradingPage\n","import TradingPage from './TradingPage'\n\nexport default TradingPage\n","import styled from 'styled-components'\n\nexport interface TabProps {\n    active: boolean\n}\n\nexport const Tabs = styled.div`\n  float: none;\n  background: #2A2D34;\n  height: 100%;\n\n  div {\n    float: none;\n  }\n`\n\nexport const Tab = styled.button<TabProps>`\n  border: none;\n  cursor: pointer;\n  width: 200px;\n\n  font-size: 1em;\n  border-top: ${props => (props.active ? '2px solid #5773FF' : '')};\n  color: ${props => (props.active ? '#FFFFFF' : '#76808F')};\n  background-color: ${props => (props.active ? '#181C20' : '#2A2D34')};\n  height: ${props => (props.active ? '40px' : '36px; top:4px')};\n  transition: background-color 0.5s ease-in-out;\n\n  :hover {\n    border-top: 2px solid #5773FF;\n    color: #FFFFFF;\n    background-color: #181C20;\n  }\n`\n\nexport const Content = styled.div<TabProps>`\n  height: 100%;\n  ${props => (props.active ? '' : 'display:none;')}\n`\n","import { useState, useEffect } from 'react'\nimport { useTranslation } from 'react-i18next'\nimport styled from 'styled-components'\n\nimport { Tabs, Tab, Content } from 'components/tabs/VTabs'\n\nconst Left = styled.div`\nfloat: left;\nheight: 100%;\n`\n\nconst Right = styled.div`\nfloat: left;\nheight: 100%;\n`\n\nconst LiquidityPage = () => {\n\n  const { t } = useTranslation()\n\n  const [active, setActive] = useState('l0')\n  const handleClick = (e: any) => {\n    const index = e.target.id\n    if (index !== active) {\n      setActive(index)\n    }\n  }\n\n  return (\n    <>\n      <Left>\n        <Tabs>\n          <div>\n            <Tab onClick={handleClick} active={active === 'l0'} id={'l0'}>\n              \n          </Tab>\n          </div>\n          <div>\n            <Tab onClick={handleClick} active={active === 'l1'} id={'l1'}>\n              \n          </Tab>\n          </div>\n          <div>\n            <Tab onClick={handleClick} active={active === 'l2'} id={'l2'}>\n              \n          </Tab></div>\n        </Tabs>\n      </Left>\n      <Right>\n        <Content active={active === 'l0'}>\n          aaaa\n        </Content>\n        <Content active={active === 'l1'}>\n          bbbb\n        </Content>\n        <Content active={active === 'l2'}>\n          cccc\n        </Content>\n      </Right>\n    </>\n  )\n}\n\nexport default LiquidityPage\n","import LiquidityPage from './LiquidityPage'\n\nexport default LiquidityPage\n","import { useState, useEffect } from 'react'\nimport { useTranslation } from 'react-i18next'\nimport styled from 'styled-components'\n\nimport { Tabs, Tab, Content } from 'components/tabs/VTabs'\n\nconst Left = styled.div`\nfloat: left;\nheight: 100%;\n`\n\nconst Right = styled.div`\nfloat: left;\nheight: 100%;\n`\n\nconst L2WalletPage = () => {\n\n  const { t } = useTranslation()\n\n  const [active, setActive] = useState('w0')\n  const handleClick = (e: any) => {\n    const index = e.target.id\n    if (index !== active) {\n      setActive(index)\n    }\n  }\n\n  return (\n    <>\n      <Left>\n        <Tabs>\n          <div>\n            <Tab onClick={handleClick} active={active === 'w0'} id={'w0'}>\n              \n          </Tab>\n          </div>\n          <div>\n            <Tab onClick={handleClick} active={active === 'w1'} id={'w1'}>\n              \n          </Tab>\n          </div>\n          <div>\n            <Tab onClick={handleClick} active={active === 'w2'} id={'w2'}>\n              \n          </Tab>\n          </div>\n          <div>\n            <Tab onClick={handleClick} active={active === 'w3'} id={'w3'}>\n              \n          </Tab>\n          </div>\n        </Tabs>\n      </Left>\n      <Right>\n        <Content active={active === 'w0'}>\n          aaaa\n        </Content>\n        <Content active={active === 'w1'}>\n          bbbb\n        </Content>\n        <Content active={active === 'w2'}>\n          cccc\n        </Content>\n        <Content active={active === 'w3'}>\n          dddd\n        </Content>\n      </Right>\n    </>\n  )\n}\n\nexport default L2WalletPage\n","import L2WalletPage from './L2WalletPage'\n\nexport default L2WalletPage\n","import { InjectedConnector } from '@web3-react/injected-connector'\nimport { NetworkConnector } from '@web3-react/network-connector'\nimport { WalletConnectConnector } from '@web3-react/walletconnect-connector'\nimport { WalletLinkConnector } from '@web3-react/walletlink-connector'\nimport { LedgerConnector } from '@web3-react/ledger-connector'\nimport { TrezorConnector } from '@web3-react/trezor-connector'\nimport { AuthereumConnector } from '@web3-react/authereum-connector'\n\nconst POLLING_INTERVAL = 12000\nconst RPC_URLS: { [chainId: number]: string } = {\n  1: process.env.REACT_APP_RPC_URL_1 as string,\n  4: process.env.REACT_APP_RPC_URL_4 as string\n}\n\nconsole.log('RPC_URLS 1:', RPC_URLS[1])\nconsole.log('RPC_URLS 4:', RPC_URLS[4])\n\nexport const injected = new InjectedConnector({ supportedChainIds: [1, 3, 4, 5, 42] })\n\nexport const network = new NetworkConnector({\n  urls: { 1: RPC_URLS[1], 4: RPC_URLS[4] },\n  defaultChainId: 1\n})\n\nexport const walletconnect = new WalletConnectConnector({\n  rpc: { 1: RPC_URLS[1] },\n  bridge: 'https://bridge.walletconnect.org',\n  qrcode: true,\n  pollingInterval: POLLING_INTERVAL\n})\n\nexport const walletlink = new WalletLinkConnector({\n  url: RPC_URLS[1],\n  appName: 'web3-react example'\n})\n\nexport const ledger = new LedgerConnector({ chainId: 1, url: RPC_URLS[1], pollingInterval: POLLING_INTERVAL })\n\nexport const trezor = new TrezorConnector({\n  chainId: 1,\n  url: RPC_URLS[1],\n  pollingInterval: POLLING_INTERVAL,\n  manifestEmail: 'dummy@abc.xyz',\n  manifestAppUrl: 'http://localhost:1234'\n})\n\nexport const authereum = new AuthereumConnector({ chainId: 42 })\n","import React from 'react'\n\n// <!-- By Sam Herbert (@sherb), for everyone. More @ http://goo.gl/7AJzbL -->\nexport function Spinner({ color, ...rest }: any) {\n  return (\n    <svg width='38' height='38' viewBox='0 0 38 38' xmlns='http://www.w3.org/2000/svg' stroke={color} {...rest}>\n      <g fill='none' fillRule='evenodd'>\n        <g transform='translate(1 1)' strokeWidth='2'>\n          <circle strokeOpacity='.5' cx='18' cy='18' r='18' />\n          <path d='M36 18c0-9.94-8.06-18-18-18'>\n            <animateTransform\n              attributeName='transform'\n              type='rotate'\n              from='0 18 18'\n              to='360 18 18'\n              dur='1s'\n              repeatCount='indefinite'\n            />\n          </path>\n        </g>\n      </g>\n    </svg>\n  )\n}\n","import { useWeb3React } from '@web3-react/core'\n\nexport function Account() {\n  const { account } = useWeb3React()\n\n  return (\n    <>\n      <span>Account</span>\n      <span role='img' aria-label='robot'>\n        \n      </span>\n      <span>\n        {account === null\n          ? '-'\n          : account\n            ? `${account.substring(0, 6)}...${account.substring(account.length - 4)}`\n            : ''}\n      </span>\n    </>\n  )\n}\n","import {\n    injected,\n    network,\n    walletconnect,\n    walletlink,\n    ledger,\n    trezor,\n    authereum,\n} from 'networks/web3_connectors'\n\nexport enum ConnectorNames {\n    Injected = 'Injected',\n    Network = 'Network',\n    WalletConnect = 'WalletConnect',\n    WalletLink = 'WalletLink',\n    Ledger = 'Ledger',\n    Trezor = 'Trezor',\n    Authereum = 'Authereum',\n}\n\nexport const connectorsByName: { [connectorName in ConnectorNames]: any } = {\n    [ConnectorNames.Injected]: injected,\n    [ConnectorNames.Network]: network,\n    [ConnectorNames.WalletConnect]: walletconnect,\n    [ConnectorNames.WalletLink]: walletlink,\n    [ConnectorNames.Ledger]: ledger,\n    [ConnectorNames.Trezor]: trezor,\n    [ConnectorNames.Authereum]: authereum,\n}\n","import React from 'react'\nimport { useWeb3React } from '@web3-react/core'\n\nimport { formatEther } from '@ethersproject/units'\n\nexport function Balance() {\n  const { account, library, chainId } = useWeb3React()\n\n  const [balance, setBalance] = React.useState<number>()\n  React.useEffect((): any => {\n    if (!!account && !!library) {\n      let stale = false\n\n      library\n        .getBalance(account)\n        .then((balance: any) => {\n          if (!stale) {\n            setBalance(balance)\n          }\n        })\n        .catch(() => {\n          if (!stale) {\n            setBalance(0)\n          }\n        })\n\n      return () => {\n        stale = true\n        setBalance(0)\n      }\n    }\n  }, [account, library, chainId]) // ensures refresh if referential identity of library doesn't change across chainIds\n\n  return (\n    <>\n      <span>Balance</span>\n      <span role='img' aria-label='gold'>\n        \n      </span>\n      <span>{balance === null || balance === undefined ? 'Error' : balance ? `${formatEther(balance)}` : ''}</span>\n    </>\n  )\n}\n","import React from 'react'\nimport { useWeb3React } from '@web3-react/core'\n\nexport function BlockNumber() {\n  const { chainId, library } = useWeb3React()\n\n  const [blockNumber, setBlockNumber] = React.useState<number>()\n  React.useEffect((): any => {\n    if (!!library) {\n      let stale = false\n\n      library\n        .getBlockNumber()\n        .then((blockNumber: number) => {\n          if (!stale) {\n            setBlockNumber(blockNumber)\n          }\n        })\n        .catch(() => {\n          if (!stale) {\n            setBlockNumber(-1)\n          }\n        })\n\n      const updateBlockNumber = (blockNumber: number) => {\n        setBlockNumber(blockNumber)\n      }\n      library.on('block', updateBlockNumber)\n\n      return () => {\n        stale = true\n        library.removeListener('block', updateBlockNumber)\n        setBlockNumber(undefined)\n      }\n    }\n  }, [library, chainId]) // ensures refresh if referential identity of library doesn't change across chainIds\n\n  return (\n    <>\n      <span>Block Number</span>\n      <span role='img' aria-label='numbers'>\n        \n      </span>\n      <span>{blockNumber === null ? 'Error' : blockNumber ?? ''}</span>\n    </>\n  )\n}\n","import { useWeb3React } from '@web3-react/core'\n\nexport function ChainId() {\n  const { chainId } = useWeb3React()\n\n  return (\n    <>\n      <span>Chain Id</span>\n      <span role='img' aria-label='chain'>\n        \n      </span>\n      <span>{chainId ?? ''}</span>\n    </>\n  )\n}\n","import { Web3Provider } from '@ethersproject/providers'\n\nimport { UnsupportedChainIdError } from '@web3-react/core'\n\nimport {\n    NoEthereumProviderError,\n    UserRejectedRequestError as UserRejectedRequestErrorInjected\n} from '@web3-react/injected-connector'\nimport { UserRejectedRequestError as UserRejectedRequestErrorWalletConnect } from '@web3-react/walletconnect-connector'\n\nexport function getLibrary(provider: any): Web3Provider {\n    const library = new Web3Provider(provider)\n    library.pollingInterval = 10000\n    return library\n}\n\nexport function getErrorMessage(error: Error) {\n    if (error instanceof NoEthereumProviderError) {\n        return 'No Ethereum browser extension detected, install MetaMask on desktop or visit from a dApp browser on mobile.'\n    } else if (error instanceof UnsupportedChainIdError) {\n        return 'You\\'re connected to an unsupported network.'\n    } else if (\n        error instanceof UserRejectedRequestErrorInjected ||\n        error instanceof UserRejectedRequestErrorWalletConnect\n    ) {\n        return 'Please authorize this website to access your Ethereum account.'\n    } else {\n        console.error(error)\n        return 'An unknown error occurred. Check the console for more details.'\n    }\n}\n","import React from 'react'\nimport styled from 'styled-components/macro'\n\nimport { useWeb3React } from '@web3-react/core'\nimport { Web3Provider } from '@ethersproject/providers'\n\nimport { useEagerConnect, useInactiveListener } from '../../hooks/web3_hook'\n\nimport { Spinner } from './items/Spinner'\n\nimport { Account } from './items/Account'\nimport { Balance } from './items/Balance'\nimport { BlockNumber } from './items/BlockNumber'\nimport { ChainId } from './items/ChainId'\n\nimport { ConnectorNames, connectorsByName } from '../../wallets/wallet_defs'\n\nimport { getErrorMessage } from '../../utils/web3_tools'\n\nconst Button = styled.button`\ncursor: pointer;\nbackground: #373739;\nborder-radius: 8px;\nwidth: 120px;\nheight: 36px;\nline-height: 36px;\ntext-align: center;\n\nfont-family: PingFang HK;\nfont-size: 16px;\nfont-style: normal;\nfont-weight: normal;\nline-height: 19px;\ncolor: #ffffff;\n`\n\nfunction WalletShowCase() {\n\n  const context = useWeb3React<Web3Provider>()\n  const { connector, library, chainId, account, activate, deactivate, active, error } = context\n\n  // handle logic to recognize the connector currently being activated\n  const [activatingConnector, setActivatingConnector] = React.useState<any>()\n  React.useEffect(() => {\n    if (activatingConnector && activatingConnector === connector) {\n      setActivatingConnector(undefined)\n    }\n  }, [activatingConnector, connector])\n\n  // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n  const triedEager = useEagerConnect()\n\n  // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n  useInactiveListener(!triedEager || !!activatingConnector)\n\n  return (\n    <>\n    <h1 style={{ margin: '1rem', textAlign: 'right' }}>{active ? '' : error ? '' : ''}</h1>\n    <h3\n        style={{\n            display: 'grid',\n            gridGap: '1rem',\n            gridTemplateColumns: '1fr min-content 1fr',\n            maxWidth: '20rem',\n            lineHeight: '2rem',\n            margin: 'auto'\n        }}\n    >\n        <ChainId />\n        <BlockNumber />\n        <Account />\n        <Balance />\n    </h3>\n      <hr style={{ margin: '2rem' }} />\n      <div\n        style={{\n          display: 'grid',\n          gridGap: '1rem',\n          gridTemplateColumns: '1fr 1fr',\n          maxWidth: '20rem',\n          margin: 'auto'\n        }}\n      >\n        {Object.keys(connectorsByName).map(name => {\n          // @ts-ignore\n          const currentConnector = connectorsByName[name]\n          const activating = currentConnector === activatingConnector\n          const connected = currentConnector === connector\n          const disabled = !triedEager || !!activatingConnector || connected || !!error\n\n          return (\n            <Button color='primary'\n              disabled={disabled}\n              key={name}\n              onClick={() => {\n                setActivatingConnector(currentConnector)\n                activate(currentConnector)\n              }}\n            >\n              <div\n                style={{\n                  position: 'absolute',\n                  top: '0',\n                  left: '0',\n                  height: '100%',\n                  display: 'flex',\n                  alignItems: 'center',\n                  color: 'black',\n                  margin: '0 0 0 1rem'\n                }}\n              >\n                {activating && <Spinner color={'black'} style={{ height: '25%', marginLeft: '-1rem' }} />}\n                {connected && (\n                  <span role='img' aria-label='check'>\n                    \n                  </span>\n                )}\n              </div>\n              {name}\n            </Button>\n          )\n        })}\n      </div>\n      <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {(active || error) && (\n          <Button color='primary'\n            style={{\n            }}\n            onClick={() => {\n              deactivate()\n            }}\n          >\n            Deactivate\n          </Button>\n        )}\n\n        {!!error && <h4 style={{ marginTop: '1rem', marginBottom: '0' }}>{getErrorMessage(error)}</h4>}\n      </div>\n\n      <hr style={{ margin: '2rem' }} />\n\n      <div\n        style={{\n          display: 'grid',\n          gridGap: '1rem',\n          gridTemplateColumns: 'fit-content',\n          maxWidth: '20rem',\n          margin: 'auto'\n        }}\n      >\n        {!!(library && account) && (\n          <Button color='primary'\n            onClick={() => {\n              library\n                .getSigner(account)\n                .signMessage('')\n                .then((signature: any) => {\n                  window.alert(`Success!\\n\\n${signature}`)\n                })\n                .catch((error: any) => {\n                  window.alert('Failure!' + (error && error.message ? `\\n\\n${error.message}` : ''))\n                })\n            }}\n          >\n            Sign Message\n          </Button>\n        )}\n        {!!(connector === connectorsByName[ConnectorNames.Network] && chainId) && (\n          <Button color='primary'\n            onClick={() => {\n              ; (connector as any).changeChainId(chainId === 1 ? 4 : 1)\n            }}\n          >\n            Switch Networks\n          </Button>\n        )}\n        {connector === connectorsByName[ConnectorNames.WalletConnect] && (\n          <Button color='primary'\n            onClick={() => {\n              ; (connector as any).close()\n            }}\n          >\n            Kill WalletConnect Session\n          </Button>\n        )}\n        {connector === connectorsByName[ConnectorNames.WalletLink] && (\n          <Button color='primary'\n            onClick={() => {\n              ; (connector as any).close()\n            }}\n          >\n            Kill WalletLink Session\n          </Button>\n        )}\n      </div>\n    </>\n  )\n}\n\nexport default WalletShowCase;\n","import { useState, useEffect } from 'react'\nimport { useWeb3React } from '@web3-react/core'\n\nimport { injected } from 'networks/web3_connectors'\n\nexport function useEagerConnect() {\n  const { activate, active } = useWeb3React()\n\n  const [tried, setTried] = useState(false)\n\n  useEffect(() => {\n    injected.isAuthorized().then((isAuthorized: boolean) => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true)\n        })\n      } else {\n        setTried(true)\n      }\n    })\n  }, []) // intentionally only running on mount (make sure it's only mounted once :))\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect(() => {\n    if (!tried && active) {\n      setTried(true)\n    }\n  }, [tried, active])\n\n  return tried\n}\n\nexport function useInactiveListener(suppress: boolean = false) {\n  const { active, error, activate } = useWeb3React()\n\n  useEffect((): any => {\n    const { ethereum } = window as any\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleConnect = () => {\n        console.log('Handling \\'connect\\' event')\n        activate(injected)\n      }\n      const handleChainChanged = (chainId: string | number) => {\n        console.log('Handling \\'chainChanged\\' event with payload', chainId)\n        activate(injected)\n      }\n      const handleAccountsChanged = (accounts: string[]) => {\n        console.log('Handling \\'accountsChanged\\' event with payload', accounts)\n        if (accounts.length > 0) {\n          activate(injected)\n        }\n      }\n      const handleNetworkChanged = (networkId: string | number) => {\n        console.log('Handling \\'networkChanged\\' event with payload', networkId)\n        activate(injected)\n      }\n\n      ethereum.on('connect', handleConnect)\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n      ethereum.on('networkChanged', handleNetworkChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('connect', handleConnect)\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n          ethereum.removeListener('networkChanged', handleNetworkChanged)\n        }\n      }\n    }\n  }, [active, error, suppress, activate])\n}\n","import React, { lazy } from 'react'\n\nimport {\n  HashRouter as Router,\n  Switch,\n  Route,\n  useParams,\n  useRouteMatch,\n} from 'react-router-dom'\n\nimport styled from 'styled-components/macro'\nimport styles from './routers.module.scss'\n\nimport Header from 'layouts/header'\nimport Footer from 'layouts/footer'\n\n/*\nconst QuotePanel = lazy(() => import('../pages/QuotePanel'))\nconst TradingPanel = lazy(() => import('../pages/TradingPanel'))\nconst LiquidityPanel = lazy(() => import('../pages/LiquidityPanel'))\nconst L2WalletPanel = lazy(() => import('../pages/L2WalletPanel'))\nconst WalletShowCase = lazy(() => import('../pages/demo_page/wallet_showcase'))\n*/\n\nimport HomePage from 'pages/HomePage'\n\nimport QuotePage from 'pages/QuotePage'\nimport TradingPage from 'pages/TradingPage'\nimport LiquidityPage from 'pages/LiquidityPage'\nimport L2WalletPage from 'pages/L2WalletPage'\n\nimport WalletShowCase from 'pages/DemoPage/wallet_showcase'\n\nconst Container = styled.div`\nwidth: 100%;\nbackground: ${({ theme }) => theme.colors.bodyBgColor};\ncolor: #ffffff;\n}\n`\n\nclass RouterView extends React.Component {\n  render() {\n    return (\n      <Router>\n        <Switch>\n          <Route exact path='/'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <HomePage />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/quote'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <QuotePage />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/trading/quick'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <TradingPage />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/trading/pro'>\n            <Header />\n            <Container>\n              <TradingPage />\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/liquidity'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <LiquidityPage />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/l2wallet'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <L2WalletPage />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n          <Route exact path='/demo'>\n            <Header />\n            <Container>\n              <div className={styles.content_container}>\n                <WalletShowCase />\n              </div>\n            </Container>\n            <Footer />\n          </Route>\n        </Switch>\n      </Router>\n    );\n  }\n}\n\nexport default RouterView;\n","export default __webpack_public_path__ + \"static/media/adv.d47cd595.png\";","export default __webpack_public_path__ + \"static/media/logo.abb8fa74.svg\";","export default __webpack_public_path__ + \"static/media/submenu_down.04b22e69.svg\";","export default __webpack_public_path__ + \"static/media/download.57441563.svg\";","export default __webpack_public_path__ + \"static/media/notification.65fff1bf.svg\";","export default __webpack_public_path__ + \"static/media/settings.4e96ad31.svg\";","export default __webpack_public_path__ + \"static/media/lang.fbf0f0e9.svg\";","export default __webpack_public_path__ + \"static/media/account.db30bc0a.svg\";","export default __webpack_public_path__ + \"static/media/obt1.2b5a7023.svg\";","export default __webpack_public_path__ + \"static/media/obt2.72a2dbad.svg\";","export default __webpack_public_path__ + \"static/media/obt3.99bd2141.svg\";","export default __webpack_public_path__ + \"static/media/mode_selector.bc09e566.svg\";","import baseStyled, { ThemedStyledInterface } from 'styled-components'\n\nimport advImg from '../assets/images/adv.png'\n\nimport logo_dark from '../assets/images/dark/logo.svg'\nimport logo_light from '../assets/images/dark/logo.svg'\n\nimport submenu_down_dark from '../assets/images/dark/submenu_down.svg'\nimport submenu_down_light from '../assets/images/dark/submenu_down.svg'\n\nimport download_dark from '../assets/images/dark/download.svg'\nimport notification_dark from '../assets/images/dark/notification.svg'\nimport mode_dark from '../assets/images/dark/settings.svg'\n// import mode_dark from '../assets/images/dark/mode_selector.svg'\nimport lang_dark from '../assets/images/dark/lang.svg'\nimport account_dark from '../assets/images/dark/account.svg'\nimport obt1_dark from '../assets/images/dark/obt1.svg'\nimport obt2_dark from '../assets/images/dark/obt2.svg'\nimport obt3_dark from '../assets/images/dark/obt3.svg'\n\nimport download_light from '../assets/images/dark/download.svg'\nimport notification_light from '../assets/images/dark/notification.svg'\nimport mode_light from '../assets/images/dark/mode_selector.svg'\nimport lang_light from '../assets/images/dark/lang.svg'\nimport account_light from '../assets/images/dark/account.svg'\nimport obt1_light from '../assets/images/dark/obt1.svg'\nimport obt2_light from '../assets/images/dark/obt2.svg'\nimport obt3_light from '../assets/images/dark/obt3.svg'\n\nexport const darkTheme = {\n  all: {\n  },\n  name: ' dark',\n  colors: {\n    bodyBgColor: '#111111',\n    headerBgColor: '#111111',\n    cwBtnBgColor: '#373739',\n    cwBtnColor: '#ffffff',\n    menuActived: '#ffffff',\n    menuInactived: '#999999',\n    subMenuBgColor: '#ffffff',\n    upColor: '#00BBA8',\n    upBorderColor: '#00BBA8',\n    downColor: '#FF5677',\n    downBorderColor: '#FF5677',\n    submenu_item_bg_color_a: '#373739',\n    submenu_item_bg_color_ia: '#1F2126',\n    submenu_circle_bg_color_a: '#5773FF',\n    submenu_circle_bg_color_ia: '#ffffff',\n    submenu_title_color_a: '#5773FF',\n    submenu_title_color_ia: '#ffffff',\n    submenu_desc_color: '#999999',\n  },\n  effects: {\n    submenu_desc_text_shadow: '1px 2px 2px #000, 0 -1px 0 #000, 0 1px 0 #000, -1px 0 0 #000',\n  },\n  imgs: {\n    advImg: advImg,\n    logo: logo_dark,\n    submenu_down: submenu_down_dark,\n    download_img: download_dark,\n    notification_img: notification_dark,\n    mode_img: mode_dark,\n    lang_img: lang_dark,\n    account_img: account_dark,\n    obt1_img: obt1_dark,\n    obt2_img: obt2_dark,\n    obt3_img: obt3_dark,\n  }\n}\n\nexport const lightTheme: Theme = {\n  all: { ...darkTheme.all },\n  name: 'light',\n  colors: {\n    bodyBgColor: '#222222',\n    headerBgColor: '#777777',\n    cwBtnBgColor: '#373739',\n    cwBtnColor: '#ffffff',\n    menuActived: '#ffffff',\n    menuInactived: '#999999',\n    subMenuBgColor: '#000000',\n    upColor: '#ec0000',\n    upBorderColor: '#8A0000',\n    downColor: '#00da3c',\n    downBorderColor: '#008F28',\n    submenu_item_bg_color_a: '#373739',\n    submenu_item_bg_color_ia: '#1F2126',\n    submenu_circle_bg_color_a: '#5773FF',\n    submenu_circle_bg_color_ia: '#ffffff',\n    submenu_title_color_a: '#5773FF',\n    submenu_title_color_ia: '#ffffff',\n    submenu_desc_color: '#999999',\n  },\n  effects: {\n    submenu_desc_text_shadow: '1px 2px 2px #000, 0 -1px 0 #000, 0 1px 0 #000, -1px 0 0 #000',\n  },\n  imgs: {\n    advImg: advImg,\n    logo: logo_light,\n    submenu_down: submenu_down_light,\n    download_img: download_light,\n    notification_img: notification_light,\n    mode_img: mode_light,\n    lang_img: lang_light,\n    account_img: account_light,\n    obt1_img: obt1_light,\n    obt2_img: obt2_light,\n    obt3_img: obt3_light,\n  }\n}\n\nexport type Theme = typeof darkTheme\nexport const styled = baseStyled as ThemedStyledInterface<Theme>\n","import { ThemeProvider } from './ThemeProvider'\n\nexport default ThemeProvider\n","import * as React from 'react'\n\nimport { useSelector } from 'react-redux'\nimport { RootState } from 'stores'\n\nimport { ThemeProvider as SCThemeProvider, } from 'styled-components'\n\nimport { darkTheme, lightTheme, } from 'themes/theme'\n\nexport interface ThemeProviderProps {\n  children: React.ReactNode\n}\n\nexport const ThemeProvider = ({ children }: ThemeProviderProps) => {\n\n  const themeType = useSelector((state: RootState) => state.settings.themeType)\n\n  return (\n    <SCThemeProvider theme={ themeType === 'dark' ?  darkTheme : lightTheme}>\n      <React.Fragment>\n        {children}\n      </React.Fragment>\n    </SCThemeProvider>\n  )\n\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n\nexport interface LoadingState {\n  isLoading: boolean\n}\n\nconst initialState = { isLoading: false } as LoadingState\n\nconst loadingSlice = createSlice({\n  name: 'loading',\n  initialState,\n  reducers: {\n    setLoading(state, action: PayloadAction<boolean>) {\n      state.isLoading = action.payload\n    },\n  },\n})\n\nexport const { setLoading } = loadingSlice.actions\nexport default loadingSlice\n","import LoadingModal from './LoadingModal'\n\nexport default LoadingModal\n","export interface LoadingProps {\n  isLoading: boolean\n  onClose?: any\n}\n\nconst LoadingModal = ({ isLoading, onClose }: LoadingProps) => {\n  return (\n    <></>\n  )\n}\n\nexport default LoadingModal\n","import LoadingModal from './LoadingModal'\n\nexport default LoadingModal\n","import { useSelector, useDispatch } from 'react-redux'\n\nimport { RootState } from 'stores'\nimport { setLoading } from 'stores/reducers/loading_reducer'\n\nimport LoadingModalUI from 'components/modals/LoadingModal'\n\nconst LoadingModal = () => {\n\n  const isLoading = useSelector((state: RootState) => state.loading.isLoading)\n\n  const dispatch = useDispatch()\n\n  const close = () => {\n    dispatch(setLoading(false))\n  }\n  \n  return (\n    <LoadingModalUI isLoading={isLoading} onClose={close}/>\n  )\n\n}\n\nexport default LoadingModal\n","import React from 'react'\n\nimport './themes/global_fonts.scss'\nimport './themes/global.scss'\nimport '../node_modules/react-grid-layout/css/styles.css'\nimport '../node_modules/react-resizable/css/styles.css'\n\nimport RouterView from './routers'\n\nimport { I18nextProvider } from 'react-i18next'\nimport i18n from 'plugins/i18n'\nimport ThemeProvider from 'features/themes/ThemeProvider'\n\nimport LoadingModal from 'features/components/modal/LoadingModal'\n\nimport { useExchangeMarkets } from 'hooks/trading_hook'\n\nconst App = () => {\n\n  useExchangeMarkets()\n  \n  return (\n    <ThemeProvider>\n      <I18nextProvider i18n={i18n}>\n        <LoadingModal />\n        <RouterView />\n      </I18nextProvider>\n    </ThemeProvider>\n  )\n}\n\nexport default App\n","import { combineReducers } from '@reduxjs/toolkit'\n\nimport settingsSlice from './settings_reducer'\nimport accountSlice from './account_reducer'\nimport loadingSlice from './loading_reducer'\nimport tradingSlice from './trading_reducer'\n\nconst rootReducer = combineReducers({\n  settings: settingsSlice.reducer,\n  account: accountSlice.reducer,\n  loading: loadingSlice.reducer,\n  trading: tradingSlice.reducer,\n})\n\nexport default rootReducer\n","import { configureStore } from '@reduxjs/toolkit'\nimport { useDispatch } from 'react-redux'\n\n// We'll use redux-logger just as an example of adding another middleware\nimport logger from 'redux-logger'\n\n// And use redux-batch as an example of adding enhancers\nimport { reduxBatch } from '@manaflair/redux-batch'\n\nimport reducer from './reducers'\n\nconst store = configureStore({\n  reducer,\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n  devTools: process.env.NODE_ENV !== 'production',\n  enhancers: [reduxBatch],\n})\n\n// The store has been created with these options:\n// - The slice reducers were automatically passed to combineReducers()\n// - redux-thunk and redux-logger were added as middleware\n// - The Redux DevTools Extension is disabled for production\n// - The middleware, batch, and devtools enhancers were composed together\n\nexport type AppDispatch = typeof store.dispatch\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\n\nexport type RootState = ReturnType<typeof reducer>\n\nexport default store\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './themes/reset.scss'\n\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nimport { getLibrary } from './utils/web3_tools'\nimport { Web3ReactProvider } from '@web3-react/core'\nimport { Provider } from 'react-redux'\nimport store from './stores'\n\nReactDOM.render(\n  <Provider store={store}>\n    <Web3ReactProvider getLibrary={getLibrary}>\n      <App />\n    </Web3ReactProvider>\n  </Provider>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n\nif (process.env.NODE_ENV !== 'production') {\n  reportWebVitals(console.log)\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menu_bar\":\"header_menu_bar__1fADi\",\"small_menu_bar\":\"header_small_menu_bar__3jvPG\",\"advimg\":\"header_advimg__3_OMj\",\"iconbtns\":\"header_iconbtns__3DM0r\",\"cwbtn\":\"header_cwbtn__1OEye\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"content_container\":\"routers_content_container__2kdCz\"};","// Taken from\n// https://github.com/iden3/circomlib\n\nimport { bigInt, bn128 } from 'snarkjs';\nimport blake2b from 'blake2b';\nconst assert = require('assert');\n\nconst F = bn128.Fr;\nconst SEED = 'poseidon';\nconst NROUNDSF = 8;\nconst NROUNDSP = 57;\nconst T = 6;\n\nfunction getPseudoRandom(seed, n) {\n  const res = [];\n  let input = Buffer.from(seed);\n  let h = blake2b(32).update(input).digest();\n  while (res.length < n) {\n    const n = F.affine(bigInt.leBuff2int(h));\n    res.push(n);\n    h = blake2b(32).update(h).digest();\n  }\n\n  return res;\n}\n\nfunction allDifferent(v) {\n  for (let i = 0; i < v.length; i++) {\n    if (v[i].isZero()) return false;\n    for (let j = i + 1; j < v.length; j++) {\n      if (v[i].equals(v[j])) return false;\n    }\n  }\n  return true;\n}\n\nexport function getMatrix(t, seed, nRounds) {\n  if (typeof seed === 'undefined') seed = SEED;\n  if (typeof nRounds === 'undefined') nRounds = NROUNDSF + NROUNDSP;\n  if (typeof t === 'undefined') t = T;\n  let nonce = '0000';\n  let cmatrix = getPseudoRandom(seed + '_matrix_' + nonce, t * 2);\n  while (!allDifferent(cmatrix)) {\n    nonce = Number(nonce) + 1 + '';\n    while (nonce.length < 4) nonce = '0' + nonce;\n    cmatrix = getPseudoRandom(seed + '_matrix_' + nonce, t * 2);\n  }\n\n  const M = new Array(t);\n  for (let i = 0; i < t; i++) {\n    M[i] = new Array(t);\n    for (let j = 0; j < t; j++) {\n      M[i][j] = F.affine(F.inverse(F.sub(cmatrix[i], cmatrix[t + j])));\n    }\n  }\n  return M;\n}\n\nexport function getConstants(t, seed, nRounds) {\n  if (typeof seed === 'undefined') seed = SEED;\n  if (typeof nRounds === 'undefined') nRounds = NROUNDSF + NROUNDSP;\n  if (typeof t === 'undefined') t = T;\n  return getPseudoRandom(seed + '_constants', nRounds);\n}\n\nfunction ark(state, c) {\n  for (let j = 0; j < state.length; j++) {\n    state[j] = F.add(state[j], c);\n  }\n}\n\nfunction sigma(a) {\n  return F.mul(a, F.square(F.square(a, a)));\n}\n\nfunction mix(state, M) {\n  const newState = new Array(state.length);\n  for (let i = 0; i < state.length; i++) {\n    newState[i] = F.zero;\n    for (let j = 0; j < state.length; j++) {\n      newState[i] = F.add(newState[i], F.mul(M[i][j], state[j]));\n    }\n  }\n  for (let i = 0; i < state.length; i++) state[i] = newState[i];\n}\n\nexport function createHash(t, nRoundsF, nRoundsP, seed) {\n  if (typeof seed === 'undefined') seed = SEED;\n  if (typeof nRoundsF === 'undefined') nRoundsF = NROUNDSF;\n  if (typeof nRoundsP === 'undefined') nRoundsP = NROUNDSP;\n  if (typeof t === 'undefined') t = T;\n\n  assert(nRoundsF % 2 === 0);\n  const C = getConstants(t, seed, nRoundsF + nRoundsP);\n  const M = getMatrix(t, seed, nRoundsF + nRoundsP);\n  return function (inputs) {\n    let state = [];\n    assert(inputs.length < t);\n    assert(inputs.length > 0);\n    for (let i = 0; i < inputs.length; i++) state[i] = bigInt(inputs[i]);\n    for (let i = inputs.length; i < t; i++) state[i] = F.zero;\n\n    for (let i = 0; i < nRoundsF + nRoundsP; i++) {\n      ark(state, C[i]);\n      if (i < nRoundsF / 2 || i >= nRoundsF / 2 + nRoundsP) {\n        for (let j = 0; j < t; j++) state[j] = sigma(state[j]);\n      } else {\n        state[0] = sigma(state[0]);\n      }\n      mix(state, M);\n    }\n    return F.affine(state[0]);\n  };\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"dropdown_content\":\"menu_dropdown_content__20My2\",\"dropdown\":\"menu_dropdown__2ZPkA\"};","import * as ethUtil from 'ethereumjs-util'\nimport BN from 'bn.js'\nimport BigNumber from 'bignumber.js'\n\nBigNumber.config({\n  EXPONENTIAL_AT: 20,\n  RANGE: [-100000, 10000000],\n  ROUNDING_MODE: 1,\n})\n\n/**\n *\n * @param mixed Buffer|number|string (hex string must be with '0x' prefix)\n * @returns {Buffer}\n */\nexport function toBuffer(mixed: any) {\n  if (mixed instanceof Buffer) {\n    return mixed;\n  } else {\n    return ethUtil.toBuffer(mixed)\n  }\n}\n\n/**\n *\n * @param num number|string (hex string must be with '0x' prefix)\n * @param places number of zeros to pad\n * @returns {Buffer}\n */\nexport function zeroPad(num: any, places: any) {\n  return toBuffer(String(num).padStart(places, '0'))\n}\n\n/**\n *\n * @param mixed number | BigNumber |  BN  | Buffer | string\n * @returns {string}\n */\nexport function toHex(mixed: any) {\n  if (\n    typeof mixed === 'number' ||\n    mixed instanceof BigNumber ||\n    mixed instanceof BN\n  ) {\n    return addHexPrefix(mixed.toString(16))\n  }\n\n  if (mixed instanceof Buffer) {\n    return addHexPrefix(mixed.toString('hex'))\n  }\n\n  if (typeof mixed === 'string') {\n    const regex = new RegExp(/^0x[0-9a-fA-F]*$/)\n    return regex.test(mixed)\n      ? mixed\n      : addHexPrefix(toBuffer(mixed).toString('hex'))\n  }\n  throw new Error('Unsupported type')\n}\n\n/**\n *\n * @param mixed number | BigNumber |  BN  | Buffer | string\n * @returns {number}\n */\nexport function toNumber(mixed: any) {\n  if (typeof mixed === 'number') {\n    return mixed\n  }\n\n  if (mixed instanceof BigNumber || mixed instanceof BN) {\n    return mixed.toNumber()\n  }\n\n  if (typeof mixed === 'string') {\n    return Number(mixed)\n  }\n\n  throw new Error('Unsupported type')\n}\n\n/**\n *\n * @param mixed number | BigNumber |  BN  | Buffer | string\n * @returns {BigNumber}\n */\nexport function toBig(mixed: any) {\n  if (mixed instanceof BigNumber) {\n    return mixed\n  }\n\n  if (typeof mixed === 'number') {\n    return new BigNumber(mixed.toString())\n  }\n\n  if (typeof mixed === 'string') {\n    return new BigNumber(mixed)\n  }\n\n  throw new Error('Unsupported type')\n}\n\n/**\n *\n * @param mixed number | BigNumber |  BN  | Buffer | string\n * @returns {BN}\n */\nexport function toBN(mixed: any) {\n  return mixed instanceof BN ? mixed : new BN(toBig(mixed).toString(10), 10)\n}\n\n/**\n *\n * @param value number | BigNumber | Buffer | string\n * @returns {BN}\n */\nexport function fromGWEI(value: any) {\n  return new BigNumber(toBig(value).times(1e9).toFixed(0))\n}\n\n/**\n *\n * @param value number | BigNumber | Buffer | string\n * @returns {BN}\n */\nexport function toGWEI(value: any) {\n  return toBig(value).div(1e9)\n}\n\n/**\n * Returns formatted hex string of a given private key\n * @param mixed Buffer| string\n * @returns {string}\n */\nexport function formatKey(mixed: any) {\n  if (mixed instanceof Buffer) {\n    return mixed.toString('hex')\n  }\n\n  if (typeof mixed === 'string') {\n    return mixed.startsWith('0x') ? mixed.slice(2) : mixed\n  }\n  throw new Error('Unsupported type')\n}\n\n/**\n * Returns hex string of a given address\n * @param mixed Buffer | string\n * @returns {string}\n */\nexport function formatAddress(mixed: any) {\n  if (mixed instanceof Buffer) {\n    return ethUtil.toChecksumAddress('0x' + mixed.toString('hex'))\n  }\n\n  if (typeof mixed === 'string') {\n    return ethUtil.toChecksumAddress(\n      mixed.startsWith('0x') ? mixed : '0x' + mixed\n    );\n  }\n  throw new Error('Unsupported type');\n}\n\n/**\n * Returns hex string with '0x' prefix\n * @param input\n * @returns {string}\n */\nexport function addHexPrefix(input: any) {\n  if (typeof input === 'string') {\n    return input.startsWith('0x') ? input : '0x' + input\n  }\n  throw new Error('Unsupported type')\n}\n\n/**\n * Returns hex string without '0x' prefix\n * @param input string\n * @returns {string}\n */\nexport function clearHexPrefix(input: any) {\n  if (typeof input === 'string') {\n    return input.startsWith('0x') ? input.slice(2) : input\n  }\n  throw new Error('Unsupported type')\n}\n\n/**\n *\n * @param hex\n * @returns {string}\n */\nexport function padLeftEven(hex: any) {\n  return hex.length % 2 !== 0 ? `0${hex}` : hex\n}\n\n/**\n * Returns symbol of a given kind of currency\n * @param settingsCurrency\n * @returns {*}\n */\nexport function getDisplaySymbol(settingsCurrency: any) {\n  switch (settingsCurrency) {\n    case 'CNY':\n      return ''\n    case 'USD':\n      return '$'\n    default:\n      return ''\n  }\n}\n\n/**\n * Returns number in string with a given precision\n * @param number number | BigNumber\n * @param precision number\n * @param ceil bool  round up\n * @returns {string}\n */\nexport function toFixed(number: any, precision: any, ceil: any) {\n  precision = precision || 0\n  if (number instanceof BigNumber) {\n    const rm = ceil ? 0 : 1\n    return number.toFixed(precision, rm)\n  }\n\n  if (typeof number === 'number') {\n    return ceil\n      ? (\n          Math.ceil(number * Number('1e' + precision)) /\n          Number('1e' + precision)\n        ).toFixed(precision)\n      : (\n          Math.floor(number * Number('1e' + precision)) /\n          Number('1e' + precision)\n        ).toFixed(precision)\n  }\n\n  throw new Error('Unsupported type')\n}\n\nexport function formatEddsaKey(key: any) {\n  const hexKey = clearHexPrefix(key)\n  return addHexPrefix(String(hexKey).padStart(64, '0'))\n}\n\n/**\n * Returns a number with commas as thousands separators\n * @param number number\n * @returns {*}\n */\nexport function numberWithCommas(number: any) {\n  if (number) {\n    number = number.toString().replace(/,/g, '')\n    if (isNaN(Number(number))) {\n      return '-'\n    }\n    try {\n      var parts = number.toString().split('.')\n      parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n      return parts.join('.')\n    } catch (error) {\n      return '-'\n    }\n  } else {\n    return number\n  }\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"dropdown_content\":\"lng_selector_dropdown_content__MS8zI\",\"dropdown\":\"lng_selector_dropdown__1c_I3\"};","// Taken and modified from\n// https://github.com/iden3/circomlib\n\nconst F1Field = require('ffjavascript').F1Field;\nconst Scalar = require('ffjavascript').Scalar;\nconst utils = require('ffjavascript').utils;\n\nexports.addPoint = addPoint;\nexports.mulPointEscalar = mulPointEscalar;\nexports.inCurve = inCurve;\nexports.inSubgroup = inSubgroup;\nexports.packPoint = packPoint;\nexports.unpackPoint = unpackPoint;\n\nexports.p = Scalar.fromString(\n  '21888242871839275222246405745257275088548364400416034343698204186575808495617'\n);\nconst F = new F1Field(exports.p);\nexports.F = F;\n\nexports.Base8 = [\n  F.e(\n    '16540640123574156134436876038791482806971768689494387082833631921987005038935'\n  ),\n  F.e(\n    '20819045374670962167435360035096875258406992893633759881276124905556507972311'\n  ),\n];\nexports.order = Scalar.fromString(\n  '21888242871839275222246405745257275088614511777268538073601725287587578984328'\n);\nexports.subOrder = Scalar.shiftRight(exports.order, 3);\nexports.A = F.e('168700');\nexports.D = F.e('168696');\n\nfunction addPoint(a, b) {\n  const res = [];\n\n  /* does the equivalent of:\n     res[0] = bigInt((a[0]*b[1] + b[0]*a[1]) *  bigInt(bigInt('1') + d*a[0]*b[0]*a[1]*b[1]).inverse(q)).affine(q);\n    res[1] = bigInt((a[1]*b[1] - cta*a[0]*b[0]) * bigInt(bigInt('1') - d*a[0]*b[0]*a[1]*b[1]).inverse(q)).affine(q);\n    */\n\n  const beta = F.mul(a[0], b[1]);\n  const gamma = F.mul(a[1], b[0]);\n  const delta = F.mul(F.sub(a[1], F.mul(exports.A, a[0])), F.add(b[0], b[1]));\n  const tau = F.mul(beta, gamma);\n  const dtau = F.mul(exports.D, tau);\n\n  res[0] = F.div(F.add(beta, gamma), F.add(F.one, dtau));\n\n  res[1] = F.div(\n    F.add(delta, F.sub(F.mul(exports.A, beta), gamma)),\n    F.sub(F.one, dtau)\n  );\n\n  return res;\n}\n\nfunction mulPointEscalar(base, e) {\n  let res = [F.e('0'), F.e('1')];\n  let rem = e;\n  let exp = base;\n\n  while (!Scalar.isZero(rem)) {\n    if (Scalar.isOdd(rem)) {\n      res = addPoint(res, exp);\n    }\n    exp = addPoint(exp, exp);\n    rem = Scalar.shiftRight(rem, 1);\n  }\n\n  return res;\n}\n\nfunction inSubgroup(P) {\n  if (!inCurve(P)) return false;\n  const res = mulPointEscalar(P, exports.subOrder);\n  return F.isZero(res[0]) && F.eq(res[1], F.one);\n}\n\nfunction inCurve(P) {\n  const x2 = F.square(P[0]);\n  const y2 = F.square(P[1]);\n\n  if (\n    !F.eq(\n      F.add(F.mul(exports.A, x2), y2),\n      F.add(F.one, F.mul(F.mul(x2, y2), exports.D))\n    )\n  )\n    return false;\n\n  return true;\n}\n\nfunction packPoint(P) {\n  const buff = utils.leInt2Buff(P[1], 32);\n  if (F.lt(P[0], F.zero)) {\n    buff[31] = buff[31] | 0x80;\n  }\n  return buff;\n}\n\nfunction unpackPoint(_buff) {\n  const buff = Buffer.from(_buff);\n  let sign = false;\n  const P = new Array(2);\n  if (buff[31] & 0x80) {\n    sign = true;\n    buff[31] = buff[31] & 0x7f;\n  }\n  P[1] = utils.leBuff2int(buff);\n  if (Scalar.gt(P[1], exports.p)) return null;\n\n  const y2 = F.square(P[1]);\n\n  let x = F.sqrt(\n    F.div(F.sub(F.one, y2), F.sub(exports.A, F.mul(exports.D, y2)))\n  );\n\n  if (x == null) return null;\n\n  if (sign) x = F.neg(x);\n\n  P[0] = x;\n\n  return P;\n}\n","// Taken and modified from\n// https://github.com/iden3/circomlib\n\n// from https://github.com/Loopring/protocols/blob/master/packages/loopring_v3.js/src/eddsa.ts\n\nimport { F1Field, utils } from 'ffjavascript';\nimport { bigInt } from 'snarkjs';\nimport { createHash } from './poseidon';\nimport babyJub from './babyjub';\nimport createBlakeHash from 'blake-hash';\nimport crypto from 'crypto';\n\nvar assert = require('assert');\n\nfunction getKeyPair() {\n  const entropy = crypto.randomBytes(32);\n  const Fr = new F1Field(babyJub.subOrder);\n  let secretKey = utils.leBuff2int(entropy);\n  secretKey = Fr.e(secretKey);\n\n  // Increment the secretKey until we found a point that is compressable\n  let unpacked = null;\n  while (unpacked == null) {\n    const publicKey = babyJub.mulPointEscalar(babyJub.Base8, secretKey);\n    const packed = this.pack(\n      publicKey[0].toString(10),\n      publicKey[1].toString(10)\n    );\n    unpacked = this.unpack(packed);\n    if (unpacked == null) {\n      secretKey = Fr.add(secretKey, Fr.e('1'));\n    } else {\n      assert(\n        unpacked.publicKeyX === publicKey[0].toString(10),\n        'invalid unpack X'\n      );\n      assert(\n        unpacked.publicKeyY === publicKey[1].toString(10),\n        'invalid unpack Y'\n      );\n    }\n  }\n  assert(\n    babyJub.inCurve([\n      babyJub.F.e(unpacked.publicKeyX),\n      babyJub.F.e(unpacked.publicKeyY),\n    ]),\n    'invalid point'\n  );\n\n  const keyPair = {\n    publicKeyX: unpacked.publicKeyX,\n    publicKeyY: unpacked.publicKeyY,\n    secretKey: secretKey.toString(10),\n  };\n  return keyPair;\n}\n\nfunction pack(publicKeyX, publicKeyY) {\n  const keyX = babyJub.F.e(publicKeyX);\n  const keyY = babyJub.F.e(publicKeyY);\n  const packed = babyJub.packPoint([keyX, keyY]);\n  const reversed = Buffer.alloc(32);\n  for (let i = 0; i < 32; i++) {\n    reversed[31 - i] = packed[i];\n  }\n  return reversed.toString('hex');\n}\n\nfunction unpack(publicKey) {\n  if (publicKey.startsWith('0x')) {\n    publicKey = publicKey.slice(2);\n  }\n  while (publicKey.length < 64) {\n    publicKey = '0' + publicKey;\n  }\n  // Special case for 0\n  if (publicKey === '00'.repeat(32)) {\n    const pubKey = {\n      publicKeyX: '0',\n      publicKeyY: '0',\n    };\n    return pubKey;\n  } else {\n    let packed = Buffer.from(publicKey, 'hex');\n    const reversed = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      reversed[31 - i] = packed[i];\n    }\n    const unpacked = babyJub.unpackPoint(reversed);\n    if (unpacked == null) {\n      return null;\n    }\n    const pubKey = {\n      publicKeyX: unpacked[0].toString(10),\n      publicKeyY: unpacked[1].toString(10),\n    };\n    return pubKey;\n  }\n}\n\nfunction sign(strKey, msg) {\n  const key = bigInt(strKey);\n  const prv = bigInt.leInt2Buff(key, 32);\n\n  const h1 = createBlakeHash('blake512').update(prv).digest();\n  const msgBuff = bigInt.leInt2Buff(bigInt(msg), 32);\n  const rBuff = createBlakeHash('blake512')\n    .update(Buffer.concat([h1.slice(32, 64), msgBuff]))\n    .digest();\n  let r = bigInt.leBuff2int(rBuff);\n  r = r.mod(babyJub.order);\n\n  const A = babyJub.mulPointEscalar(babyJub.Base8, key);\n  const R8 = babyJub.mulPointEscalar(babyJub.Base8, r);\n\n  const hasher = createHash(6, 6, 52);\n  const hm = hasher([R8[0], R8[1], A[0], A[1], msg]);\n  const S = r.add(hm.mul(key)).mod(babyJub.order);\n\n  return {\n    Rx: R8[0].toString(),\n    Ry: R8[1].toString(),\n    s: S.toString(),\n  };\n}\n\nfunction verify(msg, sig, pubKey) {\n  const A = [bigInt(pubKey[0]), bigInt(pubKey[1])];\n  const R = [bigInt(sig.Rx), bigInt(sig.Ry)];\n  const S = bigInt(sig.s);\n\n  // Check parameters\n  if (!babyJub.inCurve(R)) return false;\n  if (!babyJub.inCurve(A)) return false;\n  if (S >= babyJub.subOrder) return false;\n\n  const hasher = createHash(6, 6, 52);\n  const hm = hasher([R[0], R[1], A[0], A[1], bigInt(msg)]);\n\n  const Pleft = babyJub.mulPointEscalar(babyJub.Base8, S);\n  let Pright = babyJub.mulPointEscalar(A, hm);\n  Pright = babyJub.addPoint(R, Pright);\n\n  if (!Pleft[0].equals(Pright[0])) return false;\n  if (!Pleft[1].equals(Pright[1])) return false;\n\n  return true;\n}\n\nfunction generateKeyPair(seed) {\n  const secretKey = bigInt.leBuff2int(seed).mod(babyJub.subOrder);\n  const publicKey = babyJub.mulPointEscalar(babyJub.Base8, secretKey);\n  return {\n    publicKeyX: publicKey[0].toString(10),\n    publicKeyY: publicKey[1].toString(10),\n    secretKey: secretKey.toString(10),\n  };\n}\n\nfunction generatePubKeyFromPrivate(secretKey) {\n  const publicKey = babyJub.mulPointEscalar(babyJub.Base8, bigInt(secretKey));\n  return {\n    publicKeyX: publicKey[0].toString(10),\n    publicKeyY: publicKey[1].toString(10),\n  };\n}\n\nexport default {\n  getKeyPair,\n  pack,\n  unpack,\n  sign,\n  verify,\n  generateKeyPair,\n  generatePubKeyFromPrivate,\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"basic_info_panel\":\"basic_info_basic_info_panel__3363R\",\"basic_info_row\":\"basic_info_basic_info_row__3xkrZ\",\"basic_info_row2\":\"basic_info_basic_info_row2__EZjSM\"};"],"sourceRoot":""}